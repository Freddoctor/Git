export default {
  "data": "<h2 id=\"API文档\">API文档<\/h2>\n<p><span id=\"API\"><\/span><\/p>\n<h4 id=\"helpapihelpnameapi_old\"><a href=\"\/help\/api\/help?name=api_old\">跳转到旧版<\/a><\/h4>\n<p>感谢您使用JoinQuant（聚宽）量化交易平台，以下内容主要介绍聚宽量化交易平台的API使用方法，目录中带有\"♠\" 标识的API是 <code>\"回测环境\/模拟\"<\/code>的专用API，<strong>不能在研究模块中调用<\/strong>。<\/p>\n<p>内容较多，可使用<code>Ctrl+F<\/code>进行搜索。<\/p>\n<p>如果以下内容仍没有解决您的问题，请您通过<a href=\"\/community\">社区提问<\/a>的方式告诉我们，谢谢。<\/p>\n<h2 id=\"开始写策略\">开始写策略<\/h2>\n<p><span id = \"begin_alg\" ><\/span><\/p>\n<h3 id=\"简单但是完整的策略\">简单但是完整的策略<\/h3>\n<p><span id = \"full_alg\" ><\/span><\/p>\n<p>先来看一个简单但是完整的策略:<\/p>\n<pre><code class=\"python language-python\">def initialize(context):\n    # 定义一个全局变量, 保存要操作的股票\n    g.security = '000001.XSHE'\n    # 运行函数\n    run_daily(market_open, time='every_bar')\n\ndef market_open(context):\n    if g.security not in context.portfolio.positions:\n        order(g.security, 1000)\n    else:\n        order(g.security, -800)\n<\/code><\/pre>\n<p>一个完整策略只需要两步:<\/p>\n<ul>\n<li>设置初始化函数: <a href=\"#initialize\">initialize<\/a>,上面的例子中, 只操作一支股票: '000001.XSHE', 平安银行<\/li>\n<li>实现一个函数, 来根据历史数据调整仓位.<\/li>\n<\/ul>\n<p>这个策略里, 每当我们没有股票时就买入1000股, 每当我们有股票时又卖出800股, 具体的下单API请看<a href=\"#order-method\">order<\/a>函数.<\/p>\n<p>这个策略里, 我们有了交易, 但是只是无意义的交易, 没有依据当前的数据做出合理的分析<\/p>\n<p>下面我们来看一个真正实用的策略<\/p>\n<h3 id=\"实用的策略\">实用的策略<\/h3>\n<p><span id = \"useful_alg\" ><\/span><\/p>\n<p>在这个策略里, 我们会根据历史价格做出判断:<\/p>\n<ul>\n<li>如果上一时间点价格高出五天平均价1%, 则全仓买入<\/li>\n<li>如果上一时间点价格低于五天平均价, 则空仓卖出<\/li>\n<\/ul>\n<pre><code class=\"python language-python\"># 导入聚宽函数库\nimport jqdata\n\n# 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 定义一个全局变量, 保存要操作的股票\n    # 000001(股票:平安银行)\n    g.security = '000001.XSHE'\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 运行函数\n    run_daily(market_open, time='every_bar')\n\n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef market_open(context):\n    security = g.security\n    # 获取股票的收盘价\n    close_data = attribute_history(security, 5, '1d', ['close'])\n    # 取得过去五天的平均价格\n    MA5 = close_data['close'].mean()\n    # 取得上一时间点价格\n    current_price = close_data['close'][-1]\n    # 取得当前的现金\n    cash = context.portfolio.cash\n\n    # 如果上一时间点价格高出五天平均价1%, 则全仓买入\n    if current_price &gt; 1.01*MA5:\n        # 用所有 cash 买入股票\n        order_value(security, cash)\n        # 记录这次买入\n        log.info(\"Buying %s\" % (security))\n    # 如果上一时间点价格低于五天平均价, 则空仓卖出\n    elif current_price &lt; MA5 and context.portfolio.positions[security].closeable_amount &gt; 0:\n        # 卖出所有股票,使这只股票的最终持有量为0\n        order_target(security, 0)\n        # 记录这次卖出\n        log.info(\"Selling %s\" % (security))\n    # 画出上一时间点价格\n    record(stock_price=current_price)\n<\/code><\/pre>\n<h2 id=\"策略引擎介绍\">策略引擎介绍<\/h2>\n<p><span id = \"alg_introduce\" ><\/span>\n<span id=\"testing_environment\"><\/span><\/p>\n<h3 id=\"回测环境\">回测环境<\/h3>\n<ol>\n<li>回测引擎运行在Python2.7之上, 请您的策略也兼容Python2.7<\/li>\n<li>我们支持所有的Python标准库和部分常用第三方库, 具体请看: <a href=\"#Python库\">python库<\/a>. 另外您可以把.py文件放在研究根目录, 回测中可以直接import, 具体请看: <a href=\"#自定义python库\">自定义python库<\/a><\/li>\n<li>安全是平台的重中之重, 您的策略的运行也会受到一些限制, 具体请看: <a href=\"#安全\">安全<\/a><\/li>\n<\/ol>\n<p><span id=\"testing_process\"><\/span><\/p>\n<h3 id=\"回测过程\">回测过程<\/h3>\n<ol>\n<li>准备好您的策略,  选择要操作的股票池, 实现handle_data函数<\/li>\n<li>选定一个回测开始和结束日期, 选择初始资金、调仓间隔(每天还是每分钟), 开始回测<\/li>\n<li>引擎根据您选择的股票池和日期, 取得股票数据, 然后每一天或者每一分钟调用一次您的handle_data函数, 同时告诉您现金、持仓情况和股票在上一天或者分钟的数据. 在此函数中, 您还可以调用函数获取任何多天的历史数据, 然后做出调仓决定.<\/li>\n<li>当您下单后, 我们会根据接下来时间的实际交易情况, 处理您的订单. 具体细节参见<a href=\"#订单处理\">订单处理<\/a><\/li>\n<li>下单后您可以调用get_open_orders取得所有未完成的订单, 调用cancel_order取消订单<\/li>\n<li>您可以在handle_data里面调用record()函数记录某些数据, 我们会以图表的方式显示在回测结果页面<\/li>\n<li>您可以在任何时候调用log.info\/debug\/warn\/error函数来打印一些日志<\/li>\n<li>回测结束后我们会画出您的收益和基准(参见<a href=\"#set_benchmark\">set_benchmark<\/a>)收益的曲线,  列出每日持仓,每日交易和一系列风险数据。<\/li>\n<\/ol>\n<p><span id=\"data_introduce\"><\/span><\/p>\n<h3 id=\"数据\">数据<\/h3>\n<ol>\n<li>股票数据：我们拥有所有A股上市公司2005年以来的股票行情数据、<a href=\"\/data\/dict\/fundamentals#市值数据\">市值数据<\/a>、<a href=\"\/data\/dict\/fundamentals\">财务数据<\/a>、<a href=\"\/help\/data\/data?name=jy\">上市公司基本信息<\/a>、<a href=\"\/api#getmtss\">融资融券信息<\/a>等。为了避免<a href=\"http:\/\/zh.wikipedia.org\/zh\/%E5%80%96%E5%AD%98%E8%80%85%E5%81%8F%E5%B7%AE\">幸存者偏差<\/a>，我们包括了已经退市的股票数据。<\/li>\n<li>商品期货：我们支持从2005年以来上海国际能源交易中心、上期所、郑商所、大商所的行情数据，并包含历史产品的数据。<\/li>\n<li>基金数据：我们目前提供了600多种在交易所上市的基金的行情、净值等数据，包含<a href=\"\/data\/dict\/fundData#etf列表\">ETF<\/a>、<a href=\"\/data\/dict\/fundData#lof列表\">LOF<\/a>、<a href=\"\/data\/dict\/fundData#分级基金列表\">分级A\/B基金<\/a>以及<a href=\"\/data\/dict\/fundData#mmf列表\">货币基金<\/a>的完整的行情、净值数据等，请点击<a href=\"\/data\/dict\/fundData\">基金数据<\/a>查看。<\/li>\n<li>金融期货数据：我们提供中金所推出的所有<a href=\"\/data\/dict\/sfData\">金融期货产品<\/a>的行情数据，并包含历史产品的数据。<\/li>\n<li>股票指数：我们支持近600种<a href=\"\/data\/dict\/indexData\">股票指数<\/a>数据，包括指数的行情数据以及成分股数据。为了避免未来函数，我们支持获取历史任意时刻的指数成分股信息，具体见<a href=\"#get_index_stocks\">get_index_stocks<\/a>。注意：指数不能买卖<\/li>\n<li>行业板块：我们支持按行业、按板块选股，具体见<a href=\"#get_industry_stocks\">get_industry_stocks<\/a><\/li>\n<li>概念板块：我们支持按概念板块选股，具体见<a href=\"#get_concept_stocks\">get_concept_stocks<\/a><\/li>\n<li>宏观数据：我们提供全方位的<a href=\"\/data\/dict\/macroData\">宏观数据<\/a>，为投资者决策提供有力数据支持。<\/li>\n<li>所有的行情数据我们均已处理好前复权信息。<\/li>\n<li>我们当日的回测数据会在收盘后通过多数据源进行校验，并在T+1（第二天）的00:01更新。<\/li>\n<li>我们提供的所有行情K线数据为后对其，标识K线的时间为数据的结束时间。在一分钟K线上，没有09:30，从09:31开始，有15:00的K线，共计240根。表示时间为09:31的一分钟K线，其数据时间为09:25:00~09:30:59，这一分钟的开盘价是09:25的集合竞价的价格。\n<span id=\"safe_introduce\"><\/span><\/li>\n<\/ol>\n<h3 id=\"安全\">安全<\/h3>\n<ol>\n<li>保证您的策略安全是我们的第一要务<\/li>\n<li>在您使用我们网站的过程中, 我们全程使用https传输<\/li>\n<li>策略会加密存储在数据库<\/li>\n<li>回测时您的策略会在一个安全的进程中执行, 我们使用了进程隔离的方案来确保系统不会被任何用户的代码攻击, 每个用户的代码都运行在一个有很强限制的进程中:<\/li>\n<\/ol>\n<ul>\n<li><p>只能读指定的一些python库文件<\/p><\/li>\n<li><p>不能写和执行任何文件, 如果您需要保存和读取私有文件, 请看<a href=\"#write_file\">write_file<\/a>\/<a href=\"#read_file\">read_file<\/a><\/p><\/li>\n<li><p>不能创建进程或者线程<\/p><\/li>\n<li><p>限制了cpu和内存, 堆栈的使用<\/p><\/li>\n<li><p>可以访问网络, 但是对带宽做了限制, 下载最大带宽为500KB\/s, 上传带宽为10KB\/s<\/p><\/li>\n<li><p>有严格的超时机制, 如果handle_data超过30分钟则立即停止运行\n对于读取回测所需要的数据, 和输出回测结果, 我们使用一个辅助进程来帮它完成, 两者之间通过管道连接.<\/p>\n<p>我们使用了linux内核级别的apparmer技术来实现这一点.\n有了这些限制我们确保了任何用户不能侵入我们的系统, 更别提盗取他人的策略了.<\/p><\/li>\n<\/ul>\n<p><span id = \"running_frequency\" ><\/span><\/p>\n<h3 id=\"运行频率\">运行频率<\/h3>\n<p><strong>1. Bar 的概念<\/strong><\/p>\n<p>在一定时间段内的时间序列就构成了一根 K 线（日本蜡烛图），单根 K 线被称为 Bar。<\/p>\n<p>如果是一分钟内的 Tick 序列，即构成一根分钟 K 线，又称分钟 Bar;<br \/>\n如果是一天内的分钟序列，即构成一根日线 K 线，又称日线 Bar;<\/p>\n<p>Bar 的示意图如下所示：<\/p>\n<p><img src=\"http:\/\/img0.ph.126.net\/QVCQxL-2IUy6NYG9MD-oRQ==\/6631975962305988684.png\" alt=\"Bar 的示意图\" \/><\/p>\n<p>Bar 就是时间维度上，价格在空间维度上变化构成的数据单元。如下图所示，多个数据单元 Bar 构成的一个时间序列。<\/p>\n<p><img src=\"http:\/\/img1.ph.126.net\/HAVUVlSog-bkwxWOm5UJWw==\/6632518021535809699.png\" alt=\"K线序列\" \/><\/p>\n<p><strong>2. 频率详解<\/strong><\/p>\n<p>下列图片中齿轮为 handle_data(context, data) 的运行时间，before_trading_start(context) 等其他函数运行时间详见<a href=\"#alg_frame\">相关API<\/a>。<\/p>\n<p><strong>频率：天<\/strong><\/p>\n<p>当选择天频率时， 算法在每根日线 Bar 都会运行一次，即每天运行一次。 <\/p>\n<p>在算法中，可以获取任何粒度的数据。 <\/p>\n<p><img src=\"http:\/\/img1.ph.126.net\/bBL80Rm3WkBCYZ331cQ-tA==\/6632136491003641585.png\" alt=\"日K线\" \/><\/p>\n<p><strong>频率：分钟<\/strong><\/p>\n<p>当选择分钟频率时， 算法在每根分钟 Bar 都会运行一次，即每分钟运行一次。<\/p>\n<p>在算法中，可以获取任何粒度的数据。 <\/p>\n<p><img src=\"http:\/\/img2.ph.126.net\/NnyZ_w-rEbBOOdFa0HR0jg==\/6632093610050159615.png\" alt=\"分钟K线\" \/><\/p>\n<p><strong>频率：Tick<\/strong><\/p>\n<p>当选择 Tick 频率时，每当新来一个 Tick，算法都会被执行一次。<\/p>\n<p>执行示意图如下图所示：<\/p>\n<p><img src=\"http:\/\/img0.ph.126.net\/C7zTMuhM2ququLeNGSuMAQ==\/6632092510538531835.png\" alt=\"Tick序列\" \/><\/p>\n<p><span id=\"order_way\"><\/span><\/p>\n<h3 id=\"订单处理\">订单处理<\/h3>\n<p>风险指标数据有利于您对策略进行一个客观的评价。<\/p>\n<p><strong>注意<\/strong>: 无论是回测还是模拟, 所有风险指标(年化收益\/alpha\/beta\/sharpe\/max_drawdown等指标)都只会<strong>每天更新一次, 也只根据每天收盘后的收益计算, 并不考虑每天盘中的收益情况<\/strong>. 例外:<\/p>\n<ul>\n<li>分钟和TICK模拟盘每分钟会更新策略收益和基准收益<\/li>\n<li>按天模拟盘每天开盘后和收盘后会更新策略收益和基准收益<\/li>\n<\/ul>\n<p>那么可能会造成这种现象: 模拟时收益曲线中有回撤, 但是 max_drawdown 可能为0.<\/p>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>回测<\/label>\n      <label>回测订单处理详情<\/label>\n      <article>\n\n使用Bar撮合\n\n- 市价单:\n    - 按天回测\n        - 当 “最新价+滑点” 在涨跌停范围内，则进行撮合，反之撤销\n        - 交易价格: 最新价 + [滑点]，如果在开盘时刻运行， 最新价格为开盘价。 其他情况下， 为上一分钟的最后一个价格。\n        - 最大成交量: 每次下单成交量不会超过该股票当天的总成交量.  可通过选项 [order_volume_ratio](#order_volume_ratio) 设置每天最大的成交量, 例如: 0.25 表示下单成交量不会超过当天成交量的 25%\n        - 注意:\n            - context.portfolio 中的持仓价格会使用上一分钟的最后一个价格更新。\n            - data 是昨天的按天数据, 要想拿到当天开盘价, 请使用 [get_current_data](#get_current_data) 拿取 day_open 字段\n\n    - 分钟回测\n        - 当 “最新价+滑点” 在涨跌停范围内，则进行撮合，反之撤销\n        - 交易价格: 因为我们是在每分钟的第一秒钟执行代码, 所以价格是上一分钟的最后一个价格 + [滑点]\n        - 同按天回测规则, 每次下单成交量不会超过该股票当天的总成交量, [order_volume_ratio](#order_volume_ratio) 同样有效.注意: 这是限制了每个订单的成交量, 当然, 你可以通过一天多次下单来超过一天成交量, 但是, 为了对你的回测负责, 请不要这么做.\n\n    - 所有市价单下单之后同步完成(也即 order_XXX 系列函数返回时完成), context.portfolio 会同步变化\n\n- 限价单\n    - 回测(天、分钟):\n      - 当 委托价 > 最新价+滑点，按市价单模式撮合\n    - 当 委托价 <= 最新价+滑点，则挂单，在Bar结束时按照Bar信息进行撮合：\n      - 当 委托价 > bar 的最低价，则成交价为委托价，成交量不超过 Bar 成交量 * order_volume_ratio\n      - 天、分钟相同\n    - 不是立即完成, 下单之后 context.portfolio.cash 和 context.portfolio.positions 不会同步变化.\n    - 按天模拟交易暂时不支持限价单\n\n- 上述过程中, 如果实际价格已经涨停或者跌停, 则相对应的买单或卖单不成交, 市价单直接取消(log中有警告信息), 限价单会挂单直到可以成交.\n- 一天结束后, 所有未完成的订单会被取消\n- 每次订单完成(完全成交)或者取消后, 我们会根据成交量计算手续费(参见[set_order_cost](#set_order_cost)), 减少您的现金\n- 更多细节, 请看[order](#order-method)函数\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>模拟<\/label>\n      <label>模拟交易订单处理详情<\/label>\n      <article>\n\n##### **1.使用盘口撮合**\n\n- 市价单\n  - 买单：\n    - 根据卖单盘口进行撮合\n    - 优先从卖一档开始撮合，根据成交量算出 加权均价\n    - 成交价： 加权均价\n    - 5档成交剩余撤销：买入时从“卖一\"到“卖五\"价格依次成交，卖出时从“买一”到“买五\"价格依次成交。若无法全部成交，则剩余未匹配量自动撤销\n    - 当前没有盘口时，按照 使用 Bar 处理 处理：\n      - 当成交量不为零为，使用最新价+滑点成交\n      - 当成交量为零，则取消该订单\n  - 卖单：\n    - 根据买单盘口进行撮合\n    - 优先从买一档开始撮合，根据成交量算出 加权均价\n    - 成交价 ： 加权均价\n    - 5档成交剩余撤销：买入时从“卖一\"到“卖五\"价格依次成交，卖出时从“买一”到“买五\"价格依次成交。若无法全部成交，则剩余未匹配量自动撤销\n    - 当前没有盘口时，按照 使用 Bar 处理 处理：\n      - 当成交量不为零为，使用最新价+滑点成交\n      - 当成交量为零，则取消该订单\n\n- 限价单\n  - 买单：\n    - 根据卖单盘口进行撮合\n    - 优先从卖一档开始撮合，直至盘口价格>委托价的档位，根据成交量算出 加权均价\n    - 成交价 ： 加权均价\n    - 当限价单根据盘口撮合完，为部分成交时，剩余委托数量会在 Bar 结束时根据 Bar 信息进行撮合，详情见Bar撮合方式。\n\n  - 卖单：\n    - 根据买单盘口进行撮合\n    - 优先从买一档开始撮合，直至盘口价格<委托价的档位，根据成交量算出 加权均价\n    - 成交价 ： 加权均价\n    - 当限价单根据盘口撮合完，为部分成交时，剩余委托数量会在 Bar 结束时根据 Bar 信息进行撮合，详情见 Bar 撮合方式。\n  - 注意：如模拟盘下限价委托单，并且根据盘口撮合后，订单为部分成交，则该订单完整信息在收盘时更新。\n\n\n##### **2.使用Bar撮合**\n\n- 市价单:\n    - 模拟交易\n        - 当 “最新价+滑点” 在涨跌停范围内，则进行撮合，反之撤销\n        - 交易价格: 最新价 + 滑点\n        - 最大交易量: 不管是按天, 按分钟, 还是按tick, 由于市价单都是同步完成, 下单那一刻无法知道当天成交量, 所以市价单都不考虑成交量, 全量成交.\n\n    - 所有市价单下单之后同步完成(也即 order_XXX 系列函数返回时完成), context.portfolio 会同步变化\n\n- 限价单\n  - 模拟交易(天、分钟、Tick):\n    - 当 委托价 > 最新价+滑点，按市价单模式撮合\n    - 当 委托价 <= 最新价+滑点，则挂单，在Bar结束时按照Bar信息进行撮合：\n      - 当 委托价 > bar 的最低价，则成交价为委托价，成交量不超过 Bar 成交量 * order_volume_ratio\n      - 天、分钟、tick 相同\n      - 按tick, 不是立即完成, 而是下单之后每个tick根据这个tick的分价表撮合一次, 直到完全成交或者当天收盘为止. 同样考虑 [order_volume_ratio](#order_volume_ratio) 选项.\n    - 注意：如模拟盘下限价委托单，订单信息会在收盘后更新。\n\n    - 不是立即完成, 下单之后 context.portfolio.cash 和 context.portfolio.positions 不会同步变化.\n\n    - 按天模拟交易暂时不支持限价单\n\n- 上述过程中, 如果实际价格已经涨停或者跌停, 则相对应的买单或卖单不成交, 市价单直接取消(log中有警告信息), 限价单会挂单直到可以成交.\n- 一天结束后, 所有未完成的订单会被取消\n- 每次订单完成(完全成交)或者取消后, 我们会根据成交量计算手续费(参见[set_order_cost](#set_order_cost)), 减少您的现金\n- 更多细节, 请看[order](#order-method)函数\n\n      <\/article>\n    <\/div>\n\n\n  <\/div>\n<\/section>\n<p><span id=\"split_merge_dividends_\"><\/span><\/p>\n<h3 id=\"拆分合并与分红\">拆分合并与分红<\/h3>\n<ul>\n<li><strong>传统前复权回测模式：<\/strong>当股票发生拆分，合并或者分红时，股票价格会受到影响，为了保证价格的连续性, 我们使用前复权来处理之前的股票价格，给您的所有股票价格已经是前复权的价格。<\/li>\n<li><strong>真实价格（动态复权）回测模式：<\/strong>当股票发生拆分，合并或者分红时，会按照历史情况，对账户进行处理，会在账户账户中增加现金或持股数量发生变化，并会有日志提示。<\/li>\n<\/ul>\n<section>\n  <div class=\"header\">\n    <label>内容<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>传统前复权回测模式 与 真实价格（动态复权）回测模式 区别<\/label>\n      <article>\n\n使用前复权价格，不论回测开始时间、结束时间是何时，使用的数据都是基于今天（回测当天）或某个时间的复权因子进行前复权获得的价格，因此使用前复权价格进行回测，回测结果肯定有问题。示意图如下：\n\n![传统回测模式](http:\/\/img2.ph.126.net\/s5dPwCYVbIKgCRjMAjSDOQ==\/6631803338977829912.jpg)\n\n不论历史时刻1或历史时刻2，拿到的数据都是基于未来某一天的前复权价格，使用这样的数据存在未来函数（未来函数是回测最大的敌人之一）\n\n\n![开启真实价格回测](http:\/\/img1.ph.126.net\/E_KtLi8SEBsWf-tRh1t3IQ==\/6631660402466218474.jpg)\n\n使用真实价格回测模式，回测到历史时刻1，使用历史时刻1的真实价格撮合成交；如果需要复权，会使用的历史时刻1的复权因子，对“历史时刻1\"之前的价格进行前复权，这样有效避免了未来函数，因为回测全程都不可能使用未来的数据。\n\n\n你可能没有看懂，下面举个例子：\n\n![p3](http:\/\/img1.ph.126.net\/Tfq2l-YgvsUWIOHGo8MwFQ==\/6631682392698838639.png)\n\n如现有一只股票，股价一直没有波动，只进行了拆分。\n\n- 前复权回测模式  \n    - 站在“历史时刻3”看历史数据：因为使用今天的复权因子，“历史时刻3”之前的股价均为2；\n    - 站在“历史时刻2”看历史数据：因为使用今天的复权因子，“历史时刻3”的股价是2；\n    - 站在“历史时刻1”看历史数据，因为使用今天的复权因子，“历史时刻2”和“历史时刻3”的股价是2；\n\n- 真实价格回测模式\n    - 站在“历史时刻3”看历史数据：因为使用历史时刻3的复权因子，“历史时刻3”之前的股价均为8\n    - 站在“历史时刻2”看历史数据：因为使用历史时刻2的复权因子，“历史时刻3”的股价是4；\n    - 站在“历史时刻1”看历史数据：因为使用历史时刻1的复权因子，“历史时刻2”和“历史时刻3”的股价是2；\n\n**因为使用了未来的复权因子，前复权回测模式，回测过程中使用的价格是不正确的。**\n\n下面再举一个真实的例子，比较一下前复权回测模式和真实价格回测模式的区别\n\n![GL_pre](http:\/\/img0.ph.126.net\/LHU6vhX5xc4qC_1pIpZTkw==\/6631628516629060053.jpg)\n\n![GL_pre](http:\/\/img0.ph.126.net\/sJw3-sj4vuKBIhbwwNs-EQ==\/4819696026317438817.jpg)\n\n2007-01-30，波导股份的真实股价（绿色曲线）是低于格力电器（黑色曲线）的；但使用前复权价格，波导股份的价格会高于格力电器。\n采用最简单的交易思路，购买股价低的股票并持有，前复权模式会买入格力电器，真实价格回测模式会买入波导股份。\n\n下面我们进行回测，根据2007-01-30当天格力电器与波导股份的收盘价，买入低价位股票并持有到现在。回测结果如下所示：\n\n**前复权回测模式的回测结果：**\n初始资金：100,000\n策略收益：776.54%\n沪深300收益：21.98%\n最大回撤：64.98%\n\n![gbzs](http:\/\/img1.ph.126.net\/BmGLShxJ73EaDjo-n08dmg==\/6631761557536052617.png)\n\n**真实价格回测模式的回测结果：**\n初始资金：100,000\n策略收益：78.35%\n沪深300收益：21.98%\n最大回撤：79.78%\n\n![kqzs](http:\/\/img1.ph.126.net\/P3DxALiXIXufvTDVVQWGAg==\/4855161873383798650.png)\n\n**由回测结果不难看出，前复权回测模式因为存在未来函数，结果是不准确的，使用前复权回测模式可能会让你获得非常高的收益，但实盘时，效果却非常一般；在某些策略中，如使用到价格因子，前复权模式会导致回测中买卖信号与实际中不一致，从而导致回测结果不准确，影响策略在真实场景中的应用。**\n\n\n开启真实价格回测功能\n\n其实很简单，只需一步即可搞定：\n\n在initialize中使用set_option即可，如下所示：\n<pre><code class=\"python language-python\">def initialize(context):\n    set_option('use_real_price', True)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>是否开启动态复权(真实价格)模式对模拟交易的影响<\/label>\n      <article>\n\n近来，很多用户反馈在模拟盘看到的有些股票价格与在炒股软件上看到的不一样，对此表示很疑惑。\n\n这是因为在模拟交易中，在未开启动态复权(真实价格)模式时，我们是使用基于模拟交易创建日期的[**后复权**](http:\/\/baike.baidu.com\/link?url=2BW9tBKYan9fZ9cWCoBTR-DQDMaIahEOwu26zCe1UfrMMflYDE05aZHX4Kxmii0XrOQrJ1fUHV7OPD6ZyrPnXK)价格。\n\n后复权模式示意图如下图所示：\n\n![enter image description here](http:\/\/img2.ph.126.net\/GZV_NYOuirdXrvHkKE3EaQ==\/6631691188793544593.png)\n\n不开启真实价格模拟盘的运算结果是没有错误，只是会让您理解起来更费劲一些。\n\n用户如果想知道今天的真实价格，还需知道模拟创建的日期，并进行复权计算。\n\n为了让用户使用更便于理解、更真实的模拟系统，我们强烈建议您**开启动态复权(真实价格)模式**。开启方式：用户可在代码中调用`set_option('use_real_price', True)`.\n\n开启动态复权(真实价格)模式示意图如下图所示：\n![enter image description here](http:\/\/img0.ph.126.net\/arnwv6gwKRJwleUxIasIww==\/6631743965351683797.png)\n\n\n**开启动态复权(真实)模式后，您看到的价格都是最新的，每到新的一天, 如果持仓中有股票发生了拆合或者分红或者其他可能影响复权因子的情形, 我们会根据复权因子自动调整股票的数量. 但不要跨日期缓存这些 API 返回的结果**\n\n\n## 我们强烈建议您开启动态复权(真实价格)模式，进行模拟与回测！\n\n### **注意：**\n\n1.  开启真实价格回测之后，为了让编写代码简单, 通过history\/attribute_history\/get_price\/SecurityUnitData.mavg\/vwap 等 API 拿到的都是基于当天日期的前复权价格.  另一方面, 你在不同日期调用 history\/attribute_history\/get_price\/SecurityUnitData.mavg\/vwap 返回的价格可能是不一样的, 因为我们在不同日期看到的前复权价格是不一样的. **所以不要跨日期缓存这些 API 返回的结果**.\n2. 每到新的一天, **如果持仓中有股票发生了拆合或者分红或者其他可能影响复权因子的情形, 我们会根据复权因子自动调整股票的数量, 如果调整后的数量是小数, 则向下取整到整数,** 最后为了保证context.portfolio.portfolio_value不变, context.portfolio.cash可能有略微调整.\n3. 更多详情请见 API - [set_option](#set_option)\n\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h3 id=\"股息红利税的计算\">股息红利税的计算<\/h3>\n<p>真实的税率计算方式如下：<\/p>\n<ul>\n<li>分红派息的时候，不扣税；<\/li>\n<li>等你卖出该只股票时，会根据你的股票持有时间（自你买进之日，算到你卖出之日的前一天，下同）超过一年的免税。2015年9月之前的政策是，满一年的收5%。现在执行的是,2015年9月份的新优惠政策：满一年的免税；<\/li>\n<li>等你卖出股票时，你的持有时间在1个月以内（含1个月）的，补交红利的20%税款，券商会在你卖出股票当日清算时直接扣收；<\/li>\n<li>等你卖出股票时，你的持有时间在1个月至1年间（含1年）的，补交红利的10%税款，券商直接扣；<\/li>\n<li>分次买入的股票，一律按照“先进先出”原则，对应计算持股时间；<\/li>\n<li>当日有买进卖出的（即所谓做盘中T+0），收盘后系统计算你当日净额，净额为买入，则记录为今日新买入。净额为卖出，则按照先进先出原则，算成你卖出了你最早买入的对应数量持股，并考虑是否扣税和税率问题。<\/li>\n<\/ul>\n<p>在回测及模拟交易中，由于需要在分红当天将扣税后的分红现金发放到账户，因此无法准确计算用户的持仓时间（不知道股票卖出时间），我们的计算方式是，统一按照 20% 的税率计算的。<\/p>\n<p><span id=\"slippage_introduce\"><\/span><\/p>\n<h3 id=\"滑点\">滑点<\/h3>\n<p>在实战交易中，往往最终成交价和预期价格有一定偏差，因此我们加入了滑点模式来帮助您更好地模拟真实市场的表现。<\/p>\n<p><span id=\"order_cost\"><\/span><\/p>\n<h3 id=\"交易税费\">交易税费<\/h3>\n<p>交易税费包含券商手续费和印花税。您可以通过<a href=\"#set_order_cost\">set_order_cost<\/a>来设置具体的交易税费的参数。<\/p>\n<h5 id=\"\">券商手续费<\/h5>\n<p>中国A股市场目前为双边收费，券商手续费系默认值为万分之三，即0.03%，最少5元。<\/p>\n<h5 id=\"-1\">印花税<\/h5>\n<p>印花税对卖方单边征收，对买方不再征收，系统默认为千分之一，即0.1%。<\/p>\n<p><span id = \"risk-metrics\" ><\/span><\/p>\n<h3 id=\"风险指标\">风险指标<\/h3>\n<p>风险指标数据有利于您对策略进行一个客观的评价。<\/p>\n<p><strong>注意<\/strong>: 无论是回测还是模拟, 所有风险指标(年化收益\/alpha\/beta\/sharpe\/max_drawdown等指标)都只会<strong>每天于17:00左右更新一次, 也只根据每天收盘后的收益计算, 并不考虑每天盘中的收益情况<\/strong>. 例外:<\/p>\n<ul>\n<li>分钟和TICK模拟盘每分钟会更新策略收益和基准收益<\/li>\n<li>按天模拟盘每天开盘后和收盘后会更新策略收益和基准收益<\/li>\n<\/ul>\n<p>那么可能会造成这种现象: 模拟时收益曲线中有回撤, 但是 max_drawdown 可能为0.<\/p>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>Total Returns<\/label>\n      <label>策略收益<\/label>\n      <article>\n\n$$Total\\space Returns=(P_{end}-P_{start})\/P_{start}*100\\%$$$$P_{end}=策略最终股票和现金的总价值$$$$P_{start}=策略开始股票和现金的总价值$$\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>Total Annualized Returns<\/label>\n      <label>策略年化收益<\/label>\n      <article>\n\n$$Total\\space Annualized\\space Returns=R_p=((1+P)^\\frac{250}{n}-1)*100\\%$$$$P=策略收益$$$$n=策略执行天数$$\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>Alpha<\/label>\n      <label>阿尔法<\/label>\n      <article>\n\n投资中面临着系统性风险（即Beta）和非系统性风险（即Alpha），Alpha是投资者获得与市场波动无关的回报。比如投资者获得了15%的回报，其基准获得了10%的回报，那么Alpha或者价值增值的部分就是5%。\n\n$$Alpha=\\alpha=R_p- [R_f+\\beta_p(R_m-R_f)]$$$$R_p=策略年化收益率$$$$R_m=基准年化收益率$$$$R_f=无风险利率（默认0.04）$$$$\\beta_p=策略beta值$$\nAlpha值 | 解释\n--------|--------\nα>0|策略相对于风险，获得了超额收益\nα=0|策略相对于风险，获得了适当收益\nα<0|策略相对于风险，获得了较少收益\n\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>Beta<\/label>\n      <label>贝塔<\/label>\n      <article>\n\n表示投资的系统性风险，反映了策略对大盘变化的敏感性。例如一个策略的Beta为1.5，则大盘涨1%的时候，策略可能涨1.5%，反之亦然；如果一个策略的Beta为-1.5，说明大盘涨1%的时候，策略可能跌1.5%，反之亦然。\n$$Beta=\\beta_p=\\frac{Cov(D_p,D_m)}{Var(D_m)}$$$$D_p=策略每日收益$$$$D_m=基准每日收益$$$$Cov(D_p,D_m)=策略每日收益与基准每日收益的协方差$$$$Var(D_m)=基准每日收益的方差$$\nBeta值 | 解释\n--------|--------\nβ<0|投资组合和基准的走向通常反方向，如空头头寸类\nβ=0|投资组合和基准的走向没有相关性，如固定收益类\n0<β<1|投资组合和基准的走向相同，但是比基准的移动幅度更小\nβ=1|投资组合和基准的走向相同，并且和基准的移动幅度贴近\nβ>1|投资组合和基准的走向相同，但是比基准的移动幅度更大\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>Sharpe<\/label>\n      <label>夏普比率<\/label>\n      <article>\n\n表示每承受一单位总风险，会产生多少的超额报酬，可以同时对策略的收益与风险进行综合考虑。\n$$Sharpe\\space Ratio=\\frac{R_p - R_f}{\\sigma_p}$$$$R_p=策略年化收益率$$$$R_f=无风险利率（默认0.04）$$$$\\sigma_p=策略收益波动率$$\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>Sortino<\/label>\n      <label>索提诺比率<\/label>\n      <article>\n\n表示每承担一单位的下行风险，将会获得多少超额回报。\n$$Sortino\\space Ratio=\\frac{R_p - R_f}{\\sigma_{pd}}$$$$R_p=策略年化收益率$$$$R_f=无风险利率（默认0.04）$$$$\\sigma_{pd}=策略下行波动率$$\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>Information Ratio<\/label>\n      <label>信息比率<\/label>\n      <article>\n\n衡量单位超额风险带来的超额收益。信息比率越大，说明该策略单位跟踪误差所获得的超额收益越高，因此，信息比率较大的策略的表现要优于信息比率较低的基准。合理的投资目标应该是在承担适度风险下，尽可能追求高信息比率。\n$$Information\\space Ratio=\\frac{R_p - R_m}{\\sigma_t}$$$$R_p=策略年化收益率$$$$R_m=基准年化收益率$$$$\\sigma_t=策略与基准每日收益差值的年化标准差$$\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>Algorithm Volatility<\/label>\n      <label>策略波动率<\/label>\n      <article>\n\n用来测量策略的风险性，波动越大代表策略风险越高。\n$$Algorithm\\space Volatility=\\sigma_p=\\sqrt{\\frac{250}{n-1} \\sum_{i=1}^{n}(r_p-\\bar{r_p})^2}$$$$r_p=策略每日收益率$$$$\\bar{r_p}=策略每日收益率的平均值=\\frac{1}{n} \\sum_{i=1}^{n}r_p$$$$n=策略执行天数$$\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>Benchmark Volatility<\/label>\n      <label>基准波动率<\/label>\n      <article>\n\n用来测量基准的风险性，波动越大代表基准风险越高。\n$$Benchmark\\space Volatility=\\sigma_m=\\sqrt{\\frac{250}{n-1} \\sum_{i=1}^{n}(r_m-\\bar{r_m})^2}$$$$r_m=基准每日收益率$$$$\\bar{r_m}=基准每日收益率的平均值=\\frac{1}{n} \\sum_{i=1}^{n}r_m$$$$n=基准执行天数$$\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>Max Drawdown<\/label>\n      <label>最大回撤<\/label>\n      <article>\n\n描述策略可能出现的最糟糕的情况，最极端可能的亏损情况。\n$$Max\\space Drawdown=Max(P_x-P_y)\/P_x$$$$P_x,P_y=策略某日股票和现金的总价值，y>x$$\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>Downside Risk<\/label>\n      <label>下行波动率<\/label>\n      <article>\n\n策略收益下行波动率。和普通收益波动率相比，下行标准差区分了好的和坏的波动。\n$$Downside\\space Risk=\\sigma_{pd}=\\sqrt{\\frac{250}{n} \\sum_{i=1}^{n}(r_p - \\bar{r_{pi}})^2 f(t)}$$$$r_p=策略每日收益率$$$$\\bar{r_{pi}}=策略至第i日平均收益率=\\frac{1}{i} \\sum_{j=1}^{i}r_j$$$$n=策略执行天数$$$$f(t)=1\\space if \\space r_p< \\bar{r_{pi}}$$$$f(t)=0\\space if \\space r_p>=\\bar{r_{pi}}$$\n\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>胜率<\/label>\n      <label>胜率(%)<\/label>\n      <article>\n\n盈利次数在总交易次数中的占比。\n$$胜率 = \\frac{盈利交易次数}{总交易次数}$$\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>日胜率<\/label>\n      <label>日胜率(%)<\/label>\n      <article>\n\n策略盈利超过基准盈利的天数在总交易数中的占比。\n$$日胜率 = \\frac{当日策略收益跑赢当日基准收益的天数}{总交易日数}$$\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>盈亏比<\/label>\n      <label>盈亏比<\/label>\n      <article>\n\n周期盈利亏损的比例。\n$$盈亏比 = \\frac{总盈利额}{总亏损额}$$\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>超额收益<span id = \"excess_income\" ><\/span><\/label>\n      <label>除法版超额收益率说明<\/label>\n      <article>\n\n由于投资的资产变动是有复利效应的，所以净值的变动是符合几何增长过程的，在这种情况中，最自然的“减法”不是减法，而是除法，所以一个更合理的超额收益算法是:\n\n$$\n\\frac{策略收益+100\\%}{基准收益+100\\%}-100\\%\n$$\n\n先看一眼这条线的效果，第一印象就可以发现它和策略线分开了，不是继续黏在一起。\n\n![3.png](https:\/\/joinquant-image.b0.upaiyun.com\/bedfd19ba1c6dffb277f74fa176ecc7c)\n\n回到上面的例子，假如在时间T时策略的净值S是基准B的十倍，那么超额收益线就是:\n\n$$\n\\frac{S}{B}-100\\%=900\\%\n$$\n\n假设在从 T 之后的一年里，策略涨幅 2% 并且基准涨幅 10%，那么，一年之后的超额收益线是:\n\n$$\n\\frac{S\\ast1.02}{B\\ast1.10}-100\\%=1000\\%\\ast92.7\\%-100\\%=827\\%\n$$\n\n低于了之前的 900%，它表明了在这一年里策略跑输了基准。跑输了多少呢？算一下\n\n$$\n\\frac{827\\%+100\\%}{900\\%+100\\%}=\\frac{S\\ast1.02}{B\\ast1.10}\\ast\\frac{B}{S}=\\frac{1.02}{1.10}=92.7\\%\n$$\n\n告诉我们如果我们在时间T的时候用一块钱策略和一块钱基准一起跑（注意这很重要，不是十块钱策略对一块钱基准），那么在一年之后策略的净值只有基准的 92.7%。\n\n使用除法产生的超额收益线上任意两点的数值都可以进行上面的计算，当然这里要展示的并不是教大家如何去算这个数，而是要让大家明白，**只要除法版的超额收益线发生了回撤，就说明在这段时间里策略跑输了基准，而只要超额收益上涨了，就说明策略跑赢了基准**，我们不需要再改时间重新回测就可以知道这个信息了。\n\n举一个可以看出效果的例子，看下图标为 1 和 2 的部分：\n\n![4.png](https:\/\/joinquant-image.b0.upaiyun.com\/453d3f78415b17b4e9c7bc74204d7adc)\n\n-    在 1 的地方，策略和基准都涨了。谁涨的多？看黄线下跌了，所以是基准涨的多。\n-    在 2 的地方策略和基准都跌了。谁跌的多？看黄线又是下跌了，所以是策略跌的多。\n-    在 1 和 2 哪个地方策略输于基准更厉害？在1的地方黄线挖了一个坑，而在 2 的地方黄线下降并不多，所以虽然看起来2的地方策略跌得很厉害，但其实1的那段输于基准更多。\n\n\n除此之外，我们知道回测在14年7月4号的超额收益指标是 150% 左右，并且在16年6月24号是接近 200%，并且根据这条黄线的形状，我们可以判断出：如果我从14年7月4号开始运行这个策略，它会在很长一段时间里跑输基准，然后在红色竖线的地方追平，最后在16年6月24号的地方净值大于基准；我们甚至不需要知道策略和基准的收益曲线都可以做出这个判断。\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>对数轴<\/label>\n      <label>对数轴说明<\/label>\n      <article>\n\n除法版超额收益线解决了多个时间序列在截面上比对的问题，但是同一序列在不同时间的对比还存在着问题。什么问题呢？就是我们没法看清策略在两个不同时间段的涨跌幅的区别。再回顾之前的一个回测的话，\n\n![5.png](https:\/\/joinquant-image.b0.upaiyun.com\/11520ee05b4140738f83a5db07a01d63)\n\n要不是图上标出了最大回撤的位置，我们肯定目测不出最大回撤的位置。这是因为08年的时候策略净值还相对小，回撤个80%所损失的钱也不是那么多；而15年的时候净值是之前的几十倍，就算回撤20%损失也比之前回撤80%的损失多，所以在图上根本对比不出来。再者说，基准线呢？根本都看不见了啊。\n\n和之前一样，这是由于策略净值有着复合增长效应，导致净值上很难表现出很多的信息。这里的解决办法就是把竖轴做一个变换，改成对数轴。\n\n在对数轴的图上，策略（或者基准）在时间T时显示的高度是：\n\n$$\nlog\\left ( 在时间 T 的净值 \\right )\n$$\n\n就像我们之前从减法改成用除法一样，对数log可以把乘法变加法，把除法变减法，\n\n$$\nlog\\left ( x*y \\right )=log\\left ( x \\right )+log\\left ( y \\right )\n$$\n\n$$\nlog\\left ( x \/ y \\right )=log\\left ( x \\right )-log\\left ( y \\right )\n$$\n\n这样，在对数轴的图上，涨跌幅的倍数就不再是乘除关系而是加法关系，这样回测图上就能看出更丰富的信息了。\n\n**举例来说**，策略在时间T的时候净值是 S，在 T+1 时是 2S，在 T+2 时是 4S，也就是说在每个时间段都翻了一倍。那么在普通轴上我们可以看出 T+1 的净值比 T 的净值高很多，但是 T+2 的净值比 T+1 高出更多，然而哪个是阶段的涨幅更大却很难看出。如果改用对数轴，那么在 T 时对数轴上高度是 $log(S)$；在 T+1 时是 $log(2S)=log(2)+log(S)$；在 T+2 时是 $log(4S)=2log(2)+log(S)$。这三个数构成一个等差数列，也就是说在对数轴上它们相互之间的距离是一样的，很容易通过目测看出每个时间段的涨跌幅是一样的。\n\n再举个最大回撤的例子。假设一策略在 08 年高峰时的净值是 S，并且在随后的股灾中回撤 80%，即损失 0.8S；它在 15 年高峰时净值有之前的五十倍，50S，并在股灾中回撤 50%，即 25S。在普通轴上我们根本不可能目测出哪个回撤更大，但如果换到对数轴上，在08年高峰和低点的对数值分别是 $log(S)$ 和 $log(S\/5)=log(S)-log(5)$，那么对数轴上的回撤是 $log(5)$；在15年高峰和低点的对数值分别是 $log(50S)$ 和 $log(25S)=log(50S\/2)= log(50S)-log(2)$，在对数轴上的回撤是 $log(2)$。由于 $log(5)>log(2)$，我们可以很明显地看出 08 年的回撤大于 16 年。\n\n除此之外，策略和基准在同一时间段中的对比也更简单了。假设基准在一段时间里翻了一倍，策略只涨了 50%，那么如果策略净值太大的话我们在普通轴上根本看不出基准有什么变动。在上边我们提到可以根据除法版超额收益的回撤来观测，而另一个方法就是在对数轴上看：在这段时间里基准在对数轴上上升了$log(2)$ 个单位，而基准只上升了 $log(1.5)$ 个单位，很直观，上升多的那个就是赢了。\n\n![6.png](https:\/\/joinquant-image.b0.upaiyun.com\/07bfeb28dc2c4cfaaa982f9af0c525fc)\n\n我们把之前的回测放到对数轴上，净值规模造成的问题荡然无存。08 年回撤巨大，在图上清晰可见。相比之下，16 年的股灾（标注 3 的地方）虽然净值损失很多，但是实际上回撤比 08 年温柔很多，同时凭目测可以看出标注2的阴跌部分回撤和 16 年股灾中差不多。\n\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>对数轴上的超额收益<\/label>\n      <label>对数轴上的超额收益的计算方法<\/label>\n      <article>\n\n对数轴上的超额收益的计算方法为：\n$$\nlog\\left ( \\frac{策略净值}{基准净值} \\right )=log\\left ( 策略净值 \\right )-log\\left ( 基准净值 \\right )\n$$\n\n也就是说，普通轴上的除法版超额收益可以很方便地移植到对数轴上，只要取一个 $log$ 就好。这条曲线集成了上面说过的所有优点。首先，由于log函数是单调的（x小于y的话就有log(x)小于log(y)），那么只要超额收益线在对数轴上上升或下降，就说明它在普通轴上同样也上升或下降，于是可以看出策略在这段时间里是跑赢还是跑输了大盘。另外，在对数轴上，净值的规模效应也被消除了。举例来说，在时间T的时候策略净值 S，基准净值 B，一年之后变动为 3S 和 2B，再假设在多年后的某个时间点策略和基准的净值分别是 10S 和 B，一年后变成 30S 和 2B。在这两个一年期里都是策略翻两倍基准翻一倍，实际上是一样的涨跌幅。在基准轴上超额收益分别是从 S\/B-100% 变到3S\/2B-100%以及从 10S\/B-100% 变到30S\/2B-100%，由于净资产规模的影响，后者在图像上的变动是前者的 10 倍。但是如果改用对数轴，我们看到两个一年期内超额收益的对数分别是从 $log(S\/B)$ 变到 $log(3\/2)+log(S\/B)$ 以及从 $log(10S\/B)$ 变到 $log(3\/2)+log(10S\/B)$，都是得到了$log(3\/2)$ 的增长，反映了在这两个一年期里，策略相对于大盘的表现是一样的。\n\n如何看一个策略是否有稳定的alpha收益？**最直观的方法莫过于看它在对数轴上的超额收益线了，如果那条线是稳定斜向向上的就对了。**\n\n![7.png](https:\/\/joinquant-image.b0.upaiyun.com\/5e63f5f850cfd3b4ece524e6c7aef28e)\n\n先看这个回测，它有着整体很高的超额收益，但是我们也发现了几个明显的黄线回撤，说明它在这些时段跑输大盘的地方。而下面这个策略虽然收益不如上面的高，但是超额收益高稳定得多，黄线看不出明显回撤说明它基本没有跑输大盘的时候。\n\n![8.png](https:\/\/joinquant-image.b0.upaiyun.com\/22c55425f87fc438d4ba8b826a64bb64)\n\n进一步，我们也可以看出这个策略的超额收益都产生于哪些时候。在第一根红线之前超额收益超额收益斜率较大，说明超额收益很高；两根红线的之间的超额收益基本为零；第二根红线之后又开始有了超额收益，但远没有第一个阶段里高。策略什么时候强什么时候弱，哪些时段需要额外的分析研究，或者很多其他的重要信息，都在一条线上一目了然，这是一条不简单的线。\n\n      <\/article>\n    <\/div>\n\n\n  <\/div>\n<\/section>\n<p><span id = \"run_time\" ><\/span><\/p>\n<h3 id=\"运行时间\">运行时间<\/h3>\n<ul>\n<li><p>开盘前(9:00)运行:<\/p>\n<ul>\n<li><a href=\"#run_monthly\">run_monthly<\/a>\/<a href=\"#run_weekly\">run_weekly<\/a>\/<a href=\"#run_daily\">run_daily<\/a>中指定time='before_open'运行的函数<\/li>\n<li><a href=\"#before_trading_start\">before_trading_start<\/a><\/li><\/ul><\/li>\n<li><p>盘中运行:<\/p>\n<ul>\n<li><a href=\"#run_monthly\">run_monthly<\/a>\/<a href=\"#run_weekly\">run_weekly<\/a>\/<a href=\"#run_daily\">run_daily<\/a>中在指定交易时间执行的函数, 执行时间为这分钟的第一秒. 例如: <code>run_daily(func, '14:50')<\/code> 会在每天的14:50:00(精确到秒)执行<\/li>\n<li>[handle_data]<ul>\n<li>按日回测\/模拟, 在9:30:00(精确到秒)运行, <a href=\"#data\">data<\/a>为昨天的天数据<\/li>\n<li>按分钟回测\/模拟, 在每分钟的第一秒运行, 每天执行240次, 不包括11:30和15:00这两分钟, [data]是上一分钟的分钟数据. 例如: 当天第一次执行是在9:30:00, <a href=\"#data\">data<\/a>是昨天14:59这一分钟的分钟数据, 当天最后一次执行是在14:59:00, [data]是14:58这一分钟的分钟数据.<\/li><\/ul><\/li><\/ul><\/li>\n<li><p>收盘后(15:00后半小时内)运行:<\/p>\n<ul>\n<li><a href=\"#run_monthly\">run_monthly<\/a>\/<a href=\"#run_weekly\">run_weekly<\/a>\/<a href=\"#run_daily\">run_daily<\/a>中指定time='after_close'运行的函数<\/li>\n<li><a href=\"#after_trading_end\">after_trading_end<\/a><\/li><\/ul><\/li>\n<li><p>同一个时间点, 总是先运行 run_XXX 指定的函数, 然后是 <a href=\"#before_trading_start\">before_trading_start<\/a>\n, <a href=\"#handle_data\">handle_data<\/a> 和 <a href=\"#after_trading_end\">after_trading_end<\/a><\/p><\/li>\n<li><p>注意:<\/p>\n<ul>\n<li>run_XXX 指定的函数只能有一个参数 <a href=\"#context\">context<\/a>,  <a href=\"#data\">data<\/a> 不再提供, 请使用 <a href=\"#history\">history<\/a>等获取<\/li>\n<li>[initialize] \/ [before_trading_start] \/ [after_trading_end] \/ [handle_data] 都是可选的, 如果不是必须的, 不要实现这些函数, 一个空函数会降低运行速度.<\/li><\/ul><\/li>\n<\/ul>\n<p><span id = \"simulation_matters\" ><\/span><span id = \"模拟盘注意事项\" ><\/span><\/p>\n<h3 id=\"模拟盘注意事项\">模拟盘注意事项<\/h3>\n<ul>\n<li><p>为了避免以不合理的价格对标的进行下单，模拟盘在下单时会检查开盘（9:25）到下单时刻的累积成交量，若为0则会拒绝，提示：WARNING - 该标的截至到目前成交量为0 ，暂时无法成交。<\/p><\/li>\n<li><p>模拟盘在每天运行结束后会保存状态, 结束进程(相当于休眠). 然后在第二天恢复.<\/p><\/li>\n<li><p>进程结束时会保存这些状态:<\/p>\n<ul>\n<li><p>用户账户, 持仓<\/p><\/li>\n<li><p>使用 <a href=\"#pickle\">pickle<\/a> 保存 <a href=\"#g\">g<\/a> 对象. 注意<\/p>\n<ul>\n<li>g 中以 '__' 开头的变量将被忽略, 不会被保存<\/li>\n<li>g 中不能序列化的变量不会被保存, 重启后会不存在. 如果你写了如下的代码:<\/li><\/ul>\n<pre><code class=\"python language-python\">def initialize(context):\n    g.query = query(valuation)\n<\/code><\/pre>\n<ul>\n<li><a href=\"#g\">g<\/a> 将不能被保存, 因为 query() 返回的对象并不能被持久化. 重启后也不会再执行 <a href=\"#initialize\">initialize<\/a>, 使用 g.query 将会抛出 AttributeError 异常。正确的做法是, 在 <a href=\"#process_initialize\">process_initialize<\/a> 中初始化它, 并且名字以 '__' 开头.<\/li><\/ul>\n<pre><code class=\"python language-python\">def process_initialize(context):\n    g.__query = query(valuation)\n<\/code><\/pre>\n<ul>\n<li>注意: 涉及到IO(打开的文件, 网络连接, 数据库连接)的对象是不能被序列化的:<ul>\n<li><code>query(valuation)<\/code> : 数据库连接<\/li>\n<li><code>open(\"some\/path\")<\/code> : 打开的文件<\/li>\n<li><code>requests.get('')<\/code> : 网络连接<\/li><\/ul><\/li><\/ul><\/li>\n<li><p>使用 <a href=\"#pickle\">pickle<\/a> 保存 <a href=\"#context\">context<\/a> 对象, 处理方式跟 <a href=\"#g\">g<\/a> 一样<\/p><\/li>\n<li><p>为了防止恶意攻击, 序列化之后的状态大小不能超过 30M, 如果超出将在保存状态时运行失败. 当超过 20M 时日志中会有警告提示, 请注意日志.<\/p><\/li><\/ul><\/li>\n<li><p>恢复过程是这样的:<\/p>\n<ol>\n<li>加载策略代码, 因为python是动态语言, 编译即运行, 所以全局的(在函数外写的)代码会被执行一遍.<\/li>\n<li>使用保存的状态恢复 [g], [context], 和函数外定义的全局变量.<\/li>\n<li>如果策略代码和上一次运行时发生了修改，而且代码中定义了 [after_code_changed] 函数，则会运行 [after_code_changed] 函数。<\/li>\n<li>执行 [process_initialize], 每次启动时都会执行这个函数.<\/li><\/ol><\/li>\n<li><p>重启后不再执行 <a href=\"#initialize\">initialize<\/a> 函数, <a href=\"#initialize\">initialize<\/a> 函数在整个模拟盘的生命周期中只执行一次. 即使是更改回测后, <a href=\"#initialize\">initialize<\/a> 也不会执行.<\/p><\/li>\n<li><p>模拟盘更改回测之后上述的全局变量(包括 g 和 context 中保存的)不会丢失. 新代码中 <a href=\"#initialize\">initialize<\/a> 不会执行.\n如果需要修改原来的值, 可以在 <a href=\"#after_code_changed\">after_code_changed<\/a> 函数里面修改, 比如, 原来代码是:<\/p>\n<pre><code class=\"python language-python\">a = 1\ndef initialize(context):\n    g.stock = '000001.XSHE'\n<\/code><\/pre>\n<p>代码改成:<\/p>\n<pre><code class=\"python language-python\">a = 2\ndef initialize(context):\n    g.stock = '000002.XSHE'\n<\/code><\/pre>\n<p>执行时, a 仍然是 1, g.stock 仍然是 '000001.XSHE', 要修改他们的值, 必须定义 <a href=\"#after_code_changed\">after_code_changed<\/a>:<\/p>\n<pre><code class=\"python language-python\">def after_code_changed(context):\n    global a\n    a = 2\n    g.stock = '000002.XSHE'\n<\/code><\/pre><\/li>\n<li><p>创建模拟交易时, 如果选择的日期是今天, 则从今天当前时间点开始运行, 应该在当前时间点之前运行的函数不再运行. 比如: 今天10:00创建了<strong>按天<\/strong>的模拟交易, 选择日期是今天, 代码中实现了 handle_data 和 after_trading_end, 则 handle_data 今天不运行, 而 after_trading_end 会在 15:10 运行<\/p><\/li>\n<li><p>当模拟交易在A时间点失败后, 然后在B时间点\"重跑\", 那么 A-B 之间的时间点应该运行的函数不再运行<\/p><\/li>\n<li><p>因为模拟盘资源有限, 为了防止用户创建之后长期搁置浪费资源, 我们做出如下限制: 如果一个模拟盘同时满足下面条件, 则暂缓运行:<\/p>\n<ul>\n<li>模拟盘所有者在最近一个月内访问过聚宽网站<\/li>\n<li>用户的策略在策略擂台\/策略商城上<\/li>\n<li>用户的策略被其他用户购买的<\/li><\/ul>\n<p>当用户重新使用网站后, 第二天会继续运行(会把之前的交易日执行一遍, 并不会跳过日期)<\/p><\/li>\n<li><p>强烈建议模拟盘使用真实价格成交, 即调用 <code>set_option('use_real_price', True)<\/code>. <a href=\"#use_real_price\">更多细节<\/a><\/p><\/li>\n<\/ul>\n<p><span id = \"testing_simulation_difference\" ><\/span><\/p>\n<h3 id=\"模拟交易和回测的差别\">模拟交易和回测的差别<\/h3>\n<p>因为一些原因, 模拟交易现在和回测还是有些微小的差别, 具体如下:<\/p>\n<ul>\n<li><p>市价单的处理:<\/p>\n<ul>\n<li>回测: 成交量不会超过当天成交量(或当天成交量的一部分, 见<a href=\"#order_volume_ratio\">order_volume_ratio<\/a> 选项)<\/li>\n<li>模拟: 默认使用盘口撮合，五档之后转撤销处理；关闭盘口撮合后，如果成交量不为0，则全部成交。<\/li><\/ul>\n<p>这会导致同样的日期同样的程序回测结果可能会和模拟交易结果不一样, 请注意<\/p><\/li>\n<li><p>按天模拟交易暂时不支持限价单, 所有限价单会自动转成市价单<\/p><\/li>\n<li><p>理论上对运行结果不会有影响: 模拟交易进程每天会重启(请看[模拟交易注意事项]). 回测进程一般不会重启, 如果需要重启(比如机器宕机了) 也会做和模拟交易同样的处理.<\/p><\/li>\n<\/ul>\n<p><span id = \"futures_delivery_date\" ><\/span><\/p>\n<h3 id=\"期货交割日\">期货交割日<\/h3>\n<p>期货持仓到交割日，没有手动交割，系统会以当天结算价平仓, 没有手续费, 不会有交易记录.<\/p>\n<p><span id = \"marginsec_close_detail\" ><\/span><\/p>\n<h3 id=\"还券细则\">还券细则<\/h3>\n<ul>\n<li>T+1, 当日融的券当日不能还<\/li>\n<li>还券时要扣除利息<\/li>\n<li>直接还券时, 可以使用当日买入的券还(不受T+1限制), 且优先使用当日买入的券还<\/li>\n<\/ul>\n<h3 id=\"投资组合优化器\">投资组合优化器<\/h3>\n<p><strong>投资组合优化<\/strong>是指应用概率论与数理统计、最优化方法以及线性代数等相关数学理论方法，根据既定目标收益和风险容许程度（例如最大化收益，最小化风险，风险平价等），将投资重新组合，分散风险的过程，它体现了投资者的意愿和投资者所受到的约束，即在一定风险水平下收益最大化或一定收益水平下的风险最小化。<\/p>\n<p>投资组合管理者在设定了投资收益预期、风险预算、相关约束和风险模型之后， 依托优化器的快速计算优势，得到资产配置最优化结果。<\/p>\n<p>由于不同的约束条件、目标函数，会形成不同的优化器，优化器的处理结果依赖用户输入的相关信息，因此投资者对收益率的预期和风险模型本身估计的准确性，都会影响最终的分析结果，再考虑到交易成本等各类因素的影响，所以从用户使用上而言， 没有绝对意义上最好的优化器。对于资产组合优化问题， 我们可以通过使用优化器，进行一个较长时间的回测，测试整个投资过程，在所有组合输入一致的情况下通过策略的绩效对比来看哪一个优化器有更好的表现， 或者更符合自己的需求。<\/p>\n<p>组合优化器支持对股票、基金进行投资优化，支持如下优化模型：<\/p>\n<ul>\n<li>MinVariance - 组合风险最小化（均值-方差优化）<\/li>\n<li>MaxProfit - 组合收益最大化<\/li>\n<li>MaxSharpeRatio - 组合夏普比率最大化<\/li>\n<li>MinTrackingError - 追踪误差最小化<\/li>\n<li>RiskParity - 风险平价<\/li>\n<li>MaxScore - 组合标的打分最大化<\/li>\n<li>MinScore - 组合标的打分最小化<\/li>\n<li>MaxFactorValue - 因子值最大化<\/li>\n<li>MinFactorValue - 因子值最小化<\/li>\n<li>自定义约束条件的优化模型<\/li>\n<\/ul>\n<p>对使用优化器的投资组合管理者来说，只需根据收益预期、风险预算，选择恰当的优化模型，并设定相关的约束限制条件。优化器程序可以基于选定的优化模型，输出优化后的投资权重调整建议。我们会对投资组合优化器的进行持续创新与改进。<\/p>\n<h4 id=\"\">示例<\/h4>\n<p>下面选出上证50成分股的一部分与选定的ETF基金进行组合构成股票池，设定不同的投资组合优化约束条件，并进行回测，测试投资组合优化器对整个投资的影响。<\/p>\n<ul>\n<li><strong>模型1：等权重配置<\/strong><\/li>\n<\/ul>\n<p><img src=\"http:\/\/img2.ph.126.net\/aHl652neKVoidzDJ_8OXXA==\/6597397421124292478.png\" alt=\"enter image description here\" \/><\/p>\n<ul>\n<li><strong>模型2：组合风险平价；股票的总权重限制为0到90%，ETF的总权重限制为0到10%；每只标的权重不超过10%<\/strong><\/li>\n<\/ul>\n<p><img src=\"http:\/\/img0.ph.126.net\/ZjIA6o8tMusvQ-bmLTkbcQ==\/6597885604286753274.png\" alt=\"enter image description here\" \/><\/p>\n<ul>\n<li><strong>模型3：组合风险最小化（最小化组合方差）；组合总权重限制为90%到100%；组合年化收益率目标下限为10%<\/strong><\/li>\n<\/ul>\n<p><img src=\"http:\/\/img1.ph.126.net\/CARmKcPUlb0QRXDJ97g-Kg==\/6631669198563844627.png\" alt=\"enter image description here\" \/><\/p>\n<ul>\n<li><strong>模型4：'人气指标5日均值'最大化；组合年化收益率目标下限为10%；每只标的权重不超过20%<\/strong><\/li>\n<\/ul>\n<p><img src=\"http:\/\/img2.ph.126.net\/JYPUqEhuE58m3fAt1-nr5Q==\/3263983830037255451.png\" alt=\"enter image description here\" \/><\/p>\n<ul>\n<li><strong>模型5：组合夏普比率最大化；每只标的权重不超过10%<\/strong><\/li>\n<\/ul>\n<p><img src=\"http:\/\/img0.ph.126.net\/94ybHamzshdjDaDXUKH0vQ==\/6599295178193111856.png\" alt=\"enter image description here\" \/><\/p>\n<p>回测代码如下,  优化函数API详情见 <a href=\"#portfolio_optimizer\">portfolio_optimizer - 投资组合优化<\/a>：<\/p>\n<pre><code class=\"python language-python\"># 导入函数库\nimport pandas as pd\nfrom jqdata import *\nfrom jqfactor import Factor\nfrom jqlib.optimizer import *\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n\n    # 过滤掉order系列API产生的比error级别低的log\n    log.set_level('order', 'error')\n\n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003,\n                            min_commission=5), type='stock')\n\n    # 优化器设置\n    g.optimizer = 2 #设定使用的优化模型\n    optimize_model = {\n                        1:\"模型1：等权重配置\",\n                        2:\"模型2：组合风险平价；股票的总权重限制为0到90%，ETF的总权重限制为0到10%；每只标的权重不超过10%\",\n                        3:\"模型3：组合风险最小化（最小化组合方差）；组合总权重限制为90%到100%；组合年化收益率目标下限为10%\",\n                        4:\"模型4：'人气指标5日均值'最大化；组合年化收益率目标下限为10%；每只标的权重不超过20%\",\n                        5:\"模型5：组合夏普比率最大化；每只标的权重不超过10%\"\n                      }\n    print(\"优化%s\"%(optimize_model[g.optimizer]))\n\n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      # 开盘前运行\n    run_monthly(before_market_open, monthday=1, time='before_open', reference_security='000300.XSHG')\n      # 开盘运行\n    run_monthly(market_open, monthday=1, time='open', reference_security='000300.XSHG')\n\n## 开盘前运行函数\ndef before_market_open(context):\n    print('调仓日期：%s'%context.current_dt.date())\n\n    # 选出上证50成分股的一部分与选定的ETF基金进行组合,构成股票池。\n    etf = [\n        '159902.XSHE',\n        '159903.XSHE',\n        '510050.XSHG',\n        '510880.XSHG',\n        '510440.XSHG',\n        ]\n    g.buy_list = list(get_index_stocks('000016.XSHG')[-15:]) + etf\n\n## 开盘时运行函数\ndef market_open(context):\n    # 讲不在股票池中的股票卖出\n    sell_list = set(context.portfolio.positions.keys()) - set(g.buy_list)\n    for stock in sell_list:\n        order_target_value(stock, 0)\n\n    # 组合优化模型\n    if g.optimizer == 1:\n        # 模型1：等权重配置\n        optimized_weight = pd.Series(data=[1.0\/len(g.buy_list)]*len(g.buy_list),\n                                    index=g.buy_list)\n    elif g.optimizer == 2:\n        # 模型2：组合风险平价；股票的总权重限制为0到90%，ETF的总权重限制为0到10%；每只标的权重不超过10%\n        optimized_weight = portfolio_optimizer(date=context.previous_date,\n                                    securities = g.buy_list,\n                                    target = RiskParity(count=250, risk_budget=None),# risk_budget 为 None默认为每只股票贡献相等\n                                    constraints = [MarketConstraint('stock', low=0.0, high=0.9),\n                                                  MarketConstraint('etf', low=0.0, high=0.1)],\n                                    bounds=[Bound(0, 0.1)],\n                                    default_port_weight_range=[0., 1.0],\n                                    ftol=1e-09,\n                                    return_none_if_fail=True)\n    elif g.optimizer == 3:\n        # 模型3：组合风险最小化（最小化组合方差）；组合总权重限制为90%到100%；组合年化收益率目标下限为10%\n        optimized_weight = portfolio_optimizer(date=context.previous_date,\n                                    securities = g.buy_list,\n                                    target = MinVariance(count=250),\n                                    constraints = [WeightConstraint(low=0.9, high=1.0),\n                                                   AnnualProfitConstraint(limit=0.1, count=250)],\n                                    bounds=[],\n                                    default_port_weight_range=[0., 1.0],\n                                    ftol=1e-09,\n                                    return_none_if_fail=True)\n    elif g.optimizer == 4:\n        # 模型4：组合标的因子值最大化\n\n        # 定义因子：人气指标5日均值\n        class AR(Factor):\n            name = 'ar'\n            # 每天获取过去五日的数据\n            max_window = 5\n            # 获取的数据是人气指标\n            dependencies = ['AR']\n            def calc(self, data):\n                return data['AR'].mean()\n        # 模型4：'人气指标5日均值'最大化；组合年化收益率目标下限为10%；每只标的权重不超过20%\n        optimized_weight = portfolio_optimizer(date=context.previous_date,\n                                    securities = g.buy_list,\n                                    target = MaxFactorValue(factor=AR, count=1),\n                                    constraints = [AnnualProfitConstraint(limit=0.2, count=250)],\n                                    bounds=[Bound(0, 0.2)],\n                                    default_port_weight_range=[0., 1.0],\n                                    ftol=1e-09,\n                                    return_none_if_fail=True)\n    elif g.optimizer == 5:\n        # 模型5：组合夏普比率最大化；每只标的权重不超过10%\n        optimized_weight = portfolio_optimizer(date=context.previous_date,\n                                    securities = g.buy_list,\n                                    target = MaxSharpeRatio(rf=0.0,weight_sum_equal=0.5, count=250),#无风险利率为0，最大化夏普比率需要约束组合权重的和为0.5\n                                    constraints = [],\n                                    bounds=[Bound(0, 0.1)],\n                                    default_port_weight_range=[0., 1.0],\n                                    ftol=1e-09,\n                                    return_none_if_fail=True)\n\n    # 查看优化结果\n    print(optimized_weight)\n\n    # 优化失败，给予警告\n    if type(optimized_weight) == type(None):\n        print('警告：组合优化失败')\n    # 按优化结果，执行调仓操作\n    else:\n        total_value = context.portfolio.total_value # 获取总资产\n        for stock in optimized_weight.keys():\n            value = total_value * optimized_weight[stock] # 确定每个标的的权重\n            order_target_value(stock, value) # 调整标的至目标权重\n<\/code><\/pre>\n<h2 id=\"策略程序架构♦\">策略程序架构♦<\/h2>\n<p><span id = \"alg_frame\" ><\/span><\/p>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>initialize <span id = \"initialize\" ><\/span> <\/label>\n      <label>初始化函数<\/label>\n      <article>\n<pre><code class=\"python language-python\">initialize(context)\n<\/code><\/pre>\n初始化方法，在整个回测、模拟实盘中最开始执行一次，用于初始一些全局变量\n\n**参数**\ncontext: [Context](#Context)对象, 存放有当前的账户\/股票持仓信息\n\n**返回**\nNone\n\n**示例**<pre><code class=\"python language-python\">def initialize(context):\n    # g为全局变量\n    g.security = \"000001.XSHE\"\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>run_daily\/run_weekly\/run_monthly <span id=\"task_func\"><\/span> <span id=\"run_monthly\"><\/span> <span id=\"run_weekly\"><\/span> <span id=\"run_daily\"><\/span> <\/label>\n      <label>定时运行策略(可选)<\/label>\n      <article>\n\n- run_monthly\n- run_weekly\n- run_daily\n<pre><code class=\"python language-python\">def initialize(context):\n    # 按月运行\n    run_monthly(func, monthday, time='open', reference_security)\n    # 按周运行\n    run_weekly(func, weekday, time='open', reference_security)\n    # 每天内何时运行\n    run_daily(func, time='open', reference_security)\n<\/code><\/pre>\n\n**回测环境\/模拟专用API**\n\n指定每月, 每周或者每天要运行的函数, 可以在具体每月\/周的第几个交易日(或者倒数第几天)的某一分钟执行。\n\n在日级模拟中使用时，如果设置 time='open' 或 time='9:30'，策略的实际运行时间是9:27~9:30之间。策略类获取到逻辑时间(context.current_dt)仍然是 9:30。\n注意只有在使用相同的参照标的时，定时运行函数的优先级别为:run_monthly>run_weekly>run_daily且与函数被注册的顺序无关；handle_data与handle_tick的执行顺序与前述函数无关。用户策略不应该依赖于这些计划任务执行的顺序。 \n\n**调用这些函数后, handle_data可以不实现**\n\n**参数**\n\n参数|解释\n---|---\nfunc|一个函数, 此函数必须接受context参数\nmonthday|每月的第几个交易日, 可以是负数, 表示倒数第几个交易日。如果超出每月总交易日个数，则取临近的交易日执行。（具体见下方注意中的示例）\nweekday|每周的第几个交易日, 可以是负数, 表示倒数第几个交易日。如果超出每周总交易日个数，则取临近的交易日执行。（具体见下方注意中的示例）\ntime|一个字符串,可以是具体执行时间,支持 time 表达式。比如 \"10:00\", \"01:00\", 或者 \"every_bar\", \"open\", \"before_open\", \"after_close\", \"morning\" 和 \"night\"。(具体执行时间如见下方)<br><br>time 表达式具有 'base +\/-offset' 的形式，如：'open-30m'表示开盘前30分钟，'close+1h30m'表示收盘后一小时三十分钟。\nreference_security|时间的参照标的。<br> 如参照 '000001.XSHG'，交易时间为 9:30\\-15:00。<br>如参照'IF1512.CCFX'，2016-01-01之后的交易时间为 9:30\\-15:00，在此之前为 9:15\\-15:15。<br>如参照'A9999.XDCE'，因为有夜盘，因此开始时间为21:00，结束时间为15:00。\n\n\nbase|具体执行时间\n---|---\n具体时间|24小时内的任意时间，如\"10:00\", \"01:00\"\nevery_bar|只能在 run_daily 中调用； **按天**会在每天的开盘时调用一次，**按分钟**会在每天的每分钟运行\nopen|开盘时运行(等同于\"9:30\")\nbefore_open|早上 9:00 运行\nafter_close|下午 15:30 运行\nmorning|早上 8:00 运行\nnight|晚上 20:00 运行\n\n\n**返回值**\nNone\n\n**注意**\n\n- **参数 func 必须是一个全局的函数, 不能是类的成员函数**, 示例:\n<pre><code class=\"python language-python\">def on_week_start(context):\n    pass\n\nclass MyObject(object):\n    def on_week_start2(self, context):\n        pass\n\ndef initialize(context):\n    # OK\n    run_weekly(on_week_start, 1)\n    # 错误, 下面的语句会报错\n    run_weekly(MyObject().on_week_start2, 1)\n<\/code><\/pre>\n\n- 通过[history](#history)\/[attribute_history](#attribute_history)取天数据时, **是不包括当天的数据的**(即使在15:00和after_close里面也是如此), 要取得当天数据, 只能取分钟的\n- 这些函数可以**重复调用**, 比如下面的代码可以在每周的第一个交易日和最后一个交易日分别调用两个函数:\n<pre><code class=\"python language-python\">def on_week_start(context):\n    pass\ndef on_week_end(context):\n    pass\ndef initialize(context):\n    run_weekly(on_week_start, 1)\n    run_weekly(on_week_end, -1)\n<\/code><\/pre>\n\n- 每次调用这些函数都会产生一个新的定时任务, 如果想修改或者删除旧的定时任务, 请先调用 [unschedule_all](#unschedule_all) 来删除所有定时任务, 然后再添加新的.\n\n- 在一月\/一周交易日数不够以致于monthday\/weekday无法满足时, 我们会找这周内最近的一个日期来执行, 比如, 如果某一周只有4个交易日:\n    - 若 weekday == 5, 我们会在第4个交易日执行\n    - 若 weekday == -5, 我们会在第1个交易日执行\n\n  如果要避免这样的行为, 您可以这样做:\n<pre><code class=\"python language-python\">def initialize(context):\n    run_weekly(weekly, 1)\n\ndef weekly(context):\n    if context.current_dt.isoweekday() != 1:\n        # 不在周一, 跳过执行\n        return\n<\/code><\/pre>\n\n**示例**<pre><code class=\"python language-python\">def weekly(context):\n    print 'weekly %s %s' % (context.current_dt, context.current_dt.isoweekday())\n\n\ndef monthly(context):\n    print 'monthly %s %s' % (context.current_dt, context.current_dt.month)\n\n\ndef daily(context):\n    print 'daily %s' % context.current_dt\n\n\ndef initialize(context):\n\n    # 指定每月第一个交易日, 在开盘后十分钟执行\n    run_monthly(monthly, 1, 'open+10m')\n\n    # 指定每周倒数第一个交易日, 在开盘前执行\n    run_weekly(weekly, -1, 'before_open')\n\n    # 指定每天收盘前10分钟运行\n    run_daily(daily, 'close - 10m')\n\n    # 指定每天收盘后执行\n    run_daily(daily, 'after_close')\n\n    # 指定在每天的10:00运行\n    run_daily(daily, '10:00')\n\n    # 指定在每天的01:00运行\n    run_daily(daily, '01:00')\n\n    # 参照股指期货的时间每分钟运行一次, 必须选择分钟回测, 否则每天执行\n    run_daily(daily, 'every_bar', reference_security='IF1512.CCFX')\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>handle_data <span id=\"handle_data\"><\/span> <\/label>\n      <label>运行策略(可选)<\/label>\n      <article>\n<pre><code class=\"python language-python\">handle_data(context, data)\n<\/code><\/pre>\n该函数每个单位时间会调用一次, 如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次。\n\n**该函数依据的时间是股票的交易时间，即 9:30 - 15:00. 期货请使用[定时运行]函数。**\n\n该函数在回测中的非交易日是不会触发的（如回测结束日期为2016年1月5日，则程序在2016年1月1日-3日时，handle_data不会运行，4日继续运行）。\n\n对于使用当日开盘价撮合的日级模拟盘，在9:25集合竞价完成时就可以获取到开盘价，出于减少并发运行模拟盘数量的目的，我们会提前到9:27~9:30之间运行, 策略内获取到逻辑时间(context.current_dt)仍然是 9:30。\n\n**参数**\ncontext: [Context](#Context)对象, 存放有当前的账户\/标的持仓信息\ndata: 一个字典(dict), key是股票代码, value是当时的[SecurityUnitData](#SecurityUnitData) 对象. 存放前一个单位时间(按天回测, 是前一天, 按分钟回测, 则是前一分钟) 的数据. **注意**:\n\n- 为了加速, data 里面的数据是按需获取的, 每次 handle_data 被调用时, data 是空的 dict, 当你使用 `data[security]` 时该 security 的数据才会被获取.\n- data 只在这一个时间点有效, 请不要存起来到下一个 handle_data 再用\n- 注意, 要获取回测当天的开盘价\/是否停牌\/涨跌停价, 请使用 [get_current_data](#get_current_data)\n\n**返回**  \nNone\n\n**示例**<pre><code class=\"python language-python\">def handle_data(context, data):\n    order(\"000001.XSHE\",100)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>before_trading_start <span id=\"before_trading_start\"><\/span> <\/label>\n      <label>开盘前运行策略(可选)<\/label>\n      <article>\n<pre><code class=\"python language-python\">before_trading_start(context)\n<\/code><\/pre>\n该函数会在每天开始交易前被调用一次, 您可以在这里添加一些每天都要初始化的东西.\n\n**该函数依据的时间是股票的交易时间，即该函数启动时间为 9:00. 期货请使用[定时运行](#task_func)函数，time 参数设定为'before_open' 。**\n\n**参数**\ncontext: [Context](#Context)对象, 存放有当前的账户\/股票持仓信息\n\n**返回**\nNone\n\n**示例**<pre><code class=\"python language-python\">def before_trading_start(context):\n    log.info(str(context.current_dt))\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>after_trading_end <span id=\"after_trading_end\"><\/span> <\/label>\n      <label>收盘后运行策略(可选)<\/label>\n      <article>\n<pre><code class=\"python language-python\">after_trading_end(context)\n<\/code><\/pre>\n该函数会在每天结束交易后被调用一次, 您可以在这里添加一些每天收盘后要执行的内容. 这个时候所有未完成的订单已经取消.\n\n**该函数依据的时间是股票的交易时间，即该函数启动时间为 15:30. 期货请使用[定时运行](#task_func)函数，time 参数设定为'after_close' 。**\n\n**参数**\ncontext: [Context](#Context)对象, 存放有当前的账户\/股票持仓信息\n\n**返回**\nNone\n\n**示例**<pre><code class=\"python language-python\">def after_trading_end(context):\n    log.info(str(context.current_dt))\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>on_strategy_end <span id=\"on_strategy_end\"><\/span> <\/label>\n      <label>策略运行结束时调用(可选)<\/label>\n      <article>\n<pre><code class=\"python language-python\">def on_strategy_end(context)\n<\/code><\/pre>\n在回测、模拟交易正常结束时被调用， 失败时不会被调用。\n\n在模拟交易到期结束时也会被调用， 手动在到期前关闭不会被调用。\n\n**参数**\ncontext: [Context](#Context)对象, 存放有当前的账户\/股票持仓信息\n\n**返回**\nNone\n\n**示例**<pre><code class=\"python language-python\">def on_strategy_end(context):\n    print '回测结束'\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n\n    <div class=\"group\">\n      <label>process_initialize <span id=\"process_initialize\"><\/span> <\/label>\n      <label>每次程序启动时运行函数(可选)<\/label>\n      <article>\n<pre><code class=\"python language-python\">process_initialize(context)\n<\/code><\/pre>\n该函数会在每次模拟盘\/回测进程重启时执行, 一般用来初始化一些**不能持久化保存**的内容. 在 [initialize](#initialize) 后执行.\n\n因为模拟盘会每天重启, 所以这个函数会每天都执行.\n\n**参数**\ncontext: [Context](#Context)对象, 存放有当前的账户\/股票持仓信息\n\n**返回**\nNone\n\n**示例**<pre><code class=\"python language-python\">def process_initialize(context):\n    # query 对象不能被 pickle 序列化, 所以不能持久保存, 所以每次进程重启时都给它初始化\n    # 以两个下划线开始, 系统序列化 [g](#g) 时就会自动忽略这个变量, 更多信息, 请看 [g](#g) 和 [模拟盘注意事项](#simulation_matters)\n    g.__q = query(valuation)\n\ndef handle_data(context, data):\n    get_fundamentals(g.__q)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n\n    <div class=\"group\">\n      <label>after_code_changed <span id=\"after_code_changed\"><\/span> <\/label>\n      <label>模拟交易更换代码后运行函数(可选)<\/label>\n      <article>\n<pre><code class=\"python language-python\">after_code_changed(context)\n<\/code><\/pre>\n模拟盘在每天的交易时间结束后会休眠，第二天开盘时会恢复，如果在恢复时发现代码已经发生了修改，则会在恢复时执行这个函数。\n具体的使用场景：可以利用这个函数修改一些模拟盘的数据。\n\n注意: 因为一些原因, 执行回测时这个函数也会被执行一次, 在 [process_initialize](#process_initialize) 执行之前执行.\n\n**参数**\ncontext: [Context](#Context)对象, 存放有当前的账户\/股票持仓信息\n\n**返回**\nNone\n\n**示例**<pre><code class=\"python language-python\">def after_code_changed(context):\n    g.stock = '000001.XSHE'\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>unschedule_all<span id=\"unschedule_all\"><\/span> <\/label>\n      <label>取消所有定时运行(可选)<\/label>\n      <article>\n<pre><code class=\"python language-python\"># 取消所有定时运行\nunschedule_all()\n<\/code><\/pre>\n\n**示例**<pre><code class=\"python language-python\">def process_initialize(context):\n    # 取消所有定时运行\n    unschedule_all()\n    # 设定新的定时运行函数，指定函数在每天的10:00运行\n    run_daily(func, '10:00')\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n\n\n  <\/div>\n<\/section>\n<p><span id = \"alg_api\" ><\/span><\/p>\n<h2 id=\"策略API介绍\">策略API介绍<\/h2>\n<p><span id = \"attention\" ><\/span><\/p>\n<h3 id=\"注意事项\">注意事项<\/h3>\n<ul>\n<li>【取数据函数】【其它函数】目录中带有\"♠\" 标识的API是 <code>\"回测环境\/模拟\"<\/code>专用的API，<strong>不能在研究模块中调用<\/strong>。整个 【jqdata 模块】在研究环境与回测环境下都可以使用.<\/li>\n<li>所有价格单位是元<\/li>\n<li>时间表示:<ul>\n<li>所有时间都是北京时间, 时区:UTC+8<\/li>\n<li>所有时间都是<a href=\"https:\/\/docs.python.org\/2\/library\/datetime.html#datetime.date\">datetime.datetime<\/a>对象<\/li><\/ul><\/li>\n<li>每个交易日结束时自动撤销所有未完成订单， 例如A股是在17:00之后。<\/li>\n<li>下文中提到 Context, SecurityUnitData,  Portfolio,  Position,  Order 对象都是只读的, 尝试修改他们会报错或者无效.<\/li>\n<li>没有python基础的同学请注意, 有的函数的定义中, 某些参数是有值的, 这个值是参数的默认值, 这个参数是可选的, 可以不传.<\/li>\n<li>回测和模拟中，每日下单的最大数量为10000笔<\/li>\n<\/ul>\n<p>如需使用<strong>策略组合或分仓操作<\/strong>，请看<a href=\"#fencang\">策略组合操作<\/a>.<\/p>\n<p><span id=\"set_func\"><\/span><\/p>\n<h3 id=\"策略设置函数\">策略设置函数<\/h3>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n    <div class=\"group\">\n      <label>set_benchmark <span id=\"set_benchmark\"><\/span> <\/label>\n      <label>设置基准<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_benchmark(security)\n<\/code><\/pre>\n\n默认我们选定了沪深300指数的每日价格作为判断您策略好坏和一系列风险值计算的基准. 您也可以使用[set_benchmark]指定其他股票\/指数\/ETF\/自定义组合的价格作为基准。注意：这个函数只能在initialize中调用。\n\n**参数**\n\n- security:股票\/指数\/ETF代码，或者一个dict，key为股票\/指数\/ETF代码，value为小于1的浮点数，代表对应标的的权重，权重之和必须小于等于1（小于1代表基准中部分资金闲置）。\n\n**返回**\nNone\n\n**示例一**<pre><code class=\"python language-python\">set_benchmark('600000.XSHG')\n<\/code><\/pre>\n\n**示例二，设置自定义组合为基准**<pre><code class=\"python language-python\">set_benchmark({'000001.XSHG':0.5,'000300.XSHG':0.3,'600000.XSHG':0.2})\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>set_order_cost <span id=\"set_order_cost\"><\/span> <\/label>\n      <label>设置佣金\/印花税<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_order_cost(cost, type, ref=None)\n<\/code><\/pre>\n\n指定每笔交易要收取的手续费, 系统会根据用户指定的费率计算每笔交易的手续费\n\n**参数**\n\n- cost: OrderCost 对象\n - open_tax，买入时印花税 (只股票类标的收取，基金与期货不收)\n - close_tax，卖出时印花税 (只股票类标的收取，基金与期货不收)\n - open_commission，买入时佣金，申购场外基金的手续费\n - close_commission,  卖出时佣金，赎回场外基金的手续费\n - close_today_commission,  平今仓佣金\n - min_commission, 最低佣金，不包含印花税\n\n- type: 股票、场内基金、场内交易的货币基金、分级A基金、分级B基金、分级母基金、金融期货、期货、债券基金、股票基金、QDII 基金、场外交易的货币基金、混合基金、场外基金，'stock'\/ 'fund' \/ 'mmf' \/'fja'\/'fjb'\/ 'fjm'\/ 'index_futures' \/ 'futures' \/ 'bond_fund' \/ 'stock_fund' \/ 'QDII_fund' \/ 'money_market_fund' \/ ‘mixture_fund' \/ 'open_fund'\n- ref: 参考代码，支持股票代码\/基金代码\/期货合约代码，以及期货的品种，如 '000001.XSHE'\/'510180.XSHG'\/'IF1709'\/'IF'\/'000300.OF'\n\n**注意：针对特定的交易品种类别设置手续费时，必须将ref设为None；若针对特定的交易品种或者标的，需要将type设置为对应的交易品种类别，将ref设置为对应的交易品种或者标的**\n\n\n**默认与示例**\n<pre><code class=\"python language-python\"># 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\nset_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='stock')\n\n# 期货类每笔交易时的手续费是：买入时万分之0.23,卖出时万分之0.23,平今仓为万分之23\nset_order_cost(OrderCost(open_tax=0, close_tax=0, open_commission=0.000023, close_commission=0.000023, close_today_commission=0.0023, min_commission=0), type='index_futures')\n\n# 单独设置 000300.XSHG 的费用\nset_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='stock', ref='000300.XSHG')\n\n# 设置所有期货（包括金融指数期货）的费用\nset_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='futures')\n\n# 对 IF\/IH\/IC 三个品种有效\nset_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='index_futures')\n\n# 单独设置AU期货品种的费用\nset_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='futures', ref='AU')\n\n# 单独设置AU1709合约的费用\nset_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='futures', ref='AU1709')\n<\/code><\/pre>\n\n**注：期货持仓到交割日会以当天结算价平仓, 没有手续费, 不会有交易记录.**\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>set_slippage <span id=\"set_slippage\"><\/span> <\/label>\n      <label>设置滑点<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_slippage(object,type=None, ref=None)\n<\/code><\/pre>\n设定滑点，回测\/模拟时有效.\n\n当您下单后, 真实的成交价格与下单时预期的价格总会有一定偏差, 因此我们加入了滑点模式来帮您更好的模拟真实市场的表现. 我们暂时只支持固定滑点。同时，我们也支持为交易品种和特定的交易标的设置滑点。\n\n**参数**\n- type：交易品种，支持股票、基金、金融期货、期货、债券基金、股票基金、QDII 基金、货币基金、混合基金，'stock'\/ 'fund' \/ 'index_futures' （金融期货）\/ 'futures'（包含股指期货和商品期货） \/ 'bond_fund' \/ 'stock_fund' \/ 'QDII_fund' \/ 'money_market_fund' \/ ‘mixture_fund' 。为None时则应用于全局。当type被设定而ref为None时，表示将滑点应用于交易品种为type的所有交易标的。\n- ref: 标的代码。如要为特定交易标的单独设置滑点，必须同时设置type为交易标的的交易品种。\n\n**固定滑点**\n当您使用固定滑点的时候, 我们认为您的落单的多少并不会影响您最后的成交价格. 您只需要指定一个价差,\n当您下达一个买单指令的时候, 成交的价格等于当时(您执行order函数所在的单位时间)的平均价格加上价差的一半；当您下达一个卖出指令的时候，卖出的价格等于当时的平均价格减去价差的一半.\n价差可以设定为一个固定值或者按照百分比设定。\n\n- 固定值：\n这个价差可以是一个固定的值(比如0.02元, 交易时加减0.01元), 设定方式为：FixedSlippage(0.02)\n-  百分比：\n这个价差可以是是当时价格的一个百分比(比如0.2%, 交易时加减当时价格的0.1%), 设定方式为：PriceRelatedSlippage(0.002)\n- 跳数（期货专用）:\n这个价差可以是合约的价格变动单位（跳数），比如0.02跳，设定方式为：\nStepRelatedSlippage(0.02)\n<pre><code class=\"python language-python\"># 为全部交易品种设定固定值滑点\nset_slippage(FixedSlippage(0.02))\n\n# 为股票设定滑点为百分比滑点\nset_slippage(PriceRelatedSlippage(0.00246),type='stock')\n\n# 为CU1809设定滑点为跳数滑点\nset_slippage(StepRelatedSlippage(0.02),type='future', ref=\"CU1809.XSGE\")\n<\/code><\/pre>\n\n**注：如果您没有调用 set_slippage 函数, 系统默认的滑点是 PriceRelatedSlippage(0.00246)**\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>use_real_price <span id=\"use_real_price\"><\/span> <\/label>\n      <label>设置动态复权(真实价格)模式<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_option('use_real_price', value)\n<\/code><\/pre>\n\n**该设定必须在[initialize](#initialize)中调用**\n设置是否开启动态复权（真实价格）模式，[原理讲解图示](#split_merge_dividends)。默认是False(主要是为了让旧的策略不会出错).\n是否开启动态复权模式对模拟交易是有影响的，[查看详情](#split_merge_dividends)。\n\n**在场外基金中的应用**\n\n1）value=True，表示用基金的单位净值进行撮合成交  \n2）value=False，表示分红再投资，即复权净值进行撮合成交\n\n**参数**\n\n- value: True \/ False\n\n**示例**\n<pre><code class=\"python language-python\"># 开启动态复权模式\nset_option('use_real_price', True)\n<\/code><\/pre>\n\n**是否开启动态复权对于回测及模拟交易的影响：**\n1. [动态复权原理](#split_merge_dividends)\n2. [是否开启动态复权模式对模拟交易的影响](#split_merge_dividends)\n\n- **开启**，value 值为 True: 回测过程中:\n    - 每天看到的当天的价格都是真实的(不复权的)\n    - 使用真实的价格下单, 交易详情和持仓详情里看到的都是真实价格\n    - 为了让编写代码简单, 通过[数据获取函数API](#数据获取函数)  **拿到的都是基于当天日期的前复权价格**. 比如: 回测运行到了2015-01-01这一天, 那么`history(3, '1d', 'close')`取得的就是你穿越到2015-01-01这一天所看到的前复权价格. 另一方面, 你在不同日期调用[数据获取函数API](#数据获取函数)返回的价格可能是不一样的, 因为我们在不同日期看到的前复权价格是不一样的. 所以**不要跨日期缓存这些API返回的结果.**\n    - 每到新的一天, **如果持仓中有股票发生了拆合或者分红或者其他可能影响复权因子的情形, 我们会根据复权因子自动调整股票的数量, 如果调整后的数量是小数, 则向下取整到整数,** 最后为了保证[context].portfolio.portfolio_value不变, [context].portfolio.cash可能有略微调整.\n    - 注意事项:\n        - 如上所说, 不要跨日期缓存[数据获取函数API](#数据获取函数)返回的结果\n        - 开启真实价格回测之后, 回测结果可能会之前不一样, 因为交易时买入数量必须是100的倍数, 使用前复权价格和实际价格能买入的数量是不一样的.\n        - 如果想通过 history 拿到昨天的真实价格, 还是需要用取得价格除以factor, 因为可能今天发生了拆合分红, 导致拿到的昨天的价格是相对于今天的前复权价格.\n\n            ```python\n            s = '000001.XSHE'\n            df = attribute_history(s, 1, '1d', fields=['close', 'factor'])\n            real_close = df['close'][-1] \/ df['factor'][-1]\n            ```\n- **关闭**，value 值为 False: 此选项的核心是选定一个日期作为基准, 保证这个日期的价格是真实价格, 然后调整其他日期的价格. 最终保证所有价格是连续的, 在回测或者模拟交易过程中不同日期看到的价格是一致的. 下面分回测和模拟交易单独做介绍:\n    - 回测: 基准日期是建立回测的日期, 回测过程中所看到的所有价格都是基于此日期的前复权价格. 比如说, 我昨天跑了一个回测, 那么回测过程所有价格都是在昨天所看到的前复权价格. 这会导致两个问题:\n        - 回测过程中使用了前复权价格下单, 这是违背真实场景的, 不能对接实盘的.\n        - 不同的日期建立的回测跑出来的结果可能会有差异, 因为如果这两次回测之间回测的股票发生了拆合或者分红, 会导致回测中看到前复权价格会不一致.\n    - 模拟交易: 基准日期是建立模拟交易的日期, 模拟交易过程所看到的所有价格都是基于此日期调整过的. 为了方便计算, 我举一个虚拟的例子: 某只股票在如下三个日期的实际价格和后复权因子分别是:\n\n|日期|价格|后复权因子|\n|--|--|--|\n|2015-09-01|1|1|\n|2015-10-01|2|2|\n|2015-11-01|4|4|\n\n- 如果你在 09-01 建立了一个模拟交易, 你在不同日期看到的所有价格都是 1\n- 如果你在 10-01 建立了一个模拟交易, 你在不同日期看到的所有价格都是 2\n- 如果你在 11-01 建立了一个模拟交易, 你在不同日期看到的所有价格都是 4\n\n- 为了更好的模拟, 建议大家都设成 True. 将来对接实盘交易时, 此选项会强制设成 True\n\n**注意：** 设置 use_real_price 为 True之后, 如下的按天回测的代码是不对的：\n<pre><code class=\"python language-python\">def initialize(context):\n    g.cached_data = []\n    g.s = '000001.XSHE'\n\ndef handle_data(content, data):\n    g.cached_data.append(data)\n    if len(g.cached_data) &gt; 1:\n        # 如果昨天收盘价比前天涨了5%, 则买入. 这是不对的, 如果昨天早上发生了拆合, 则昨天和前天的股价不具可比性.\n        if g.cached_data[-1][g.s].close &gt; g.cached_data[-2][g.s].close * 1.05:\n            order(g.s, 1000)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>order_volume_ratio <span id=\"order_volume_ratio\"><\/span> <\/label>\n      <label>设置成交量比例<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_option('order_volume_ratio', value)\n<\/code><\/pre>\n设定成交量比例，根据实际行情限制每个订单的成交量.\n\n**参数**\n\n- value: value 是一个 float 值,  默认为0.25, 根据实际行情限制每个订单的成交量.\n    - 对于每一笔订单：\n        - 如果是市价单, 成交量不超过: 每日成交量 * value\n        - 如果是限价单, [限价单撮合](#订单处理)时设定分价表中每一个价格的成交量的比率, 假设某一分钟分价表如下:\n\n            价格|成交量\n            ---|---\n            10.0 | 10\n            10.1 | 11\n            10.2 | 12\n\n        - 撮合时, 按价格 10.0 成交 10 * value 股, 按价格 10.1 成交 11 * value 股, 按价格 10.2 成交 12 * value 股\n\n\n**示例**\n<pre><code class=\"python language-python\"># 设定成交量比例\nset_option('order_volume_ratio', 0.25) # 成交量不超过总成交量的四分之一\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>match_with_order_book <span id=\"match_with_order_book\"><\/span> <\/label>\n      <label>设置是否开启盘口撮合模式<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_option('match_with_order_book', value)\n<\/code><\/pre>\n设定是否使用盘口撮合模式.   **此选项只对模拟盘生效，默认开启**\n\n**参数**\n\n- value: 默认开启\n  - True，开启，使用盘口进行撮合，撮合方式详见[订单处理](#订单处理)\n  - False，关闭，使用 Bar 进行撮合，撮合方式详见[订单处理](#订单处理)\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>set_universe(history专用) <span id=\"set_universe\"><\/span> <\/label>\n      <label>设定股票池<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_universe(security_list)\n<\/code><\/pre>\n设置或者更新此策略要操作的股票池 context.universe. 请注意:\n\n- **该函数现在只用于设定history函数的默认security_list, 除此之外并无其他用处。**\n\n**参数**\n\n- security_list: 股票列表\n\n**返回**\nNone\n\n**示例**\n<pre><code class=\"python language-python\">set_universe(['000001.XSHE', '600000.XSHG'])\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><s>set_commission(已废弃)<\/s><\/label>\n      <label>设定费率<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_commission(object)\n<\/code><\/pre>\n**已废弃。请使用[set_order_cost](#set_order_cost)替代**\n\n指定每笔交易要收取的手续费, 系统会根据用户指定的费率计算每笔交易的手续费\n\n**次函数已废弃，请使用 [set_order_cost - 设置佣金\/印花税](#set_order_cost)**\n\n**参数**\nobject: 一个PerTrade对象\n\n - PerTrade.buy_cost，买入时手续费\n - PerTrade.sell_cost，卖出时手续费\n - PerTrade.min_cost，最少的手续费\n\n默认：PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5)\n每笔交易时的手续费是, 买入时万分之三，卖出时万分之三加千分之一印花税, 每笔交易最低扣5块钱\n      <\/article>\n    <\/div>\n\n<div class=\"group\">\n      <label>disable_cache<span id=\"disable_cache\"><\/span> <\/label>\n      <label>关闭缓存<\/label>\n      <article>\n<pre><code class=\"python language-python\">disable_cache()\n<\/code><\/pre>\n在默认情况下系统启用了缓存以加快运行速度，但在策略内存占用较大时容易超过设置的内存上限而触发系统杀死进程。若用户反复出现策略因内存占用超限而被终止的情况，可以考虑在initialize函数中调用disable_cache来关闭缓存机制。\n\n**注意在关闭缓存后会导致策略运行速度明显下降**。\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h3 id=\"数据获取函数\">数据获取函数<\/h3>\n<p><span id=\"get_data_func\"><\/span> <span id=\"数据获取函数\"><\/span> <span id=\"获取数据函数\"><\/span><\/p>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>get_price <span id=\"get_price\"><\/span> <\/label>\n      <label>获取历史数据，可查询多个标的多个数据字段，返回数据格式为 DataFrame<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_price(security, start_date=None, end_date=None, frequency='daily', fields=None, skip_paused=False, fq='pre', count=None)\n<\/code><\/pre>\n\n获取一支或者多只股票的行情数据, 按天或者按分钟，这里在使用时注意 end_date 的设置， 不要引入未来的数据。\n\n**关于停牌**: 因为此API可以获取多只股票的数据, 可能有的股票停牌有的没有, 为了保持时间轴的一致,\n\n 我们默认没有跳过停牌的日期, 停牌时使用停牌前的数据填充(请看 [SecurityUnitData] 的 paused 属性). 如想跳过, 请使用 skip_paused=True 参数, 同时只取一只股票的信息\n\n**参数**\n\n- security: 一支股票代码或者一个股票代码的list\n- count: **与 start_date 二选一，不可同时使用**. 数量, 返回的结果集的行数, 即表示获取 end_date 之前几个 frequency 的数据\n- start_date: **与 count 二选一，不可同时使用**. 字符串或者 [datetime.datetime]\/[datetime.date] 对象, 开始时间.\n    - 如果 count 和 start_date 参数都没有, 则 start_date 生效, 值是 '2015-01-01'. 注意:\n    - 当取分钟数据时, 时间可以精确到分钟, 比如: 传入 `datetime.datetime(2015, 1, 1, 10, 0, 0)` 或者 `'2015-01-01 10:00:00'`.\n    - 当取分钟数据时, 如果只传入日期, 则日内时间是当日的 00:00:00.\n    - 当取天数据时, 传入的日内时间会被忽略\n- end_date: 格式同上, 结束时间, 默认是'2015-12-31', 包含此日期. **注意: 当取分钟数据时, 如果 end_date 只有日期, 则日内时间等同于 00:00:00, 所以返回的数据是不包括 end_date 这一天的**.\n\n- frequency: 单位时间长度, 几天或者几分钟, 现在支持'Xd','Xm', 'daily'(等同于'1d'), 'minute'(等同于'1m'), X是一个正整数, 分别表示X天和X分钟(不论是按天还是按分钟回测都能拿到这两种单位的数据), 注意, 当X > 1时, fields只支持['open', 'close', 'high', 'low', 'volume', 'money']这几个标准字段,**合成数据的逻辑见下文**. 默认值是daily\n\n- fields: 字符串list, 选择要获取的行情数据字段, 默认是None(表示['open', 'close', 'high', 'low', 'volume', 'money']这几个标准字段), 支持[SecurityUnitData](#SecurityUnitData)里面的所有基本属性,，包含：['open', ' close', 'low', 'high', 'volume', 'money', 'factor', 'high_limit','  low_limit', 'avg', ' pre_close', 'paused']\n\n- skip_paused: 是否跳过不交易日期(包括停牌, 未上市或者退市后的日期). 如果不跳过, 停牌时会使用停牌前的数据填充(具体请看SecurityUnitData的paused属性), 上市前或者退市后数据都为 nan, 但要注意:\n    - 默认为 False\n    - 当 skip_paused 是 True 时, 只能取一只股票的信息\n\n- fq: 复权选项:\n    - `'pre'`: 前复权(根据'use_real_price'选项不同含义会有所不同, 参见[set_option]), 默认是前复权\n    - `None`: 不复权, 返回实际价格\n    - `'post'`: 后复权\n\n**合成数据的逻辑**\n当frequency为X天和X分钟时，代表使用以X为长度的滑动窗口进行合并数据。举例：\n- 9:33:00调用get_price获取1个单位的数据，frequency='5min',表示使用上一交易日14:58、14:59、15:00、本交易日9:31、9:32这5根1分钟K线来合成数据；\n\n- 9:37:00调用get_price获取1个单位的数据，frequency='5min',表示使用本交易日9:32、9:33、9:34、9:35、9:36这5根1分钟K线来合成数据；\n\n\n**返回**\n\n- **请注意, 为了方便比较一只股票的多个属性, 同时也满足对比多只股票的一个属性的需求, 我们在security参数是一只股票和多只股票时返回的结构完全不一样**\n\n- 如果是一支股票, 则返回[pandas.DataFrame]对象, 行索引是[datetime.datetime]对象, 列索引是行情字段名字, 比如'open'\/'close'. 比如: `get_price('000300.XSHG')[:2]` 返回:\n\n|---|open|close|high|low|volume|money|\n|---|---|---|---|---|---|---|\n|2015-01-05 00:00:00|3566.09|3641.54|3669.04|3551.51|451198098.0|519849817448.0|\n|2015-01-06 00:00:00|3608.43|3641.06|3683.23|3587.23|420962185.0|498529588258.0|\n\n- 如果是多支股票, 则返回[pandas.Panel]对象, 里面是很多[pandas.DataFrame]对象, 索引是行情字段(open\/close\/...), 每个[pandas.DataFrame]的行索引是[datetime.datetime]对象, 列索引是股票代号. 比如`get_price(['000300.XSHG', '000001.XSHE'])['open'][:2]`返回:\n\n|---|000300.XSHG|000001.XSHE|\n|---|---|---|\n|2015-01-05 00:00:00|3566.09|13.21|\n|2015-01-06 00:00:00|3608.43|13.09|\n\n- 取多支标的的数据时，**不要获取交易时段不同的标的**，否则会报错。\n\n**示例**<pre><code class=\"python language-python\"># 获取一支股票\ndf = get_price('000001.XSHE') # 获取000001.XSHE的2015年的按天数据\ndf = get_price('000001.XSHE', start_date='2015-01-01', end_date='2015-01-31 23:00:00', frequency='minute', fields=['open', 'close']) # 获得000001.XSHG的2015年01月的分钟数据, 只获取open+close字段\ndf = get_price('000001.XSHE', count = 2, end_date='2015-01-31', frequency='daily', fields=['open', 'close']) # 获取获得000001.XSHG在2015年01月31日前2个交易日的数据\ndf = get_price('000001.XSHE', start_date='2015-12-01 14:00:00', end_date='2015-12-02 12:00:00', frequency='1m') # 获得000001.XSHG的2015年12月1号14:00-2015年12月2日12:00的分钟数据\n\n# 获取多只股票\npanel =  get_price(get_index_stocks('000903.XSHG')) # 获取中证100的所有成分股的2015年的天数据, 返回一个[pandas.Panel]\ndf_open = panel['open']  # 获取开盘价的[pandas.DataFrame],  行索引是[datetime.datetime]对象, 列索引是股票代号\ndf_volume = panel['volume']  # 获取交易量的[pandas.DataFrame]\n\ndf_open['000001.XSHE'] # 获取平安银行的2015年每天的开盘价数据\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>history ♠ <span id=\"history\"><\/span> <\/label>\n      <label>获取历史数据，可查询多个标的单个数据字段，返回数据格式为 DataFrame 或 Dict(字典)<\/label>\n      <article>\n<pre><code class=\"python language-python\">history(count, unit='1d', field='avg', security_list=None, df=True, skip_paused=False, fq='pre')\n<\/code><\/pre>\n**回测环境\/模拟专用API**\n\n查看历史的行情数据。\n\n**关于停牌**: 因为获取了多只股票的数据, 可能有的股票停牌有的没有, 为了保持时间轴的一致, 我们默认没有跳过停牌的日期, 停牌时使用停牌前的数据填充(请看[SecurityUnitData]的paused属性). 如想跳过, 请使用 skip_paused=True 参数\n\n**当取天数据时, 不包括当天的, 即使是在收盘后**\n\n**参数**\n\n- count: 数量, 返回的结果集的行数\n- unit: 单位时间长度, 几天或者几分钟, 现在支持'Xd','Xm', X是一个正整数, 分别表示X天和X分钟(不论是按天还是按分钟回测都能拿到这两种单位的数据), 注意, 当X > 1时, field只支持['open', 'close', 'high', 'low', 'volume', 'money']这几个标准字段.\n- field: 要获取的数据类型, 支持[SecurityUnitData](#SecurityUnitData)里面的所有基本属性,，包含：['open', ' close', 'low', 'high', 'volume', 'money', 'factor', 'high_limit','  low_limit', 'avg', ' pre_close', 'paused']\n- security_list: \n  - 要获取数据的股票列表\n  - None 表示查询 context.universe 中所有股票的数据，context.universe 需要使用[set_universe](#set_universe)进行设定，形如：set_universe(['000001.XSHE', '600000.XSHG'])。\n- df: 若是True, 返回[pandas.DataFrame], 否则返回一个dict, 具体请看下面的返回值介绍. 默认是True.\n我们之所以增加df参数, 是因为[pandas.DataFrame]创建和操作速度太慢, 很多情况并不需要使用它. 为了保持向上兼容, df默认是True, 但是如果你的回测速度很慢, 请考虑把df设成False.\n- skip_paused: 是否跳过不交易日期(包括停牌, 未上市或者退市后的日期). 如果不跳过, 停牌时会使用停牌前的数据填充(具体请看SecurityUnitData的paused属性), 上市前或者退市后数据都为 nan, 但要注意:\n    - 默认为 False\n    - 如果跳过, 则行索引不再是日期, 因为不同股票的实际交易日期可能不一样\n\n- fq: 复权选项:\n    - `'pre'`: 前复权(根据'use_real_price'选项不同含义会有所不同, 参见[set_option]), 默认是前复权\n    - `None`: 不复权, 返回实际价格\n    - `'post'`: 后复权\n\n**返回**\n\n- df=True:\n    [pandas.DataFrame]对象, 行索引是[datetime.datetime]对象, 列索引是股票代号. 比如: 如果当前时间是2015-01-07, universe是['000300.XSHG', '000001.XSHE'], `history(2, '1d', 'open')`将返回:\n\n|---|000300.XSHG|000001.XSHE|\n|---|---|---|\n|2015-01-05 00:00:00|3566.09|13.21|\n|2015-01-06 00:00:00|3608.43|13.09|\n\n关于numpy和pandas, 请看下面的第三方库介绍\n\n- df=False:\n    dict, key是股票代码, 值是一个numpy数组[numpy.ndarray], 对应上面的DataFrame的每一列, 例如`history(2, '1d', 'open', df=False)`将返回:\n    ```python\n    {\n        '000300.XSHG': array([ 3566.09,  3608.43]),\n        '000001.XSHE': array([ 13.21,  13.09])\n    }\n    ```\n\n**示例**<pre><code class=\"python language-python\">h = history(5, security_list=['000001.XSHE', '000002.XSHE'])\nh['000001.XSHE'] #000001(平安银行)过去5天的每天的平均价, 一个pd.Series对象, index是datatime\nh['000001.XSHE'][-1] #000001(平安银行)昨天(数组最后一项)的平均价\nh.iloc[-1] #所有股票在昨天的平均价, 一个pd.Series对象, index是股票代号\nh.iloc[-1]['000001.XSHE'] #000001(平安银行)昨天(数组最后一项)的平均价\nh.mean() # 取得每一列的平均值\n<\/code><\/pre><pre><code class=\"python language-python\">## set_universe 之后可以，调用 history 可以不用指定 security_list\nset_universe(['000001.XSHE']) # 设定universe\nhistory(5) # 获取universe中股票的过去5天(不包含今天)的每天的平均价\nhistory(5, '1m') # 获取universe中股票的过去5分钟(不包含当前分钟)的每分钟的平均价\nhistory(5, '1m', 'price') # 获取universe中股票的过去5分钟(不包含当前分钟)的每分钟的平均价\nhistory(5, '1m', 'volume') # 获取universe中股票的过去5分钟(不包含当前分钟)的每分钟的交易额\nhistory(5, '1m', 'price', ['000001.XSHE']) # 获取平安银行的过去5分钟(不包含当前分钟)的每分钟的平均价\n<\/code><\/pre><pre><code class=\"python language-python\">h = history(5, security_list=['000001.XSHE', '000002.XSHE'], df=False)\nh['000001.XSHE'] #h 是一个 dict，获取 h 中 000001.XSHE 对应的值。\nh['000001.XSHE'][0] #返回000001.XSHE最新一日的数据\nh['000001.XSHE'][-1] #返回000001.XSHE第五天的数据\nh['000001.XSHE'].sum() #对返回的五日数据求和\nh['000001.XSHE'].mean() # 对返回的五日数据求平均\n# 因为h本身是一个dict, 下列panda.DataFrame的特性将不可用:\n# h.illoc[-1]\n# h.sum()\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>attribute_history ♠ <span id=\"attribute_history\"><\/span> <\/label>\n      <label>获取历史数据，可查询单个标的多个数据字段，返回数据格式为 DataFrame 或 Dict(字典)<\/label>\n      <article>\n<pre><code class=\"python language-python\">attribute_history(security, count, unit='1d',\n            fields=['open', 'close', 'high', 'low', 'volume', 'money'],\n            skip_paused=True, df=True, fq='pre')\n<\/code><\/pre>\n**回测环境\/模拟专用API**\n\n查看某一支股票的历史数据, 可以选这只股票的多个属性, **默认跳过停牌日期**.\n\n**当取天数据时, 不包括当天的, 即使是在收盘后**\n\n**参数**\n\n- security: 股票代码\n- count: 数量, 返回的结果集的行数\n- unit: 单位时间长度, 几天或者几分钟, 现在支持 'Xd', 'Xm', X是一个正整数, 分别表示X天和X分钟(不论是按天还是按分钟回测都能拿到这两种单位的数据), 注意, 当 X > 1 时, field 只支持 ['open', 'close', 'high', 'low', 'volume', 'money'] 这几个标准字段.\n- fields: 股票属性的list, 支持[SecurityUnitData](#SecurityUnitData)里面的所有基本属性，包含：['open', ' close', 'low', 'high', 'volume', 'money', 'factor', 'high_limit','  low_limit', 'avg', ' pre_close', 'paused']\n- skip_paused: 是否跳过不交易日期(包括停牌, 未上市或者退市后的日期). 如果不跳过, 停牌时会使用停牌前的数据填充(具体请看[SecurityUnitData]的paused属性), 上市前或者退市后数据都为 nan, **默认是True**\n- df: 若是True, 返回[pandas.DataFrame], 否则返回一个dict, 具体请看下面的返回值介绍. 默认是True.我们之所以增加df参数, 是因为[pandas.DataFrame]创建和操作速度太慢, 很多情况并不需要使用它. 为了保持向上兼容, df默认是True, 但是如果你的回测速度很慢, 请考虑把df设成False.\n\n- fq: 复权选项:\n    - `'pre'`: 前复权(根据'use_real_price'选项不同含义会有所不同, 参见[set_option]), 默认是前复权\n    - `None`: 不复权, 返回实际价格\n    - `'post'`: 后复权\n\n**返回**\n\n- df=True\n    [pandas.DataFrame]对象, 行索引是[datetime.datetime]对象, 列索引是属性名字. 比如: 如果当前时间是2015-01-07, `attribute_history('000300.XSHG', 2)`将返回:\n\n|---|open|close|high|low|volume|money|\n|---|---|---|---|---|---|---|\n|2015-01-05 00:00:00|3566.09|3641.54|3669.04|3551.51|451198098.0|519849817448.0|\n|2015-01-06 00:00:00|3608.43|3641.06|3683.23|3587.23|420962185.0|498529588258.0|\n\n- df=False:\n    dict, key是股票代码, 值是一个numpy数组[numpy.ndarray], 对应上面的DataFrame的每一列, 例如`attribute_history('000300.XSHG', 2, df=False)`将返回:\n    ```python\n    {\n        'volume': array([  4.51198098e+08,   4.20962185e+08]),\n        'money': array([  5.19849817e+11,   4.98529588e+11]),\n        'high': array([ 3669.04,  3683.23]),\n        'low': array([ 3551.51,  3587.23]),\n        'close': array([ 3641.54,  3641.06]),\n        'open': array([ 3566.09,  3608.43])\n    }\n    ```\n\n**示例**<pre><code class=\"python language-python\">stock = '000001.XSHE'\nh = attribute_history(stock, 5, '1d', ('open','close', 'volume', 'factor')) # 取得000001(平安银行)过去5天的每天的开盘价, 收盘价, 交易量, 复权因子\n# 不管df等于True还是False, 下列用法都是可以的\nh['open'] #过去5天的每天的开盘价, 一个pd.Series对象, index是datatime\nh['close'][-1] #昨天的收盘价\nh['open'].mean()\n\n# 下面的pandas.DataFrame的特性, df=False时将不可用\n# 行的索引可以是整数, 也可以是日期的各种形式:\nh['open']['2015-01-05']\nh['open'][datetime.date(2015, 1, 5)]\nh['open'][datetime.datetime(2015, 1, 5)]\n\n# 按行取数据\nh.iloc[-1] #昨天的开盘价和收盘价, 一个pd.Series对象, index是字符串:'open'\/'close'\nh.iloc[-1]['open'] #昨天的开盘价\nh.loc['2015-01-05']['open']\n\n# 高级运算\nh = h[h['volume'] &gt; 1000000] # 只保留交易量&gt;1000000股的行\nh['open'] = h['open']\/h['factor'] #让open列都跟factor列相除, 把价格都转化成原始价格\nh['close'] = h['close']\/h['factor']\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n\n    <div class=\"group\">\n      <label>get_bars<span id=\"get_bars\"><\/span> <\/label>\n      <label>获取历史数据(包含快照数据)，可查询单个标的多个数据字段，返回数据格式为 numpy.ndarray<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_bars(security, count, unit='1d',\n                 fields=['date', 'open','high','low','close'],\n                 include_now=False, end_dt=None, fq_ref_date=None)\n<\/code><\/pre>\n\n获取各种时间周期的 bar 数据， bar 的分割方式与主流股票软件相同， 而且支持返回当前时刻所在 bar 的数据。\n\n**参数**\n\n- security: 股票代码\n- count: 大于0的整数，表示获取bar的个数。如果行情数据的bar不足count个，返回的长度则小于count个数。\n- unit: bar的时间单位, 支持如下周期：'1m', '5m', '15m', '30m', '60m', '120m', '1d', '1w', '1M'。'1w' 表示一周，‘1M' 表示一月。\n- fields: 获取数据的字段， 支持如下值：'date', 'open', 'close', 'high', 'low', 'volume', 'money'\n- include_now:  取值True 或者False。 表示是否包含当前bar, 比如策略时间是9:33，unit参数为5m， 如果 include_now=True,则返回9:30-9:33这个分钟 bar。\n- end_dt：查询的截止时间，支持的类型为datetime.datetime或None。为None在回测模拟环境下默认为context.current_dt，在研究环境下默认为datetime.now()，支持的格式为。\n- fq_ref_date：复权基准日期，为None时为不复权数据。注意**在回测及模拟交易中，默认为None，即不复权数据；在研究环境中，默认复权基准日期为当天**。\n\n\n**返回**\n\n一个 numpy.ndarray 对象。可以通过 array['close'] 的方式直接访问列数据。\n\n**示例**\n<pre><code class=\"python language-python\">array = get_bars('000001.XSHG', 5, unit='1d',fields=['open','close'],include_now=False)\narray['close']\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n\n    <div class=\"group\">\n      <label>get_current_data ♠ <span id=\"get_current_data\"><\/span> <\/label>\n      <label>获取当前时间数据<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_current_data()\n<\/code><\/pre>\n**回测环境\/模拟专用API**\n\n获取当前单位时间（当天\/当前分钟）的涨跌停价, 是否停牌，当天的开盘价等。\n\n回测时, 通过 API 获取到的是前一个单位时间(天\/分钟)的数据, 而有些数据, 我们在这个单位时间是知道的, 比如涨跌停价, 是否停牌, 当天的开盘价. 我们添加了这个API用来获取这些数据.\n\n**参数**\n\n- 现在不需要传入, 即使传入了, 返回的 dict 也是空的, dict 的 value 会按需获取.\n\n**返回值**\n一个dict, 其中 key 是股票代码, value 是拥有如下属性的对象\n\n- last_price : 最新价\n- high_limit: 涨停价\n- low_limit: 跌停价\n- paused: 是否停止或者暂停了交易, 当停牌、未上市或者退市后返回 True\n- is_st: 是否是 ST(包括ST, *ST)，是则返回 True，否则返回 False\n- day_open: 当天开盘价\n- name: 股票现在的名称, 可以用这个来判断股票当天是否是 ST, *ST, 是否快要退市\n- industry_code: 股票现在所属行业代码, 参见 [行业概念数据](\/data\/dict\/plateData)\n\n**注意**\n\n- 为了加速, 返回的 dict 里面的数据是按需获取的, dict 初始是空的, 当你使用 `current_data[security]` 时(假设 current_data 是返回的 dict), 该 security 的数据才会被获取.\n- 返回的结果只在当天有效, 请不要存起来到隔天再用\n- 该函数仅仅限在要获取数据的标的在交易时段时调用\n\n**示例**<pre><code class=\"python language-python\">def handle_data(context, data):\n    current_data = get_current_data()\n    print current_data\n    print current_data['000001.XSHE']\n    print current_data['000001.XSHE'].paused\n    print current_data['000001.XSHE'].day_open\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_extras <span id=\"get_extras\"><\/span> <\/label>\n      <label>获取基金单位\/累计净值，期货结算价\/持仓量等<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_extras(info, security_list, start_date='2015-01-01', end_date='2015-12-31', df=True, count=None)\n<\/code><\/pre>\n得到多只标的在一段时间的如下额外的数据:\n\n- is_st: 是否是ST，是则返回 True，否则返回 False\n- acc_net_value: 基金累计净值\n- unit_net_value: 基金单位净值\n- futures_sett_price: 期货结算价\n- futures_positions: 期货持仓量\n- adj_net_value: 场外基金的复权净值\n\n**参数**\n\n- info: ['is_st', 'acc_net_value', 'unit_net_value', 'futures_sett_price', 'futures_positions'] 中的一个\n- security_list: 股票列表\n- start_date\/end_date: 开始结束日期, 同 [get_price]\n- df: 返回[pandas.DataFrame]对象还是一个dict, 同 [history]\n- count: 数量, **与 start_date 二选一, 不可同时使用**, 必须大于 0. 表示取 end_date 往前的 count 个交易日的数据\n\n**返回值**\n\n- df=True:\n    [pandas.DataFrame]对象, 列索引是股票代号, 行索引是[datetime.datetime], 比如`get_extras('acc_net_value', ['510300.XSHG', '510050.XSHG'], start_date='2015-12-01', end_date='2015-12-03')`返回:\n\n|---|510300.XSHG|510050.XSHG|\n|---|---|---|\n|2015-12-01 00:00:00|1.395|3.119|\n|2015-12-02 00:00:00|1.4432|3.251|\n|2015-12-03 00:00:00|1.4535|3.254|\n\n`get_extras('is_st', ['000001.XSHE', '000018.XSHE'], start_date='2013-12-01', end_date='2013-12-03')`返回:\n\n|---|000001.XSHE|000018.XSHE|\n|---|---|---|\n|2013-12-02 00:00:00|False|True|\n|2013-12-03 00:00:00|False|True|\n\n- df=False\n    一个dict, key是基金代号, value是[numpy.ndarray], 比如`get_extras('acc_net_value', ['510300.XSHG', '510050.XSHG'], start_date='2015-12-01', end_date='2015-12-03', df=False)` 返回:<pre><code class=\"python language-python\">{\n    u'510050.XSHG': array([ 3.119,  3.251,  3.254]),\n    u'510300.XSHG': array([ 1.395 ,  1.4432,  1.4535])\n}\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_factor_values <span id=\"get_factor_values\"><\/span> <\/label>\n      <label>质量、基础、情绪、成长、风险、每股等数百个因子数据<\/label>\n      <article>\n<pre><code class=\"python language-python\"># 导入函数库\nfrom jqfactor import get_factor_values\n# 取值函数\nget_factor_values(securities, factors, start_date, end_date, count)\n<\/code><\/pre>\n\n获取质量因子、基础因子、情绪因子、成长因子、风险因子、每股因子等数百个因子数据，详细的因子列表请参考[因子库](\/help\/api\/help?name=factor_values)\n\n**参数**\n\n- securities:股票池，单只股票（字符串）或一个股票列表\n- factors: 因子名称，单个因子（字符串）或一个因子列表\n- start_date:开始日期，字符串或 datetime 对象，与 coun t参数二选一\n- end_date: 结束日期， 字符串或 datetime 对象，可以与 start_date 或 count 配合使用\n- count: 截止 end_date 之前交易日的数量（含 end_date 当日），与 start_date 参数二选一\n\n**返回**\n- 一个 dict： key 是因子名称， value 是 pandas.dataframe。\n- dataframe 的 index 是日期， column 是股票代码， value 是因子值\n\n**示例**\n<pre><code class=\"python language-python\"># 导入函数库\nfrom jqfactor import get_factor_values\n\n# 获取因子Skewness60(个股收益的60日偏度)从 2017-01-01 至 2017-03-04 的因子值\nfactor_data = get_factor_values(securities=['000001.XSHE'], factors=['Skewness60'], start_date='2017-01-01', end_date='2017-03-04')\n# 查看因子值\nfactor_data['Skewness60']\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n\n\n    <div class=\"group\">\n      <label>get_fundamentals <span id=\"get_fundamentals\"><\/span> <\/label>\n      <label>查询财务数据<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_fundamentals(query_object, date=None, statDate=None)\n<\/code><\/pre>\n查询财务数据，详细的数据字段描述请点击<a href=\"\/data\/dict\/fundamentals\" target=\"_blank\">财务数据文档<\/a>查看\n\ndate和statDate参数只能传入一个:\n\n- 传入date时, 查询**指定日期date收盘后所能看到的最近(对市值表来说, 最近一天, 对其他表来说, 最近一个季度)的数据**, 我们会查找上市公司在这个日期之前(包括此日期)发布的数据, 不会有未来函数.\n- 传入statDate时, 查询 **statDate 指定的季度或者年份的财务数据**. 注意:\n1. 由于公司发布财报不及时, 一般是看不到当季度或年份的财务报表的, 回测中使用这个数据可能会有未来函数, 请注意规避.\n2. 由于估值表每天更新, 当按季度或者年份查询时, 返回季度或者年份最后一天的数据\n3. 由于“资产负债数据”这个表是存量性质的， 查询年度数据是返回第四季度的数据。\n4. 银行业、券商、保险专项数据只有年报数据，需传入statDate参数，当传入 date 参数 或 statDate 传入季度时返回空，请自行避免未来函数。\n\n当 date 和 statDate 都不传入时, 相当于使用 date 参数, date 的默认值下面会描述.\n\n**参数**\n\n- query_object: 一个[sqlalchemy.orm.query.Query对象](http:\/\/docs.sqlalchemy.org\/en\/rel_1_0\/orm\/query.html), 可以通过全局的 query 函数获取 Query 对象\n- date: 查询日期, 一个字符串(格式类似'2015-10-15')或者[datetime.date]\/[datetime.datetime]对象, 可以是None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别:\n1. 回测模块: 默认值会随着回测日期变化而变化, 等于 context.current_dt 的前一天(实际生活中我们只能看到前一天的财报和市值数据, 所以要用前一天)\n2. 研究模块: 使用平台财务数据的最新日期, 一般是昨天.\n如果传入的 date 不是交易日, 则使用这个日期之前的最近的一个交易日\n\n- statDate: 财报统计的季度或者年份, 一个字符串, 有两种格式:\n1. 季度: 格式是: **年 + 'q' + 季度序号**, 例如: '2015q1', '2013q4'.\n2. 年份: 格式就是年份的数字, 例如: '2015', '2016'.\n\n**返回**\n返回一个 [pandas.DataFrame], 每一行对应数据库返回的每一行(可能是几个表的联合查询结果的一行), 列索引是你查询的所有字段\n注意：\n1. 为了防止返回数据量过大, 我们每次最多返回10000行\n2. 当相关股票上市前、退市后，财务数据返回各字段为空\n\n**示例**<pre><code class=\"python language-python\"># 查询'000001.XSHE'的所有市值数据, 时间是2015-10-15\nq = query(\n    valuation\n).filter(\n    valuation.code == '000001.XSHE'\n)\ndf = get_fundamentals(q, '2015-10-15')\n# 打印出总市值\nlog.info(df['market_cap'][0])\n<\/code><\/pre>\n<pre><code class=\"python language-python\"># 获取多只股票在某一日期的市值, 利润\ndf = get_fundamentals(query(\n        valuation, income\n    ).filter(\n        # 这里不能使用 in 操作, 要使用in_()函数\n        valuation.code.in_(['000001.XSHE', '600000.XSHG'])\n    ), date='2015-10-15')\n<\/code><\/pre>\n<pre><code class=\"python language-python\"># 选出所有的总市值大于1000亿元, 市盈率小于10, 营业总收入大于200亿元的股票\ndf = get_fundamentals(query(\n        valuation.code, valuation.market_cap, valuation.pe_ratio, income.total_operating_revenue\n    ).filter(\n        valuation.market_cap &gt; 1000,\n        valuation.pe_ratio &lt; 10,\n        income.total_operating_revenue &gt; 2e10\n    ).order_by(\n        # 按市值降序排列\n        valuation.market_cap.desc()\n    ).limit(\n        # 最多返回100个\n        100\n    ), date='2015-10-15')\n<\/code><\/pre>\n<pre><code class=\"python language-python\"># 使用 or_ 函数: 查询总市值大于1000亿元 **或者** 市盈率小于10的股票\nfrom sqlalchemy.sql.expression import or_\nget_fundamentals(query(\n        valuation.code\n    ).filter(\n        or_(\n            valuation.market_cap &gt; 1000,\n            valuation.pe_ratio &lt; 10\n        )\n    ))\n<\/code><\/pre>\n<pre><code class=\"python language-python\"># 查询平安银行2014年四个季度的季报, 放到数组中\nq = query(\n        income.statDate,\n        income.code,\n        income.basic_eps,\n        balance.cash_equivalents,\n        cash_flow.goods_sale_and_service_render_cash\n    ).filter(\n        income.code == '000001.XSHE',\n    )\n\nrets = [get_fundamentals(q, statDate='2014q'+str(i)) for i in range(1, 5)]\n<\/code><\/pre>\n<pre><code class=\"python language-python\"># 查询平安银行2014年的年报\nq = query(\n        income.statDate,\n        income.code,\n        income.basic_eps,\n        cash_flow.goods_sale_and_service_render_cash\n    ).filter(\n        income.code == '000001.XSHE',\n    )\n\nret = get_fundamentals(q, statDate='2014')\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n\n    <div class=\"group\">\n      <label>get_fundamentals_continuously <span id=\"get_fundamentals_continuously\"><\/span> <\/label>\n      <label>查询多日的财务数据<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_fundamentals_continuously(query_object, end_date=None,count=None)\n<\/code><\/pre>\n查询财务数据，详细的数据字段描述请点击<a href=\"\/data\/dict\/fundamentals\" target=\"_blank\">财务数据文档<\/a>查看\n\n**参数**\n\n- query_object: 一个[sqlalchemy.orm.query.Query对象](http:\/\/docs.sqlalchemy.org\/en\/rel_1_0\/orm\/query.html), 可以通过全局的 query 函数获取 Query 对象\n- end_date: 查询日期, 一个字符串(格式类似'2015-10-15')或者[datetime.date]\/[datetime.datetime]对象, 可以是None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别:\n1. 回测模块: 默认值会随着回测日期变化而变化, 等于 context.current_dt 的前一天(实际生活中我们只能看到前一天的财报和市值数据, 所以要用前一天)\n2. 研究模块: 使用平台财务数据的最新日期, 一般是昨天.\n如果传入的 date 不是交易日, 则使用这个日期之前的最近的一个交易日\n- count: 获取 end_date 前 count 个日期的数据\n\n**返回**\n返回一个 [pandas.Panel]\n\n**出于性能方面考虑，我们做出了返回总条数不超过10000条的限制。 也就是说：查询的股票数量\\*count 要小于10000。 否则，返回的数据会不完整。**\n\n**示例**\n<pre><code class=\"python language-python\">&gt;&gt;&gt; q = query(valuation.turnover_ratio,\n              valuation.market_cap,\n              indicator.eps\n            ).filter(valuation.code.in_(['000001.XSHE', '600000.XSHG']))\n\n&gt;&gt;&gt; panel = get_fundamentals_continuously(q, end_date='2018-01-01', count=5)\n\n&gt;&gt;&gt; panel \n\n\\&lt;class 'pandas.core.panel.Panel'\\&gt;\nDimensions: 3 (items) x 5 (major_axis) x 2 (minor_axis)\nItems axis: turnover_ratio to eps\nMajor_axis axis: 2017-12-25 to 2017-12-29\nMinor_axis axis: 000001.XSHE to 600000.XSHG\n\n&gt;&gt;&gt; panel.minor_xs('600000.XSHG')\n\nturnover_ratio  market_cap  eps\nday         \n2017-12-25  0.0687  3695.4270   0.48\n2017-12-26  0.0542  3710.1030   0.48\n2017-12-27  0.1165  3704.2324   0.48\n2017-12-28  0.0849  3680.7510   0.48\n2017-12-29  0.0582  3695.4270   0.48\n\n\n&gt;&gt;&gt; panel.major_xs('2017-12-25')\n\nturnover_ratio  market_cap  eps\ncode            \n000001.XSHE 0.9372  2275.0796   0.38\n600000.XSHG 0.0687  3695.4270   0.48\n\n&gt;&gt;&gt; panel.xs('turnover_ratio',axis=0)\n# axis=0 表示 items axis; axis=1 表示 major axis; axis=2 表示 minor axis\n\ncode    000001.XSHE 600000.XSHG\nday     \n2017-12-25  0.9372  0.0687\n2017-12-26  0.6642  0.0542\n2017-12-27  0.8078  0.1165\n2017-12-28  0.9180  0.0849\n2017-12-29  0.5810  0.0582\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>finance.run_query<span id=\"finance\"><\/span> <\/label>\n      <label>深沪港通股东信息等数据<\/label>\n      <article>\n\n**数据调用方法**\n<pre><code class=\"python language-python\">from jqdata import *\nfinance.run_query(query_object)\n<\/code><\/pre>\n\n查询深沪港通、股东信息、公司概况等数据，详细的数据字段描述请点击[股票数据](\/help\/api\/help?name=Stock)查看\n\n**参数**\n* query_object: 一个[sqlalchemy.orm.query.Query对象](http:\/\/docs.sqlalchemy.org\/en\/rel_1_0\/orm\/query.html), 可以通过全局的query函数获取Query对象。\n\n**返回**\n返回一个 dataframe， 每一行对应数据库返回的每一行， 列索引是你所查询的字段\n\n注意\n1. **为了防止返回数据量过大, 我们每次最多返回3000行**\n2. 不能进行连表查询，即同时查询多张表内数据\n\n**示例**\n<pre><code class=\"python language-python\"># 查询万科 AH 股价格的前10条数据\nq=query(finance.STK_AH_PRICE_COMP\n  ).filter(\n        finance.STK_AH_PRICE_COMP.a_code=='000002.XSHE'\n  ).order_by(\n        finance.STK_AH_PRICE_COMP.day\n  ).limit(10)\ndf=finance.run_query(q)\n<\/code><\/pre>\n<pre><code class=\"python language-python\">#指定查询对象为恒瑞医药（600276.XSHG)的十大股东情况，限定返回条数为10条\nq=query(finance.STK_SHAREHOLDER_TOP10\n  ).filter(\n        finance.STK_SHAREHOLDER_TOP10.code=='600276.XSHG',\n        finance.STK_SHAREHOLDER_TOP10.pub_date&gt;'2015-01-01'\n  ).limit(10)\ndf=finance.run_query(q)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>jy.run_query <span id=\"jy\"><\/span> <\/label>\n      <label>更多财务及宏观数据<\/label>\n      <article>\n<pre><code class=\"python language-python\">from jqdata import jy\njy.run_query(query_object)\n<\/code><\/pre>\n查询聚源数据，详细的数据字段描述请点击[聚源数据](\/help\/data\/data?name=jy)查看\n\n**参数**\n\n- query_object: 一个[sqlalchemy.orm.query.Query对象](http:\/\/docs.sqlalchemy.org\/en\/rel_1_0\/orm\/query.html), 可以通过全局的query函数获取Query对象\n\n**返回**\n\n- 返回一个pandas.DataFrame, 每一行对应数据库返回的每一行, 列索引是你查询的所有字段\n\n**注意**\n\n1. 为了防止返回数据量过大, 我们每次最多返回3000行 \n2. 不能进行连表查询，即同时查询多张表内数据\n\n**示例**\n<pre><code class=\"python language-python\"># 查询'股票基本信息表 - STK_STOCKINFO'的数据, 并返回前10条数据\nfrom jqdata import jy\ndf = jy.run_query(query(jy.LC_StockArchives).limit(10))\n\n# 打印出公司名称\nlog.info(df['ChiName'])\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>macro.run_query <span id=\"macro\"><\/span> <\/label>\n      <label>获取聚宽宏观经济数据<\/label>\n      <article>\n\n**数据调用方法**\n<pre><code class=\"python language-python\">from jqdata import *\nmacro.run_query(query_object)\n<\/code><\/pre>\n\n查询宏观经济数据，详细的数据字段描述请点击[宏观经济数据](\/data\/dict\/macroData)查看\n\n**参数**\n* query_object: 一个[sqlalchemy.orm.query.Query对象](http:\/\/docs.sqlalchemy.org\/en\/rel_1_0\/orm\/query.html), 可以通过全局的query函数获取Query对象。\n\n**返回**\n返回一个 dataframe， 每一行对应数据库返回的每一行， 列索引是你所查询的字段\n\n注意\n1. 为了防止返回数据量过大, 我们每次最多返回3000行 \n2. 不能进行连表查询，即同时查询多张表内数据\n\n**示例**\n<pre><code class=\"python language-python\"># 查询分地区农林牧渔业总产值表(季度累计) 的前10条数据\nq = query(macro.MAC_INDUSTRY_AREA_AGR_OUTPUT_VALUE_QUARTER\n    ).limit(10)\ndf = macro.run_query(q)\n<\/code><\/pre>\n<pre><code class=\"python language-python\"># 查询2014年的分地区农林牧渔业总产值表(年度)\nq = query(macro.MAC_INDUSTRY_AREA_AGR_OUTPUT_VALUE_YEAR\n        ).filter(macro.MAC_INDUSTRY_AREA_AGR_OUTPUT_VALUE_YEAR.stat_year=='2014')\ndf = macro.run_query(q)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n\n    <div class=\"group\">\n      <label>get_billboard_list <span id=\"get_billboard_list\"><\/span> <\/label>\n      <label> 获取龙虎榜数据<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_billboard_list(stock_list, start_date, end_date, count)\n<\/code><\/pre>\n获取指定日期区间内的龙虎榜数据\n\n**参数**\n\n- stock_list: 一个股票代码的 list。 当值为 None 时， 返回指定日期的所有股票。\n- start_date:开始日期\n- end_date: 结束日期\n- count: 交易日数量， 可以与 end_date 同时使用， 表示获取 end_date 前 count 个交易日的数据(含 end_date 当日)\n\n**返回值**\n\n- pandas.DataFrame， 各 column 的含义如下:\n\n    - code: 股票代码\n    - day: 日期\n    - direction: ALL 表示『汇总』，SELL 表示『卖』，BUY 表示『买』\n    - abnormal_code: 异常波动类型\n    - abnormal_name: 异常波动名称\n    - sales_depart_name: 营业部名称\n    - rank: 0 表示汇总， 1~5 表示买一到买5， 6~10 表示卖一到卖五\n    - buy_value:买入金额\n    - buy_rate:买入金额占比(买入金额\/市场总成交额)\n    - sell_value:卖出金额\n    - sell_rate:卖出金额占比(卖出金额\/市场总成交额)\n    - net_value:净额(买入金额 - 卖出金额)\n    - amount:市场总成交额\n\n\n**示例**<pre><code class=\"python language-python\"># 在策略中获取前一日的龙虎榜数据\nget_billboard_list(stock_list=None, end_date = context.previous_date, count =1)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_locked_shares <span id=\"get_locked_shares\"><\/span> <\/label>\n      <label>获取限售解禁数据<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_locked_shares(stock_list, start_date, end_date, forward_count)\n<\/code><\/pre>\n获取指定日期区间内的限售解禁数据\n\n**参数**\n\n- stock_list: 一个股票代码的 list\n- start_date: 开始日期\n- end_date: 结束日期\n- forward_count: 交易日数量， 可以与 start_date 同时使用， 表示获取 start_date 到 forward_count 个交易日区间的数据\n\n**返回值**\n\n- pandas.DataFrame， 各 column 的含义如下:\n\n    - day: 解禁日期\n    - code: 股票代码\n    - num: 解禁股数\n    - rate1: 解禁股数\/总股本\n    - rate2: 解禁股数\/总流通股本\n\n**示例**<pre><code class=\"python language-python\"># 在策略中获取个股未来500天的解禁情况\nget_locked_shares(stock_list=['000001.XSHE', '000002.XSHE'], start_date=context.current_dt, forward_count=500)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n\n    <div class=\"group\">\n      <label>get_index_stocks <span id=\"get_index_stocks\"><\/span> <\/label>\n      <label>获取指数成份股<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_index_stocks(index_symbol, date=None)\n<\/code><\/pre>\n获取一个指数给定日期在平台可交易的成分股列表，请点击[指数列表](\/indexData)查看指数信息\n\n**参数**\n\n- index_symbol: 指数代码\n- date: 查询日期, 一个字符串(格式类似'2015-10-15')或者[datetime.date]\/[datetime.datetime]对象, 可以是None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别:\n    1. 回测模块: 默认值会随着回测日期变化而变化, 等于context.current_dt\n    2. 研究模块: 默认是今天\n\n**返回**\n返回股票代码的list\n\n**示例**<pre><code class=\"python language-python\"># 获取所有沪深300的股票\nstocks = get_index_stocks('000300.XSHG')\nlog.info(stocks)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n\n    <div class=\"group\">\n      <label>get_index_weights<span id=\"get_index_weights\"><\/span><\/label>\n      <label>获取指数成分股权重<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_index_weights(index_id, date=None)\n<\/code><\/pre>\n\n**参数**\n\n- index_id: 必选参数，代表指数的标准形式代码， 形式：指数代码.交易所代码，例如\"000001.XSHG\"。若代码格式错误或传入无效的指数代码，报错。\n- date: 可选参数， 查询权重信息的日期，形式：\"%Y-%m-%d\"，例如\"2018-05-03\"，除此之外其他日期格式报错。当date为None，在回测、模拟环境中，默认为context.current_dt.date()；在研究环境中，默认为datetime.now().date()。\n\n**返回**\n\n- 查询到对应日期，且有权重数据，返回 pandas.DataFrame， index 是股票代码，columns 为 display_name(股票名称), date(日期), weight(权重)；\n- 查询到对应日期，且无权重数据， 返回距离查询日期最近日期的权重信息；\n- 找不到对应日期的权重信息， 返回距离查询日期最近日期的权重信息；\n\n**示例**\n<pre><code class=\"python language-python\">&gt;&gt;&gt; get_index_weights(index_id=\"000001.XSHG\", date=\"2018-05-09\")\n\n\n=========== ============ =========== ======\n    code    display_name     date    weight\n=========== ============ =========== ======\n000002.XSHG 万科A         2018-05-09  1.43\n000001.XSHG 平安银行      2018-05-09  0.93\n000009.XSHG 中国宝安      2018-05-09  0.27\n=========== ============ =========== ======\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n\n    <div class=\"group\">\n      <label>get_industry_stocks <span id=\"get_industry_stocks\"><\/span> <\/label>\n      <label>获取行业成份股<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_industry_stocks(industry_code, date=None)\n<\/code><\/pre>\n获取在给定日期一个行业的所有股票，行业分类列表见数据页面-[行业概念数据](\/data\/dict\/plateData)。\n\n**参数**\n\n- industry_code: 行业编码\n- date: 查询日期, 一个字符串(格式类似'2015-10-15')或者[datetime.date]\/[datetime.datetime]对象, 可以是None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别:\n    1. 回测模块: 默认值会随着回测日期变化而变化, 等于context.current_dt\n    2. 研究模块: 默认是今天\n\n**返回**\n返回股票代码的list\n\n**示例**<pre><code class=\"python language-python\"># 获取计算机\/互联网行业的成分股\nstocks = get_industry_stocks('I64')\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_concept_stocks <span id=\"get_concept_stocks\"><\/span> <\/label>\n      <label>获取概念成份股<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_concept_stocks(concept_code, date=None)\n<\/code><\/pre>\n获取在给定日期一个概念板块的所有股票，概念板块分类列表见数据页面-[行业概念数据](\/data\/dict\/plateData)。\n\n**参数**\n\n- concept_code: 概念板块编码\n- date: 查询日期, 一个字符串(格式类似'2015-10-15')或者[datetime.date]\/[datetime.datetime]对象, 可以是None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别:\n    1. 回测模块: 默认值会随着回测日期变化而变化, 等于context.current_dt\n    2. 研究模块: 默认是今天\n\n**返回**\n返回股票代码的list\n\n**示例**<pre><code class=\"python language-python\"># 获取风力发电概念板块的成分股\nstocks = get_concept_stocks('GN036')\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_industries <span id=\"get_industries\"><\/span> <\/label>\n      <label>获取行业列表<\/label>\n      <article>\n<pre><code class=\"python language-python\">from jqdata import *\nget_industries(name='zjw')\n<\/code><\/pre>\n\n按照行业分类获取行业列表。\n\n**参数**\n\n- name: 行业代码， 取值如下：\n\n    - \"sw_l1\": 申万一级行业\n    - \"sw_l2\": 申万二级行业\n    - \"sw_l3\": 申万三级行业\n    - \"jq_l1\": 聚宽一级行业\n    - \"jq_l2\": 聚宽二级行业\n    - \"zjw\": 证监会行业\n\n**返回值**\n\n- pandas.DataFrame， 各 column 的含义如下:\n\n    - index: 行业代码\n    - name: 行业名称\n    - start_date: 开始日期\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_concepts <span id=\"get_concepts\"><\/span> <\/label>\n      <label>获取概念列表<\/label>\n      <article>\n<pre><code class=\"python language-python\">from jqdata import *\nget_concepts()\n<\/code><\/pre>\n获取所有的概念板块列表，行业分类列表见数据页面-[行业概念数据](\/data\/dict\/plateData)。\n\n\n**返回值**\n\n- pandas.DataFrame， 各 column 的含义如下:\n\n    - index: 概念代码\n    - name: 概念名称\n    - start_date: 开始日期\n\n      <\/article>\n    <\/div>\n\n\n    <div class=\"group\">\n      <label>get_all_securities <span id=\"get_all_securities\"><\/span> <\/label>\n      <label>获取所有标的信息<\/label>\n      <article>\n<pre><code>get_all_securities(types=[], date=None)\n<\/code><\/pre>\n获取平台支持的所有股票、基金、指数、期货信息\n\n**参数**\n\n- types: list: 用来过滤securities的类型, list元素可选: 'stock', 'fund', 'index', 'futures', 'etf', 'lof', 'fja', 'fjb', 'open_fund', 'bond_fund', 'stock_fund', 'QDII_fund', 'money_market_fund', 'mixture_fund'。 **types为空时返回所有股票, 不包括基金,指数和期货**\n- date: 日期, 一个字符串或者 [datetime.datetime]\/[datetime.date] 对象, 用于获取某日期还在上市的股票信息. 默认值为 None, 表示获取所有日期的股票信息\n\n**返回**\n[pandas.DataFrame], 比如:`get_all_securities()[:2]`返回:\n\n|---|display_name|name|start_date|end_date|type|\n|---|---|---|---|---|---|\n|000001.XSHE|平安银行|PAYH|1991-04-03|9999-01-01|stock|\n|000002.XSHE|万  科Ａ|WKA|1991-01-29|9999-01-01|stock|\n\n\n- display_name: 中文名称\n- name: 缩写简称\n- start_date: 上市日期\n- end_date: 退市日期，如果没有退市则为2200-01-01\n- type: 类型，stock(股票)，index(指数)，etf(ETF基金)，fja（分级A），fjb（分级B），fjm（分级母基金），mmf（场内交易的货币基金）open_fund（开放式基金）, bond_fund（债券基金）, stock_fund（股票型基金）, QDII_fund（QDII 基金）, money_market_fund（场外交易的货币基金）, mixture_fund（混合型基金）\n\n\n**示例**<pre><code class=\"python language-python\">def initialize(context):\n    #获得所有股票列表\n    log.info(get_all_securities())\n    log.info(get_all_securities(['stock']))\n\n    #将所有股票列表转换成数组\n    stocks = list(get_all_securities(['stock']).index)\n\n    #获得所有指数列表\n    get_all_securities(['index'])\n\n    #获得所有基金列表\n    df = get_all_securities(['fund'])\n\n    #获取所有期货列表\n    get_all_securities(['futures'])\n\n    #获得etf基金列表\n    df = get_all_securities(['etf'])\n    #获得lof基金列表\n    df = get_all_securities(['lof'])\n    #获得分级A基金列表\n    df = get_all_securities(['fja'])\n    #获得分级B基金列表\n    df = get_all_securities(['fjb'])\n\n    #获得2015年10月10日还在上市的所有股票列表\n    get_all_securities(date='2015-10-10')\n    #获得2015年10月10日还在上市的 etf 和 lof 基金列表\n    get_all_securities(['etf', 'lof'], '2015-10-10')\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_security_info <span id=\"get_security_info\"><\/span> <\/label>\n      <label>获取单个标的信息<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_security_info(code)\n<\/code><\/pre>\n获取股票\/基金\/指数的信息.\n\n**参数**\n\n- code: 证券代码\n\n**返回值**\n\n- 一个对象, 有如下属性:\n\n    - display_name: 中文名称\n    - name: 缩写简称\n    - start_date: 上市日期, [datetime.date] 类型\n    - end_date: 退市日期， [datetime.date] 类型, 如果没有退市则为2200-01-01\n    - type: 股票、基金、金融期货、期货、债券基金、股票基金、QDII 基金、货币基金、混合基金、场外基金，'stock'\/ 'fund' \/ 'index_futures' \/ 'futures' \/ 'etf'\/'bond_fund' \/ 'stock_fund' \/ 'QDII_fund' \/ 'money_market_fund' \/ ‘mixture_fund' \/ 'open_fund'\n    - parent: 分级基金的母基金代码\n\n**示例**<pre><code class=\"python language-python\"># 获取基金的母基金, 下面的判断为真.\nassert get_security_info('502050.XSHG').parent == '502048.XSHG'\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_industry<span id=\"get_industry\"><\/span><\/label>\n      <label>查询股票所属行业<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_industry(security, date=None)\n<\/code><\/pre>\n\n**参数**\n\n- security：标的代码。类型为字符串，形式如\"000001.XSHE\"；或为包含标的代码字符串的列表，形如[\"000001.XSHE\", \"000002.XSHE\"]\n- date：查询的日期。类型为字符串，形如\"2018-06-01\"或\"2018-06-01 09:00:00\"；或为datetime.datetime对象和datetime.date。*注意传入对象的时分秒将被忽略*。\n\n**返回结果**\n\n一个dict， key是标的代码。\n\n**示例**\n<pre><code class=\"python language-python\">&gt;&gt;&gt; get_industry(security=['000001.XSHE','000002.XSHE'], date=\"2018-06-01\")\n\n\n{'000001.XSHE': {'jq_l1': {'industry_code': 'HY007', 'industry_name': '金融指数'},\n                 'jq_l2': {'industry_code': 'HY493', 'industry_name': '多元化银行指数'},\n                 'sw_l1': {'industry_code': '801780', 'industry_name': '银行I'},\n                 'sw_l2': {'industry_code': '801192', 'industry_name': '银行II'},\n                 'sw_l3': {'industry_code': '851911', 'industry_name': '银行III'},\n                 'zjw': {'industry_code': 'J66', 'industry_name': '货币金融服务'}\n                },\n '000002.XSHE': {'jq_l1': {'industry_code': 'HY011', 'industry_name': '房地产指数'},\n                 'jq_l2': {'industry_code': 'HY509', 'industry_name': '房地产开发指数'},\n                 'sw_l1': {'industry_code': '801180', 'industry_name': '房地产I'},\n                 'sw_l2': {'industry_code': '801181', 'industry_name': '房地产开发II'},\n                 'sw_l3': {'industry_code': '851811', 'industry_name': '房地产开发III'},\n                 'zjw': {'industry_code': 'K70', 'industry_name': '房地产业'}\n                }\n}\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_all_trade_days <span id=\"get_all_trade_days\"><\/span> <\/label>\n      <label>获取所有交易日<\/label>\n      <article>\n<pre><code class=\"python language-python\">from jqdata import *\nget_all_trade_days()\n<\/code><\/pre>\n获取所有交易日, 不需要传入参数, 返回一个包含所有交易日的 [numpy.ndarray], 每个元素为一个 [datetime.date] 类型.\n\n**注： 需导入 jqdata 模块，即在策略或研究起始位置加入`import jqdata`**\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_trade_days <span id=\"get_trade_days\"><\/span> <\/label>\n      <label>获取指定范围交易日<\/label>\n      <article>\n<pre><code class=\"python language-python\">from jqdata import *\nget_trade_days(start_date=None, end_date=None, count=None)\n<\/code><\/pre>\n\n获取指定日期范围内的所有交易日, 返回一个包含datetime.date object的列表, 包含指定的 start_date 和 end_date, 默认返回至 datatime.date.today() 的所有交易日\n\n**注意get_trade_days最多只能获取到截至现实时间的当前年份的最后一天的交易日数据**\n\n**注： 需导入 jqdata 模块，即在策略或研究起始位置加入`import jqdata`**\n\n**参数**\n\n- start_date: 开始日期, **与 count 二选一, 不可同时使用**. str\/[datetime.date]\/[datetime.datetime] 对象\n- end_date: 结束日期, str\/[datetime.date]\/[datetime.datetime] 对象, 默认为 datetime.date.today()\n- count: 数量, **与 start_date 二选一, 不可同时使用**, 必须大于 0. 表示取 end_date 往前的 count 个交易日，包含 end_date 当天。\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_money_flow <span id=\"get_money_flow\"><\/span> <\/label>\n      <label>获取资金流信息<\/label>\n      <article>\n\n<pre><code class=\"python language-python\">from jqdata import *\nget_money_flow(security_list, start_date=None, end_date=None, fields=None, count=None)\n<\/code><\/pre>\n\n获取一只或者多只股票在一个时间段内的资金流向数据，仅包含股票数据，不可用于获取期货数据。\n\n**注： 需导入 jqdata 模块，即在策略或研究起始位置加入`import jqdata`**\n\n**参数**\n\n- security_list: 一只股票代码或者一个股票代码的 list\n- start_date: 开始日期, **与 count 二选一, 不可同时使用**, 一个字符串或者 [datetime.datetime]\/[datetime.date] 对象, 默认为平台提供的数据的最早日期\n- end_date: 结束日期, 一个字符串或者 [datetime.date]\/[datetime.datetime] 对象, 默认为 datetime.date.today()\n- count: 数量, **与 start_date 二选一，不可同时使用**, 必须大于 0. 表示返回 end_date 之前 count 个交易日的数据, 包含 end_date\n- fields: 字段名或者 list, 可选. 默认为 None, 表示取全部字段, 各字段含义如下：\n\n|字段名|含义|备注|\n|---|---|---|\n|date|日期|---|\n|sec_code|股票代码|---|\n|change_pct|涨跌幅(%)|---|\n|net_amount_main|主力净额(万)|主力净额 = 超大单净额 + 大单净额|\n|net_pct_main|主力净占比(%)|主力净占比 = 主力净额 \/ 成交额|\n|net_amount_xl|超大单净额(万)|超大单：大于等于50万股或者100万元的成交单|\n|net_pct_xl|超大单净占比(%)|超大单净占比 = 超大单净额 \/ 成交额|\n|net_amount_l|大单净额(万)|大单：大于等于10万股或者20万元且小于50万股或者100万元的成交单|\n|net_pct_l|大单净占比(%)|大单净占比 = 大单净额 \/ 成交额|\n|net_amount_m|中单净额(万)|中单：大于等于2万股或者4万元且小于10万股或者20万元的成交单|\n|net_pct_m|中单净占比(%)|中单净占比 = 中单净额 \/ 成交额|\n|net_amount_s|小单净额(万)|小单：小于2万股或者4万元的成交单|\n|net_pct_s|小单净占比(%)|小单净占比 = 小单净额 \/ 成交额|\n\n**返回**\n\n返回一个 [pandas.DataFrame] 对象，默认的列索引为取得的全部字段. 如果给定了 fields 参数, 则列索引与给定的 fields 对应.\n\n**示例**\n<pre><code class=\"python language-python\"># 获取一只股票在一个时间段内的资金流量数据\njqdata.get_money_flow('000001.XSHE', '2016-02-01', '2016-02-04')\njqdata.get_money_flow('000001.XSHE', '2015-10-01', '2015-12-30', fields=\"change_pct\")\njqdata.get_money_flow(['000001.XSHE'], '2010-01-01', '2010-01-30', [\"date\", \"sec_code\", \"change_pct\", \"net_amount_main\", \"net_pct_l\", \"net_amount_m\"])\n\n— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —\n\n# 获取多只股票在一个时间段内的资金流向数据\njqdata.get_money_flow(['000001.XSHE', '000040.XSHE', '000099.XSHE'], '2010-01-01', '2010-01-30')\n# 获取多只股票在某一天的资金流向数据\njqdata.get_money_flow(['000001.XSHE', '000040.XSHE', '000099.XSHE'], '2016-04-01', '2016-04-01')\n\n— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —\n\n# 获取股票 000001.XSHE 在日期 2016-06-30 往前 20 个交易日的资金流量数据\njqdata.get_money_flow('000001.XSHE', end_date=\"2016-06-30\", count=20)\n# 获取股票 000001.XSHE 往前 20 个交易日的资金流量数据\njqdata.get_money_flow('000001.XSHE', count=20)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h3 id=\"数据处理函数\">数据处理函数<\/h3>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>neutralize<\/label>\n      <label>中性化<\/label>\n      <article>\n<pre><code class=\"python language-python\">neutralize(series, how=None, date=None, axis=1)\n<\/code><\/pre>\n\n**参数** \n\n- data: pd.Series\/pd.DataFrame , 待中性化的序列，序列的 index 为股票的 code\n- how: str list 。 中性化使用的因子名称列表。默认为 ['jq_l1', 'market_cap'] 支持的内容包括：\n    - 'jq_l1'： 聚宽一级行业\n    - 'jq_l2'： 聚宽二级行业\n    - 'sw_l1'： 申万一级行业\n    - 'sw_l2'： 申万二级行业\n    - 'sw_l3'： 申万三级行业\n    - barra 的风险因子：可以使用的风险因子包括： ['size', 'beta', 'momentum', 'residual_volatility', 'non_linear_size', 'book_to_price_ratio', 'liquidity', 'earnings_yield', 'growth', 'leverage']\n- date: 日期格式 str  将用 date 这天的相关变量数据对 series 进行中性化\n- axis: 默认为 1。仅在 data 为 pd.DataFrame 时生效。 表示沿哪个方向做标准化，0 为对每列做中性化，1 为对每行做中性化\n\n\n**返回**\n\n中性化后的因子数据\n\n\n**示例**\n<pre><code class=\"python language-python\"># 导入需要的函数库\nimport pandas as pd\nimport numpy as np\nfrom jqfactor import neutralize\n# 生成数据\ndata = pd.DataFrame(np.random.rand(3,300), columns=get_index_stocks('000300.XSHG', date='2018-05-02'),index=['a', 'b', 'c'])\n# 数据中性化\nneutralize(data, how=['jq_l1', 'market_cap'], date='2018-05-02', axis=1)\n<\/code><\/pre>\n\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>winsorize<\/label>\n      <label>去极值<\/label>\n      <article><pre><code class=\"python language-python\">winsorize(series, scale=None, range=None, qrange=None, inclusive=True, inf2nan=True, axis=1)\n<\/code><\/pre>\n\n**参数**\n\n- data: pd.Series\/pd.DataFrame\/np.array, 待缩尾的序列\n- scale: 标准差倍数，与 range，qrange 三选一，不可同时使用。会将位于 [mu - scale * sigma, mu + scale * sigma] 边界之外的值替换为边界值\n- range:  列表， 缩尾的上下边界。与 scale，qrange 三选一，不可同时使用。 \n- qrange: 列表，缩尾的上下分位数边界，值应在 0 到 1 之间，如 [0.05, 0.95]。与 scale，range 三选一，不可同时使用。\n- inclusive: 是否将位于边界之外的值替换为边界值，默认为 True。如果为 True，则将边界之外的值替换为边界值，否则则替换为 np.nan\n- inf2nan: 是否将 np.inf 和 -np.inf 替换成 np.nan，默认为 True如果为 True，在缩尾之前会先将 np.inf 和 -np.inf 替换成 np.nan，缩尾的时候不会考虑 np.nan，否则 inf 被认为是在上界之上，-inf 被认为在下界之下\n- axis: 在 data 为 pd.DataFrame 时使用，沿哪个方向做标准化，默认为 1。 0 为对每列做缩尾，1 为对每行做缩尾。\n\n\n\n**返回**\n\n去极值处理之后的因子数据\n\n\n\n**示例**\n<pre><code class=\"python language-python\"># 导入需要的函数库\nimport pandas as pd\nimport numpy as np\nfrom jqfactor import winsorize\n# 生成数据\ndata = pd.DataFrame(np.random.rand(3,300), columns=get_index_stocks('000300.XSHG', date='2018-05-02'),index=['a', 'b', 'c'])\n# 数据去极值\nwinsorize(data, qrange=[0.05,0.93], inclusive=True, inf2nan=True, axis=1)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n\n    <div class=\"group\">\n      <label>winsorize_med<\/label>\n      <label>中位数去极值<\/label>\n      <article><pre><code class=\"python language-python\">winsorize_med(series, scale=1, inclusive=True, inf2nan=True, axis=1)\n<\/code><\/pre>\n\n**参数**\n\n- data: pd.Series\/pd.DataFrame\/np.array, 待缩尾的序列\n- scale: 倍数，默认为 1.0。会将位于 [med - scale * distance, med + scale * distance] 边界之外的值替换为边界值\/np.nan\n- inclusive bool  是否将位于边界之外的值替换为边界值，默认为 True。 如果为 True，则将边界之外的值替换为边界值，否则则替换为 np.nan\n- inf2nan: 是否将 np.inf 和 -np.inf 替换成 np.nan，默认为 True。如果为 True，在缩尾之前会先将 np.inf 和 -np.inf 替换成 np.nan，缩尾的时候不会考虑 np.nan，否则 inf 被认为是在上界之上，-inf 被认为在下界之下\n- axis: 在 data 为 pd.DataFrame 时使用，沿哪个方向做标准化，默认为 1。0 为对每列做缩尾，1 为对每行做缩尾\n\n\n\n**返回**\n\n中位数去极值之后的因子数据\n\n\n\n**示例**\n<pre><code class=\"python language-python\"># 导入需要的函数库\nimport pandas as pd\nimport numpy as np\nfrom jqfactor import winsorize_med\n# 生成数据\ndata = pd.DataFrame(np.random.rand(3,300), columns=get_index_stocks('000300.XSHG', date='2018-05-02'),index=['a', 'b', 'c'])\n# 数据中位数去极值\nwinsorize_med(data, scale=1, inclusive=True, inf2nan=True, axis=0)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>standardlize<\/label>\n      <label>标准化<\/label>\n      <article>\n<pre><code class=\"python language-python\">standardlize(series, inf2nan=True, axis=1)\n<\/code><\/pre>\n\n**参数**\n\n- data: pd.Series\/pd.DataFrame\/np.array, 待标准化的序列\n- inf2nan: 是否将 np.inf 和 -np.inf 替换成 np.nan。默认为 True\n- axis=1: 在 data 为 pd.DataFrame 时使用，如果 series 为 pd.DataFrame，沿哪个方向做标准化。0 为对每列做标准化，1 为对每行做标准化\n\n\n\n**返回**\n\n标准化后的因子数据\n\n\n\n**示例**\n<pre><code class=\"python language-python\"># 导入需要的函数库\nimport pandas as pd\nimport numpy as np\nfrom jqfactor import standardlize\n# 生成数据\ndata = pd.DataFrame(np.random.rand(3,300), columns=get_index_stocks('000300.XSHG', date='2018-05-02'),index=['a', 'b', 'c'])\n# 数据标准化\nstandardlize(data, inf2nan=True, axis=0)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h3 id=\"组合优化函数\">组合优化函数<\/h3>\n<h5 id=\"portfolio_optimizerspanidportfolio_optimizerspan\">portfolio_optimizer - 投资组合优化 <span id=\"portfolio_optimizer\"><\/span><\/h5>\n<pre><code class=\"python language-python\">portfolio_optimizer(date, securities, target, constraints, bounds=[Bound(0.0, 1.0)], default_port_weight_range=[0.0, 1.0], ftol=1e-9, return_none_if_fail=True)\n<\/code><\/pre>\n<p>优化函数, 用于计算在某些约束条件下的最优组合权重<\/p>\n<ul>\n<li>参数<ul>\n<li>date: 优化发生的日期，请注意未来函数<\/li>\n<li>securities: 股票代码列表<\/li>\n<li>target: 优化目标函数，只能选择一个，目标函数详见下方<\/li>\n<li>constraints: 限制函数，用以对组合总权重进行限制，可设置一个或多个相同\/不同类别的函数，限制函数详见下方<\/li>\n<li>bounds: 边界函数，用以对组合中单标的权重进行限制，可设置一个或多个相同\/不同类别的函数，边界函数详见下方。如果不填，默认为 Bound(0., 1.)；如果有多个 bound，则一只股票的权重下限取所有 Bound 的最大值，上限取所有 Bound 的最小值<\/li>\n<li>default_port_weight_range: 长度为2的列表，默认的组合权重之和的范围，默认值为 [0.0, 1.0]。如果限制函数(constraints) 中没有 WeightConstraint 或 WeightEqualConstraint 限制，则会添加 WeightConstraint(low=default_port_weight_range[0], high=default_port_weight_range[1]) 到 constraints列表中。<\/li>\n<li>ftol: 默认为 1e-9，优化函数触发结束的函数值。当求解结果精度不够时可以适当降低 ftol 的值，当求解时间过长时可以适当提高 ftol 值<\/li>\n<li>return_none_if_fail: 默认为 True，如果优化失败，当 return_none_if_fail 为 True 时返回 None，为 False 时返回全为 0 的组合权重<\/li><\/ul><\/li>\n<\/ul>\n<h4 id=\"\">相关参数<\/h4>\n<section>\n  <div class=\"header\">\n    <label>参数名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>目标函数(target)<\/label>\n      <label>优化目标函数，只能选择一个<\/label>\n      <article>\n\n\n- MiniVariance(count=250) - 组合风险最小化（最小化组合方差）\n\n    ​ 最小化组合方差\n\n    - 参数：\n\n      count: 默认为 250，向前取 returns 的天数\n\n    - 示例：\n\n      target = MiniVariance(count=250)\n\n\n\n- MaxProfit(count=250) - 组合收益最大化\n\n    - 参数：\n\n      count: 默认为 250，向前取 returns 的天数\n\n    - 示例：\n\n      target = MaxProfit(count=250)\n\n\n\n- MaxSharpeRatio(rf=0.0, weight_sum_equal=1.0, count=250) - 组合夏普比率最大化\n\n    - 参数：\n\n      rf: 年化无风险利率，默认为 0\n\n      weight_sum_equal：组合总权重的值（默认值为1.0），在该权重下进行优化，使得组合的夏普比率最大化\n\n      count: 默认为 250，向前取 returns 的天数\n\n    - 示例：\n\n      target = MaxSharpeRatio(count=250)\n\n\n\n- MinTrackingError(benchmark, count=250) - 追踪误差最小化\n\n    - 参数：\n\n      benchmark: 基准的 ticker，例如 '000300.XSHG'\n\n      count: 默认为 250，向前取 returns 的天数\n\n    - 示例：\n\n      target = MinTrackingError(benchmark='000300.XSHG', count=250)\n\n\n\n- RiskParity(count=250, risk_budget=None) - 风险平价\n\n    风险平价（Risk Parity）是对投资组合中不同资产分配相同的风险权重的一种资产配置理念，资产配置的风险平价方法允许投资者针对具体的风险水平，并在整个投资组合中平均分配风险，以实现每个投资者的最佳投资组合多元化。\n\n    - 参数：\n\n      count: 默认为 250，向前取 returns 的天数\n\n      risk_budget: pandas.Series，风险预算，股票的每只对组合风险的贡献，risk_budget 为 None默认为每只股票贡献相等\n\n    - 示例：\n\n      target = RiskParity(count=250, risk_budget=pd.Series([0.3, 0.3, 0.4], index=['000001.XSHE', '000002.XSHE', '000005.XSHE']))\n\n\n\n- MaxScore(scores) - 打分最大化\n\n    在满足约束条件的情况下，给予打分高的标的更高权重（前提假设：用户已知晓打分大的标的表现更好）。\n\n    如有经过因子分析检验，打分越高越有正向效果的[A,B,C] 三只标的，打分分别为 [3,2,1] , 约束条件为年化波动率小于15%。 如果组合全部配置A可获得最高的收益，但波动率大于15%，不满足约束条件；通过优化器优化，则会配置一定比例的B与C，在满足波动率小于15%的条件下，获得最高收益。\n\n    - 参数：\n\n      scores: pandas.Series，每只股票的打分\n\n    - 示例：\n\n      target = MaxScore(scores=pd.Series([0.1, 0.2, 0.3], index=['000001.XSHE', '000002.XSHE', '000005.XSHE']))\n\n\n\n- MinScore(scores) - 打分最小化\n\n    在满足约束条件的情况下，给予打分低的标的更高权重（前提假设：用户已知晓打分小的标的表现更好）。可参考 [打分最大化] 的示例说明。\n\n    - 参数：\n\n      scores: pandas.Series，每只股票的打分\n\n    - 示例：\n\n      target = MinScore(scores=pd.Series([0.1, 0.2, 0.3], index=['000001.XSHE', '000002.XSHE', '000005.XSHE']))\n\n\n\n- MaxFactorValue(factor, count=1) - 因子值最大化\n\n    在满足约束条件的情况下，给予因子值大的标的更高权重（前提假设：用户已知晓因子值大的标的表现更好）。可参考 [打分最大化] 的示例说明。\n\n    - 参数：\n\n      factor: Factor 的子类\n\n      count: 默认为 1，用过去几天的因子取平均\n\n    - 示例：\n\n      ```python\n      from jqfactor import Factor\n      # 定义因子：人气指标5日均值\n      class AR(Factor):\n          name = 'AR_M5'\n          # 每天获取过去五日的数据\n          max_window = 5\n          # 获取的数据是人气指标\n          dependencies = ['AR']\n          def calc(self, data):\n              return data['AR'].mean()\n\n      target = MaxFactorValue(factor=AR, count=1)\n      ```\n\n\n\n- MinFactorValue(factor, count=1) - 因子值最小化\n\n    在满足约束条件的情况下，给予因子值小的标的更高权重（前提假设：用户已知晓因子值小的标的表现更好）。可参考 [打分最大化] 的示例说明。\n\n    - 参数：\n\n      factor: Factor 的子类\n\n      count: 默认为 1，用过去几天的因子取平均\n\n    - 示例：\n\n      参考 [因子值最大化] 的示例\n\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>限制函数(constraints)<\/label>\n      <label>用以对组合总权重进行限制，可设置一个或多个相同\/不同类别的函数<\/label>\n      <article>\n\n\n- WeightConstraint(low=0.0, high=1.0) - 组合总权重限制\n\n    设定组合优化结果总权重的上下限，即优化结果的总权重在此范围间。\n\n    - 参数：\n\n      low: 默认为 0.0，权重下限\n\n      high: 默认为 1.0，权重上限\n\n    - 示例：\n\n      constraint = WeightConstraint(low=0.5, high=0.9)\n\n\n\n- WeightEqualConstraint(limit=1.0) - 组合总权重和限制\n\n    设定组合优化结果总权重的和，即优化结果的总权重等于该值。\n\n    - 参数：\n\n      limit: 默认为 1.0，组合权重等式约束\n\n    - 示例：\n\n      constraint = WeightEqualConstraint(limit=0.5)\n\n\n\n- AnnualStdConstraint(limit, count=250) - 组合年化收益率标准差限制\n\n    - 参数：\n\n      limit: 标准差上限\n\n      count: 默认为 250，向前取 returns 的天数\n\n    - 示例：\n\n      constraint = AnnualStdConstraint(limit=0.15, count=250)\n\n\n\n- AnnualProfitConstraint(limit, count=250) - 组合年化收益率预期限制\n\n    - 参数：\n\n      limit: 收益率预期下限\n\n      count: 默认为 250，向前取 returns 的天数\n\n    - 示例：\n\n      constraint = AnnualProfitConstraint(limit=0.1, count=250)\n\n\n\n- IndustryConstraint(industry_code, low=0.0, high=1.0) - 组合行业权重限制\n\n    - 参数：\n\n      industry_code: 单一或多个[行业代码](\/data\/dict\/plateData)，如 'HY001'。如果为多个行业代码的列表，则表示所有属于列表中行业的股票的权重之和满足限制条件\n\n      low: 默认为 0.0，行业权重下限\n\n      high: 默认为 1.0，行业权重上限\n\n    - 示例：\n\n      constraint = IndustryConstraint(['HY007'], low=0.0, high=0.2)\n\n\n\n- IndustriesConstraint(industry_code, low=0.0, high=1.0)- 组合行业分类权重限制\n\n    - 参数：\n\n      industry_code: [行业分类代码](\/help\/api\/help?name=api#get_industries)，如 'jq_l1'。表示这个行业分类下的所有行业都需满足权重限制\n\n      low: 默认为 0.0，行业权重下限\n\n      high: 默认为 1.0，行业权重上限\n\n    - 示例：\n\n      constraint = IndustriesConstraint('jq_l1', low=0.0, high=0.2)\n\n\n\n- MarketConstraint(market_type, low=0.0, high=1.0) - 组合市场权重限制\n\n    - 参数：\n\n      market_type: ('stock', 'index', 'fund', 'futures', 'etf', 'lof', 'fja', 'fjb', 'open_fund', 'bond_fund', 'stock_fund', 'QDII_fund', 'money_market_fund', 'mixture_fund') 中的一种\n\n      low: 默认为 0.0，市场权重下限\n\n      high: 默认为 1.0，市场权重上限\n\n    - 示例：\n\n      constraint = MarketConstraint('stock', low=0.0, high=0.2)\n\n\n\n- ExposureConstraint(factor, low=0.0, high=1.0, count=1) - 因子暴露限制\n\n    - 参数：\n\n      factor: Factor 的子类\n\n      low: 默认为 0.0，因子暴露度下限\n\n      high: 默认为 1.0，因子暴露度上限\n\n      count: 默认为 1，用过去几天的因子取平均\n\n    - 示例：\n\n      ```python\n      from jqfactor import Factor\n      # 定义因子：人气指标5日均值\n      class AR(Factor):\n          name = 'AR_M5'\n          # 每天获取过去五日的数据\n          max_window = 5\n          # 获取的数据是人气指标\n          dependencies = ['AR']\n          def calc(self, data):\n              return data['AR'].mean()\n\n      constraint = ExposureConstraint(AR, low=0.0, high=10.0, count=1)\n      ```\n\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>边界函数(bounds)<\/label>\n      <label>用以对组合中单标的权重进行限制，可设置一个或多个相同\/不同类别的函数<\/label>\n      <article>\n\n\n- Bound(low=0.0, high=1.0) - 每只标的的权重限制\n\n    - 参数：\n\n      low: 默认为 0.0，每只标的的权重下限\n\n      high: 默认为 1.0，每只标的的权重上限\n\n    - 示例：\n\n      bound = Bound(low=0.0, high=0.1)\n\n\n\n- IndustryBound(industry_code, low=0.0, high=1.0) - 属于某一行业的每只股票的权重限制\n\n    - 参数：\n\n      industry_code: 单一[行业代码](https:\/\/www.joinquant.com\/data\/dict\/plateData)或者行业代码的列表。\n\n      low: 默认为 0.0，如果一只股票属于所选行业，则股票权重的下限为 low，否则下限为 0\n\n      high: 默认为 1.0，如果一只股票属于所选行业，则股票权重的上限为 high，否则上限为 1\n\n    - 示例：\n\n      bound = IndustryBound(['HY001', 'HY007'], low=0.0, high=0.05)\n\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>示例代码<\/label>\n      <label>给了五个应用示例，修改参数即可生效<\/label>\n      <article>\n<pre><code class=\"python language-python\"># 导入函数库\nimport pandas as pd\nfrom jqdata import *\nfrom jqfactor import Factor\nfrom jqlib.optimizer import *\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n\n    # 过滤掉order系列API产生的比error级别低的log\n    log.set_level('order', 'error')\n\n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003,\n                            min_commission=5), type='stock')\n\n    # 优化器设置\n    g.optimizer = 2 #设定使用的优化模型\n    optimize_model = {\n                        1:\"模型1：等权重配置\",\n                        2:\"模型2：组合风险平价；股票的总权重限制为0到90%，ETF的总权重限制为0到10%；每只标的权重不超过10%\",\n                        3:\"模型3：组合风险最小化（最小化组合方差）；组合总权重限制为90%到100%；组合年化收益率目标下限为10%\",\n                        4:\"模型4：'人气指标5日均值'最大化；组合年化收益率目标下限为10%；每只标的权重不超过20%\",\n                        5:\"模型5：组合夏普比率最大化；每只标的权重不超过10%\"\n                      }\n    print(\"优化%s\"%(optimize_model[g.optimizer]))\n\n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      # 开盘前运行\n    run_monthly(before_market_open, monthday=1, time='before_open', reference_security='000300.XSHG')\n      # 开盘运行\n    run_monthly(market_open, monthday=1, time='open', reference_security='000300.XSHG')\n\n## 开盘前运行函数\ndef before_market_open(context):\n    print('调仓日期：%s'%context.current_dt.date())\n\n    # 选出上证50成分股的一部分与选定的ETF基金进行组合,构成股票池。\n    etf = [\n        '159902.XSHE',\n        '159903.XSHE',\n        '510050.XSHG',\n        '510880.XSHG',\n        '510440.XSHG',\n        ]\n    g.buy_list = list(get_index_stocks('000016.XSHG')[-15:]) + etf\n\n## 开盘时运行函数\ndef market_open(context):\n    # 讲不在股票池中的股票卖出\n    sell_list = set(context.portfolio.positions.keys()) - set(g.buy_list)\n    for stock in sell_list:\n        order_target_value(stock, 0)\n\n    # 组合优化模型\n    if g.optimizer == 1:\n        # 模型1：等权重配置\n        optimized_weight = pd.Series(data=[1.0\/len(g.buy_list)]*len(g.buy_list),\n                                    index=g.buy_list)\n    elif g.optimizer == 2:\n        # 模型2：组合风险平价；股票的总权重限制为0到90%，ETF的总权重限制为0到10%；每只标的权重不超过10%\n        optimized_weight = portfolio_optimizer(date=context.previous_date,\n                                    securities = g.buy_list,\n                                    target = RiskParity(count=250, risk_budget=None),# risk_budget 为 None默认为每只股票贡献相等\n                                    constraints = [MarketConstraint('stock', low=0.0, high=0.9),\n                                                  MarketConstraint('etf', low=0.0, high=0.1)],\n                                    bounds=[Bound(0, 0.1)],\n                                    default_port_weight_range=[0., 1.0],\n                                    ftol=1e-09,\n                                    return_none_if_fail=True)\n    elif g.optimizer == 3:\n        # 模型3：组合风险最小化（最小化组合方差）；组合总权重限制为90%到100%；组合年化收益率目标下限为10%\n        optimized_weight = portfolio_optimizer(date=context.previous_date,\n                                    securities = g.buy_list,\n                                    target = MinVariance(count=250),\n                                    constraints = [WeightConstraint(low=0.9, high=1.0),\n                                                   AnnualProfitConstraint(limit=0.1, count=250)],\n                                    bounds=[],\n                                    default_port_weight_range=[0., 1.0],\n                                    ftol=1e-09,\n                                    return_none_if_fail=True)\n    elif g.optimizer == 4:\n        # 模型4：组合标的因子值最大化\n\n        # 定义因子：人气指标5日均值\n        class AR(Factor):\n            name = 'ar'\n            # 每天获取过去五日的数据\n            max_window = 5\n            # 获取的数据是人气指标\n            dependencies = ['AR']\n            def calc(self, data):\n                return data['AR'].mean()\n        # 模型4：'人气指标5日均值'最大化；组合年化收益率目标下限为10%；每只标的权重不超过20%\n        optimized_weight = portfolio_optimizer(date=context.previous_date,\n                                    securities = g.buy_list,\n                                    target = MaxFactorValue(factor=AR, count=1),\n                                    constraints = [AnnualProfitConstraint(limit=0.2, count=250)],\n                                    bounds=[Bound(0, 0.2)],\n                                    default_port_weight_range=[0., 1.0],\n                                    ftol=1e-09,\n                                    return_none_if_fail=True)\n    elif g.optimizer == 5:\n        # 模型5：组合夏普比率最大化；每只标的权重不超过10%\n        optimized_weight = portfolio_optimizer(date=context.previous_date,\n                                    securities = g.buy_list,\n                                    target = MaxSharpeRatio(rf=0.0,weight_sum_equal=0.5, count=250),#无风险利率为0，最大化夏普比率需要约束组合权重的和为0.5\n                                    constraints = [],\n                                    bounds=[Bound(0, 0.1)],\n                                    default_port_weight_range=[0., 1.0],\n                                    ftol=1e-09,\n                                    return_none_if_fail=True)\n\n    # 查看优化结果\n    print(optimized_weight)\n\n    # 优化失败，给予警告\n    if type(optimized_weight) == type(None):\n        print('警告：组合优化失败')\n    # 按优化结果，执行调仓操作\n    else:\n        total_value = context.portfolio.total_value # 获取总资产\n        for stock in optimized_weight.keys():\n            value = total_value * optimized_weight[stock] # 确定每个标的的权重\n            order_target_value(stock, value) # 调整标的至目标权重\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h3 id=\"jqlib\">jqlib<\/h3>\n<p><span id=\"jqlib\"><\/span><\/p>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n    <div class=\"group\">\n      <label>alpha101 <span id=\"alpha01\"><\/span> <\/label>\n      <label>Alpha 101 因子<\/label>\n      <article>\n\n**因子来源**\n\n根据 WorldQuant LLC 发表的论文 [*101 Formulaic Alphas*](https:\/\/arxiv.org\/ftp\/arxiv\/papers\/1601\/1601.00991.pdf) 中给出的 101 个 Alphas 因子公式，我们将公式编写成了函数，方便大家使用。\n\n**详细介绍**\n\n函数计算公式、API 调用方法，输入输出值详情请见:[数据 - Alpha 101](\/data\/dict\/alpha101).\n\n**使用方法**\n<pre><code class=\"python language-python\"># 导入 Alpha101 库\n&gt;&gt;&gt; from jqlib.alpha101 import *\n\n# 获取沪深300成分股的 alpha_001 因子值\n&gt;&gt;&gt; a = alpha_001('2017-03-10','000300.XSHG')\n\n# 查看前5行的因子值\n&gt;&gt;&gt; a.head()\n000001.XSHE   -0.496667\n000002.XSHE    0.226667\n000008.XSHE   -0.043333\n000009.XSHE   -0.093333\n000027.XSHE   -0.030000\nName: rank_value_boolean, dtype: float64\n\n# 查看平安银行的因子值\n&gt;&gt;&gt; a['000001.XSHE']\n-0.49666666666666665\n\n# 获取所有股票 alpha_007 的因子值\n&gt;&gt;&gt; a = alpha_007('2014-10-22')\n# 查看欣旺达(300207)的因子值\n&gt;&gt;&gt; a['300207.XSHE']\n0.8\n\n# 查询函数说明\n&gt;&gt;&gt; alpha_101?\nType:        cython_function_or_method\nString form: &lt;cyfunction alpha_101 at 0x7f037a0167d0&gt;\nDocstring:\n公式：\n((close - open) \/ ((high - low) + .001))\n\nInputs:\n    enddate: 查询日期\n    index: 股票池\n\nOutputs:\n    因子的值\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>alpha191 <span id=\"alpha191\"><\/span> <\/label>\n      <label>Alpha 191 因子<\/label>\n      <article>\n**因子来源**\n\n根据国泰君安数量化专题研究报告 - [基于短周期价量特征的多因子选股体系](http:\/\/vdisk.weibo.com\/s\/uEfe2futCdyJ9)给出了 191 个短周期交易型阿尔法因子，方便大家使用。\n\n**详细介绍**\n\n函数计算公式、API 调用方法，输入输出值详情请见:[数据 - Alpha 191](\/data\/dict\/alpha191).\n\n**使用方法**\n<pre><code class=\"python language-python\"># 导入 Alpha191 库\n&gt;&gt;&gt; from jqlib.alpha191 import *\n\n# 获取所有股票 alpha_007 的因子值\n&gt;&gt;&gt;end_date = '2017-04-04'\n&gt;&gt;&gt;code = list(get_all_securities(['stock'],date=end_date).index)\n&gt;&gt;&gt; a = alpha_007(code,end_date)\n# 查看欣旺达(300207)的因子值\n&gt;&gt;&gt; a['300207.XSHE']\n1.2494895018526142\n\n# 查询函数说明\n&gt;&gt;&gt; alpha_001?\nSignature: alpha_001(code, end_date=None)\nDocstring:\n公式：\n    (-1 * CORR(RANK(DELTA(LOG(VOLUME),1)),RANK(((CLOSE-OPEN)\/OPEN)),6)\nInputs:\n    code: 股票池\n    end_date: 查询日期\nOutputs:\n    因子的值\nFile:      ~\/alpha191.py\nType:      function\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>technical_analysis <span id=\"technical_analysis\"><\/span> <\/label>\n      <label>技术分析指标<\/label>\n      <article>\n\n**因子说明**\n为了让用户有更多可直接调用的技术分析指标因子，我们计划基于通达信、东方财富、同花顺等的公式，来完善我们的技术分析指标因子库。\n\n我们给出了公式的API、参数说明、返回值的结果及类型说明、备注（相较于上述三家结果及算法的比对）、用法注释及示例，旨在帮助您更方便、更快速的在策略研究中使用这些因子函数。\n\n**详细介绍**\n函数计算公式、API 调用方法，用法注释， 输入输出值详情请见:[数据 - 技术分析指标](\/data\/dict\/technicalanalysis).\n\n**使用方法**\n<pre><code class=\"python language-python\"># 导入 Alpha101 库\n&gt;&gt;&gt; from jqlib.technical_analysis import *\n\n# 定义股票池列表\nsecurity_list1 = '000001.XSHE'\nsecurity_list2 = ['000001.XSHE','000002.XSHE','601211.XSHG','603177.XSHG']\n\n\n# 计算并输出 security_list1 的 GDX 值，分别返回：济安线、压力线和支撑线的值。\ngdx_jax, gdx_ylx, gdx_zcx = GDX(security_list1,check_date='2017-01-04', N = 30, M = 9)\nprint gdx_jax[security_list1]\nprint gdx_ylx[security_list1]\nprint gdx_zcx[security_list1]\n\n# 输出 security_list2 的 GDX 值\ngdx_jax, gdx_ylx, gdx_zcx = GDX(security_list2,check_date='2017-01-04', N = 30, M = 9)\nfor stock in security_list2:\n    print gdx_jax[stock]\n    print gdx_ylx[stock]\n    print gdx_zcx[stock]\n\n# 查询函数说明\n&gt;&gt;&gt; GDX?\nSignature: GDX(security_list, check_date, N=30, M=9)\nDocstring:\n 计算公式：\n    AA:=ABS((2*CLOSE+HIGH+LOW)\/4-MA(CLOSE,N))\/MA(CLOSE,N); \n    JAX:DMA(CLOSE,AA);\n    压力线:(1+M\/100)*JAX; \n    支撑线:(1-M\/100)*JAX; \n    AA赋值:(2*收盘价+最高价+最低价)\/4-收盘价的N日简单移动平均的绝对值\/收盘价的N日简单移动平均\n    输出济安线 = 以AA为权重收盘价的动态移动平均\n    输出压力线 = (1+M\/100)*JAX\n    输出支撑线 = (1-M\/100)*JAX\n输入：\n    security_list:股票列表\n    check_date：要查询数据的日期\n    N：统计的天数 N\n    M：统计的天数 M\n输出：\n    济安线、压力线和支撑线的值。\n输出结果类型：\n    字典(dict)：键(key)为股票代码，值(value)为数据。\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<p><span id=\"order_func\"><\/span> <span id=\"交易函数\"><\/span> <span id=\"下单函数\"><\/span><\/p>\n<h3 id=\"交易函数\">交易函数<\/h3>\n<p><strong>提示：所有下单函数可以在 handle_data中 与 <a href=\"#task_func\">定时运行函数<\/a> 的 time 参数为 \"every_bar\", \"open\", \"morning\", \"night\" 时使用。<\/strong><\/p>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>order <span id=\"order\"><\/span><span id=\"order-method\"><\/span> <\/label>\n      <label>按股数下单<\/label>\n      <article>\n<pre><code class=\"python language-python\">order(security, amount, style=None, side='long', pindex=0, close_today=False)\n<\/code><\/pre>\n买卖标的。调用成功后, 您将可以调用[get_open_orders]取得所有未完成的交易, 也可以调用[cancel_order]取消交易\n\n**参数**\n\n- security: 标的代码\n- amount: 交易数量, 正数表示买入, 负数表示卖出\n- style: 参见[order styles], None代表MarketOrder\n- side: 'long'\/'short'，操作多单还是空单。默认为多单，**股票、基金暂不支持开空单**。\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0 指定第一个 subportfolio, 1 指定第二个 subportfolio，**默认为0**。\n- close_today: 平今字段。\n    - close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓\n    - close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓\n    - close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错\n\n**返回**\nOrder对象或者None, 如果创建订单成功, 则返回Order对象, 失败则返回None\n\n**示例**<pre><code class=\"python language-python\">#买入平安银行股票100股\norder('000001.XSHE', 100) # 下一个市价单\norder('000001.XSHE', 100, MarketOrderStyle()) # 下一个市价单, 功能同上\norder('000001.XSHE', 100, LimitOrderStyle(10.0)) # 以10块价格下一个限价单\n<\/code><\/pre>\n\n**可能的失败原因**:\n\n1. 股票数量经调整后变成0 (请看下面的说明)\n2. 股票停牌\n3. 股票未上市或者退市\n4. 股票不存在\n5. 为股票、基金开了空单\n6. 选择了不存在的仓位号，如没有建立多个仓位，而设定pindex的数大于0\n\n对于原因4, 我们会抛出异常停止运行, 因为我们认为这是您代码的bug.\n\n**注意**:\n\n- 因为下列原因, 有时候实际买入或者卖出的股票数量跟您设置的不一样，这个时候我们会在您的log中添加警告信息。\n\n1. 买入时会根据您当前的现金来限制您买入的数量\n2. 卖出时会根据您持有股票的数量来限制您卖出的数量\n3. 我们会遵守A股交易规则: 每次交易数量只能是100的整数倍, 但是卖光所有股票时不受这个限制\n\n- 根据交易所规则, 每天结束时会取消所有未完成交易\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>order_target <span id=\"order_target\"><\/span> <\/label>\n      <label>目标股数下单<\/label>\n      <article>\n<pre><code class=\"python language-python\">order_target(security, amount, style=None, side='long', pindex=0, close_today=False)\n<\/code><\/pre>\n买卖标的, 使最终标的的数量达到指定的amount\n\n**参数**\n\n- security: 标的代码\n- amount: 期望的最终数量\n- style: 参见[order styles], None代表MarketOrder\n- side: 'long'\/'short'，操作多单还是空单。默认为多单。默认为多单，**股票、基金暂不支持开空单**。\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，**默认为0**。\n- close_today: 平今字段。\n    - close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓\n    - close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓\n    - close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错\n\n**返回**\nOrder对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None\n\n**示例**<pre><code class=\"python language-python\"># 卖出平安银行所有股票\norder_target('000001.XSHE', 0)\n# 买入平安银行所有股票到100股\norder_target('000001.XSHE', 100)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>order_value <span id=\"order_value\"><\/span> <\/label>\n      <label>按价值下单<\/label>\n      <article>\n<pre><code class=\"python language-python\">order_value(security, value, style=None, side='long', pindex=0, close_today=False)\n<\/code><\/pre>\n买卖价值为value的标的。\n\n**参数**\n\n- security: 股票名字\n- value: 股票价值\n- style: 参见[order styles], None代表MarketOrder\n- side: 'long'\/'short'，操作多单还是空单。默认为多单。默认为多单，**股票、基金暂不支持开空单**。\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，**默认为0**。\n- close_today: 平今字段。\n    - close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓\n    - close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓\n    - close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错\n\n\n**返回**\nOrder对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None\n\n**示例**<pre><code class=\"python language-python\">#卖出价值为10000元的平安银行股票\norder_value('000001.XSHE', -10000)\n#买入价值为10000元的平安银行股票\norder_value('000001.XSHE', 10000)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>order_target_value <span id=\"order_target_value\"><\/span> <\/label>\n      <label>目标价值下单<\/label>\n      <article>\n<pre><code class=\"python language-python\">order_target_value(security, value, style=None, side='long', pindex=0, close_today=False)\n<\/code><\/pre>\n调整标的仓位到value价值。\n\n**参数**\n\n- security: 标的名字\n- value: 期望的标的最终价值\n- style: 参见[order styles], None代表MarketOrder\n- side: 'long'\/'short'，操作多单还是空单。默认为多单。\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，**默认为0**。\n- close_today: 平今字段。\n    - close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓\n    - close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓\n    - close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错\n\n\n**返回**\nOrder对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None\n\n**示例**<pre><code class=\"python language-python\">#卖出平安银行所有股票\norder_target_value('000001.XSHE', 0)\n#调整平安银行股票仓位到10000元价值\norder_target_value('000001.XSHE', 10000)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>cancel_order <span id=\"cancel_order\"><\/span> <\/label>\n      <label>撤单<\/label>\n      <article>\n<pre><code class=\"python language-python\">cancel_order(order)\n<\/code><\/pre>\n取消订单\n\n**参数**\n\n- order: [Order]对象或者order_id\n\n**返回**\nOrder对象或者None, 如果取消委托成功, 则返回Order对象, 委托不存在返回None\n\n**示例**<pre><code class=\"python language-python\">#每个交易日结束运行\ndef after_trading_end(context):\n    # 得到当前未完成订单\n    orders = get_open_orders()\n    # 循环，撤销订单\n    for _order in orders.values():\n        cancel_order(_order)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_open_orders <span id=\"get_open_orders\"><\/span> <\/label>\n      <label>获取未完成订单<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_open_orders()\n<\/code><\/pre>\n获得当天的所有未完成的订单\n\n**参数**\n无\n\n**返回**\n返回一个dict, key是order_id, value是[Order]对象\n\n**示例**<pre><code class=\"python language-python\">#每个交易日结束运行\ndef after_trading_end(context):\n    #得到当前未完成订单\n    orders = get_open_orders()\n    for _order in orders.values():\n        log.info(_order.order_id)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_orders <span id=\"get_orders\"><\/span> <\/label>\n      <label>获取订单信息<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_orders(order_id=None, security=None, status=None)\n<\/code><\/pre>\n获取当天的所有订单\n\n**参数**\n\n- order_id: 订单 id\n- security: 标的代码，可以用来查询指定标的的所有订单\n- status: [OrderStatus]， 查询特定订单状态的所有订单\n\n**返回**\n返回一个dict, key是order_id, value是[Order]对象\n\n**示例**<pre><code class=\"python language-python\">#每个交易日结束运行\ndef after_trading_end(context):\n    #得到当天所有订单\n    orders = get_orders()\n    for _order in orders.values():\n        log.info(_order.order_id)\n\n    # 根据订单id查询订单\n    get_orders(order_id='1517627499')   \n\n    # 查询所有标的为 000002.XSHE 的订单\n    get_orders(security='000002.XSHE')  \n\n    # 查询订单状态为 OrderStatus.held 的所有订单\n    get_orders(status=OrderStatus.held)\n\n    # 查询标的为 000002.XSHE 且状态为 OrderStatus.held 的所有订单\n    get_orders(security='000002.XSHE', status=OrderStatus.held)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_trades <span id=\"get_trades\"><\/span> <\/label>\n      <label>获取成交信息<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_trades()\n<\/code><\/pre>\n获取当天的所有成交记录, 一个订单可能分多次成交\n\n**参数**\n无\n\n**返回**\n返回一个dict, key是trade_id, value是[Trade]对象\n\n**示例**<pre><code class=\"python language-python\">#每个交易日结束运行\ndef after_trading_end(context):\n    #得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info(_trade.trade_id)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"inout_cash\"><\/span>inout_cash<\/label>\n      <label>账户出入金<\/label>\n      <article>\n<pre><code class=\"python language-python\">inout_cash(cash, pindex=0)\n<\/code><\/pre>\n\n账户转入或转出资金，当日的出入金从当日开始记入成本，用于计算收益，即当日结束计算收益时的本金是包含当日出入金金额的；\n\n**参数**\n\n- cash： 可正可负，正为入金，负为出金。\n- pindex： 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始,\n           比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。\n\n**示例**\n<pre><code class=\"python language-python\"># 查看账户可用资金\nlog.info('账户可用资金：',context.portfolio.subportfolios[0].available_cash)\n# 增加资金：6666\ninout_cash(6666, pindex=0)\n# 查看增加资金之后账户的可用资金\nlog.info('账户可用资金：',context.portfolio.subportfolios[0].available_cash)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<p><span id=\"object_func\"><\/span><\/p>\n<h3 id=\"对象\">对象<\/h3>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label><span id=\"g\"><\/span> g<\/label>\n      <label>全局变量对象<\/label>\n      <article>\n\n全局对象 g，用来存储用户的各类可被[pickle.dumps]函数序列化的全局数据\n\n在模拟盘中，如果中途进程中断，我们会使用[pickle.dumps]序列化所有的g下面的变量内容, 保存到磁盘中，再启动的时候模拟盘就不会有任何数据影响。如果没有用g声明，会出现模拟盘重启后，变量数据丢失的问题。\n\n**如果不想 g 中的某个变量被序列化, 可以让变量以 '__' 开头, 这样, 这个变量在序列化时就会被忽略**\n\n更多模拟盘细节, 请看 [模拟盘注意事项](#模拟盘注意事项).\n<pre><code class=\"python language-python\">def initialize(context):\n    g.security = \"000001.XSHE\"\n    g.count = 1\n    g.flag = 0\n\ndef process_initialize(context):\n    # 保存不能被序列化的对象, 进程每次重启都初始化, 更多信息, 请看 [process_initialize]\n    g.__q = query(valuation)\n\ndef handle_data(context, data):\n    log.info(g.security)\n    log.info(g.count)\n    log.info(g.flag)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id = \"Context\" ><\/span>Context<\/label>\n      <label>策略信息总览，包含账户、时间等信息<\/label>\n      <article>\n\n- subportfolios: 当前单个操作仓位的资金、标的信息，是一个[SubPortfolio](#subportfolios) 的数组\n\n- portfolio: 账户信息，即subportfolios 的汇总信息, [Portfolio](#portfolio)对象，单个操作仓位时，portfolio 指向 subportfolios[0]\n\n- current_dt: 当前单位时间的开始时间, [datetime.datetime]对象,\n\n    - 按天回测时, hour = 9, minute = 30, second = microsecond = 0,\n    - 按分钟回测时, second = microsecond = 0\n\n- previous_date: 前一个交易日, [datetime.date]对象, 注意, 这是一个日期, 是 date, 而不是 datetime\n\n- universe: 查询set_universe()设定的股票池, 比如: ['000001.XSHE', '600000.XSHG']\n\n- run_params: 表示此次运行的参数, 有如下属性\n\n    - start_date: 回测\/模拟开始日期, [datetime.date]对象\n    - end_date: 回测\/模拟结束日期, [datetime.date]对象\n    - type: 运行方式, 如下三个字符串之一\n      - 'simple_backtest': 回测, 通过点击'编译运行'运行\n      - 'full_backtest': 回测, 通过点击'运行回测'运行\n      - 'sim_trade': 模拟交易\n      - 'live_trade': 实盘交易\n    - frequency: 运行频率, 如下三个字符串之一\n      - 'day'\n      - 'minute'\n      - 'tick'\n\n- 为了让从其他平台迁移过来的同学更顺手的使用系统, 我们对此对象也做了和 [g] 一样的处理:\n\n    - 可以添加自己的变量, 每次进程关闭时持久保存, 进程重启时恢复.\n    - 以 '__' 开头的变量不会被持久保存\n    - 如果添加的变量与系统的冲突, 将覆盖掉系统变量, 如果想恢复系统变量, 请删除自己的变量. 示例:\n\n    ```python\n    def handle_data(context, data):\n        # 执行下面的语句之后, context.portfolio 的整数 1\n        context.portfolio = 1\n        log.info(context.portfolio)\n        # 要恢复系统的变量, 只需要使用下面的语句即可\n        del context.portfolio\n        # 此时, context.portfolio 将变成账户信息.\n        log.info(context.portfolio.portfolio_value)\n    ```\n\n  - 我们以后可能会往 context 添加新的变量来支持更多功能, 为了减少不必要的迷惑, 还是建议大家使用 [g]\n\n**示例**\n<pre><code class=\"python language-python\">def handle_data(context, data):\n\n    #获得当前回测相关时间\n    year = context.current_dt.year\n    month = context.current_dt.month\n    day = context.current_dt.day\n    hour = context.current_dt.hour\n    minute = context.current_dt.minute\n    second = context.current_dt.second\n    #得到\"年-月-日\"格式\n    date = context.current_dt.strftime(\"%Y-%m-%d\")\n    #得到周几\n    weekday = context.current_dt.isoweekday()\n\n    # 获取账户的持仓价值\n    positions_value = context.portfolio.positions_value\n\n    # 获取仓位subportfolios[0]的可用资金\n    available_cash = context.subportfolios[0].available_cash\n\n    # 获取subportfolios[0]中多头仓位的security的持仓成本\n    hold_cost = context.subportfolios[0].long_positions[security].hold_cost\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id = \"subportfolios\" ><\/span>SubPortfolio<\/label>\n      <label>子账户信息<\/label>\n      <article>\n      某个仓位的资金，标的信息，如未使用 SubPortfolioConfig 设置多仓位，默认只有subportfolios[0]一个仓位，Portfolio 指向该仓位。\n\n- inout_cash: 累计出入金, 比如初始资金 1000, 后来转移出去 100, 则这个值是 1000 - 100\n- available_cash: 可用资金, 可用来购买证券的资金\n- transferable_cash: 可取资金, 即可以提现的资金, 不包括今日卖出证券所得资金\n- locked_cash: 挂单锁住资金\n- type: 账户所属类型\n- long_positions: 多单的仓位, 一个 dict, key 是证券代码, value 是 [Position]对象\n- short_positions: 空单的仓位, 一个 dict, key 是证券代码, value 是 [Position]对象\n- positions_value: 持仓价值\n- total_value: 总资产, 包括现金, 保证金, 仓位的总价值, 可用来计算收益\n- total_liability: 总负债, 等于融资负债、融券负债、利息总负债的总和\n- net_value: 净资产, 等于总资产减去总负债\n- cash_liability: 融资负债\n- sec_liability: 融券负债\n- interest: 利息总负债\n- maintenance_margin_rate: 维持担保比例\n- available_margin: 融资融券可用保证金\n- margin: 保证金，股票、基金保证金都为100%；融资融券保证金为0；期货保证金会实时更新, 总是等于当前期货价值 乘以 保证金比率, 当保证金不足时, 强制平仓. 平仓顺序是: 亏损多的(相对于开仓均价)先平仓\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"Portfolio\"><\/span>Portfolio<\/label>\n      <label>总账户信息<\/label>\n      <article>\n\n账户当前的资金，标的信息，即所有标的操作仓位的信息汇总。如未使用 SubPortfolioConfig 设置多仓位，默认只有subportfolios[0]一个仓位，Portfolio 指向该仓位。\n\n- inout_cash: 累计出入金, 比如初始资金 1000, 后来转移出去 100, 则这个值是 1000 - 100\n- available_cash: 可用资金, 可用来购买证券的资金\n- transferable_cash: 可取资金, 即可以提现的资金, 不包括今日卖出证券所得资金\n- locked_cash: 挂单锁住资金\n- margin: 保证金，股票、基金保证金都为100%\n- positions: 等同于 long_positions\n- long_positions: 多单的仓位, 一个 dict, key 是证券代码, value 是 [Position]对象\n- short_positions: 空单的仓位, 一个 dict, key 是证券代码, value 是 [Position]对象\n- total_value: 总的权益, 包括现金, 保证金, 仓位的总价值, 可用来计算收益\n- returns: 总权益的累计收益\n- starting_cash: 初始资金, 现在等于 inout_cash\n- positions_value: 持仓价值\n- locked_cash_by_purchase: 基金申购未完成所冻结的金额\n- locked_cash_by_redeem: 基金赎回未到账的金额\n- locked_amount_by_redeem: 基金赎回时，冻结的份额\n- ~~cash: **已过时**，等价于 available_cash~~\n- ~~portfolio_value: **已过时**，等价于 total_value~~\n- ~~unsell_positions: **已过时, 请使用 positions 代替**, 当前持有的不可以卖出的持仓(比如在A股T+1市场, 今天购票的股票), 并没有考虑股票今天是否停牌, 一个dict, key是股票代码, value是[Position]对象.~~\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"Position\"><\/span>Position<\/label>\n      <label>持仓标的信息<\/label>\n      <article>\n\n持有的某个标的的信息\n\n- security: 标的代码\n- price: 最新行情价格\n- acc_avg_cost: 累计开仓成本,计算方法如下\n  买入: (old_amount * old_avg_cost + trade_amount * trade_price + commission) \/ (old_amount + trade_amount)\n  卖出: (old_amount * old_avg_cost - trade_amount * trade_price + commission) \/ (old_amount - trade_amount)\n说明：commission是本次买入或者卖出的手续费\n- avg_cost: 开仓均价，买入标的的加权平均价, 计算方法是:\n  (buy_volume1 * buy_price1 + buy_volume2 * buy_price2 + ...) \/ (buy_volume1 + buy_volume2 + ...)\n  每次买入后会调整avg_cost, 卖出时avg_cost不变. 这个值也会被用来计算浮动盈亏.\n- hold_cost: 持仓成本，**针对期货有效**。\n- init_time: 建仓时间，格式为 datetime.datetime\n- transact_time: 最后交易时间，格式为 datetime.datetime\n- total_amount: 总仓位, 但不包括挂单冻结仓位\n- closeable_amount: 可卖出的仓位 \/ 场外基金持有份额 \n- today_amount: 今天开的仓位\n- locked_amount: 挂单冻结仓位\n- value: 标的价值，计算方法是: price * total_amount * multiplier, 其中股票、基金的multiplier为1，期货为相应的合约乘数\n- side: 多\/空，'long' or 'short'\n- pindex: 仓位索引，subportfolio index\n- ~~sellable_amount: **已过时**, 为了向前兼容, 等同于 closeable_amount~~\n- ~~amount: **已过时**, 为了向前兼容, 等同于 closeable_amount~~\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"SecurityUnitData\"><\/span><span id=\"data\"><\/span>SecurityUnitData<\/label>\n      <label>data对象<\/label>\n      <article>\n\n一个单位时间内的股票的数据\n\n##### 基本属性\n\n**以下属性也能通过[history]\/[attribute_history]\/[get_price]获取到**\n\n- open: 时间段开始时价格\n- close: 时间段结束时价格\n- low: 最低价\n- high: 最高价\n- volume: 成交的股票数量\n- money: 成交的金额\n- factor: 前复权因子, 我们提供的价格都是前复权后的, 但是利用这个值可以算出原始价格, 方法是价格除以factor, 比如: `close\/factor`\n- high_limit: 涨停价\n- low_limit: 跌停价\n- avg: 这段时间的平均价, 等于`money\/volume`\n- ~~price: **已经过时**, 为了向前兼容, 等同于 avg~~\n- pre_close: 前一个单位时间结束时的价格, 按天则是前一天的收盘价, 按分钟则是前一分钟的结束价格\n- paused: bool值, 这只股票是否停牌, 停牌时open\/close\/low\/high\/pre_close依然有值,都等于停牌前的收盘价, volume=money=0\n\n##### 额外的属性和方法\n\n- security: 股票代码, 比如'000001.XSHE'\n- returns: 股票在这个单位时间的相对收益比例, 等于 `(close-pre_close)\/pre_close`\n- isnan(): 数据是否有效, 当股票未上市或者退市时, 无数据, isnan()返回True\n- `mavg(days, field='close')`: 过去days天的每天收盘价的平均值, 把field设成'avg'(等同于已过时的'price')则为每天均价的平均价, 下同\n- `vwap(days)`: 过去days天的每天均价的加权平均值, 以days=2为例子, 算法是:\n<pre><code class=\"python language-python\">(avg1 * volume1 + avg2 * volume2) \/ (volume1 + volume2)\n<\/code><\/pre>\n\n- `stddev(days)`: 过去days天的每天收盘价的标准差\n- 注：mavg\/vwap\/stddev:都会跳过停牌日期, 如果历史交易天数不足, 则返回nan\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"tick\"><\/span>tick 对象<\/label>\n      <label>tick 对象<\/label>\n      <article>\n\n一个 tick 所包含的信息。 tick 中的信息是在 tick 事件发生时， 盘面的一个快照。 \n\n- code: 标的的代码\n- datetime: tick 发生的时间\n- current: 最新价\n- high: 截至到当前时刻的最高价\n- low: 截至到当前时刻的最低价\n- volume: 截至到当前时刻的成交量\n- amount: 截至到当前时刻的成交额\n- position: 截至到当前时刻的持仓量，只适用于期货 tick 对象\n- a1_v ~ a5_v: 卖一量到卖五量，对于期货，只有卖一量\n- a1_p ~ a5_p: 卖一价到卖五价，对于期货，只有卖一价\n- b1_v ~ b5_v: 买一量到买五量，对于期货，只有买一量\n- b1_p ~ b5_p: 买一价到买五价，对于期货，只有买一价\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"Trade\"><\/span>Trade对象<\/label>\n      <label>订单的一次交易记录,一个订单可能分多次交易.<\/label>\n      <article>\n\n订单的一次交易记录,一个订单可能分多次交易.\n\n- time: 交易时间, [datetime.datetime]对象\n- security：标的代码\n- amount: 交易数量\n- price: 交易价格\n- trade_id: 交易记录id\n- order_id: 对应的订单id\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"order-object\"><\/span>Order对象<\/label>\n      <label>买卖订单信息<\/label>\n      <article>\n\n买卖订单\n\n- status: 状态, 一个[OrderStatus]值\n- add_time: 订单添加时间, [datetime.datetime]对象\n- is_buy: bool值, 买还是卖，对于期货:\n  - 开多\/平空 -> 买\n  - 开空\/平多 -> 卖\n- amount: 下单数量, 不管是买还是卖, 都是正数\n- filled: 已经成交的股票数量, 正数\n- security: 股票代码\n- order_id: 订单ID\n- price: 平均成交价格, 已经成交的股票的平均成交价格(一个订单可能分多次成交)\n- avg_cost: 卖出时表示下卖单前的此股票的持仓成本, 用来计算此次卖出的收益. 买入时表示此次买入的均价(等同于price).\n- side: 多\/空，'long'\/'short'\n- action: 开\/平， 'open'\/'close'\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"OrderStatus\"><\/span>OrderStatus<\/label>\n      <label>订单状态<\/label>\n      <article>\n\n订单状态, Enum特性使用的第三方库(https:\/\/pypi.python.org\/pypi\/enum34)\n<pre><code class=\"python language-python\">class OrderStatus(Enum):\n    # 订单新创建未委托，用于盘前\/隔夜单，订单在开盘时变为 open 状态开始撮合\n    new = 8\n\n    # 订单未完成, 无任何成交\n    open = 0\n\n    # 订单未完成, 部分成交\n    filled = 1\n\n    # 订单完成, 已撤销, 可能有成交, 需要看 Order.filled 字段\n    canceled = 2\n\n    # 订单完成, 交易所已拒绝, 可能有成交, 需要看 Order.filled 字段\n    rejected = 3\n\n    # 订单完成, 全部成交, Order.filled 等于 Order.amount\n    held = 4\n\n    # 订单取消中，只有实盘会出现，回测\/模拟不会出现这个状态\n    pending_cancel = 9 \n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"OrderStyle\"><\/span>OrderStyle<\/label>\n      <label>下单方式<\/label>\n      <article>\n\n下单方式, 有如下子类\n\n- 市价单: 不论价格, 直接下单, 直到交易全部完成\n<pre><code class=\"python language-python\">class MarketOrderStyle(OrderStyle):\n    pass\n<\/code><\/pre>\n\n- 限价单: 指定一个价格, 买入时不能高于它, 卖出时不能低于它, 如果不满足, 则等待满足后再交易\n<pre><code class=\"python language-python\">class LimitOrderStyle(OrderStyle):\n    def __init__(self, limit_price):\n        self.limit_price = limit_price\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h3 id=\"其他函数\">其他函数<\/h3>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label><span id=\"record\"><\/span>record ♠<\/label>\n      <label>画图函数<\/label>\n      <article>\n<pre><code class=\"python language-python\">record(**kwargs)\n<\/code><\/pre>\n\n**回测环境\/模拟专用API**\n\n我们会帮您在图表上画出收益曲线和基准的收益曲线，您也可以调用record函数来描画额外的曲线。\n因为我们是按天展现的，如果您使用按分钟回测，我们画出的点是您最后一次调用record的值。\n\n**参数**\n很多key=>value形式的参数，key曲线名称，value为值\n\n**返回**\nNone\n\n**示例**\n<pre><code class=\"python language-python\"># d是一个SecurityUnitData结构体，会画出每个单元时间(天或分钟)的平均价,开始价,结束价\nrecord(price=d.price, open=d.open, close=d.close)\n# 也可以画一条100的直线\nrecord(price=100)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>send_message ♠<span id=\"send_message\"><\/span><\/label>\n      <label>发送自定义消息<\/label>\n      <article>\n\n#### \n<pre><code>send_message(message, channel='weixin')\n<\/code><\/pre>\n\n**回测环境\/模拟专用API**\n\n给用户自己发送消息, 暂时只支持微信消息.\n\n**参数**\nmessage: 消息内容. 字符串.\nchannel: 消息渠道, 暂时只支持微信: weixin. 默认值是 weixin\n\n**返回值**\nTrue\/False, 表示是否发送成功. 当发送失败时, 会在日志中显示错误信息.\n\n**注意**\n\n- 要使用功能, 必须绑定微信。**请注意自定义消息的发送不受模拟交易“微信通知”开关的控制。**\n- 此功能只能在 **模拟交易** 中使用, 回测中使用会直接忽略, 无任何提示.\n- 微信消息每人每天不超过 **5** 条, 超出会失败.\n- 消息长度不得超过 **200** 个字符, 也不能包含回测和换行这些特殊字符，否则会发送失败.\n\n**示例**\n<pre><code class=\"python language-python\">send_message(\"测试消息\")\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"log\"><\/span> log <\/label>\n      <label>日志log信息<\/label>\n      <article>\n<pre><code class=\"python language-python\">log.error(content)\nlog.warn(content)\nlog.info(content)\nlog.debug(content)\nprint content1, content2, ...\n<\/code><\/pre>\n\n分级别打log,跟python的logging模块一致\nprint输出的结果等同于log.info, 但是print后面的每一个元素会占用一行\n\n**参数**\n参数可以是字符串、对象等\n\n**返回**\nNone\n\n**示例**\n<pre><code class=\"python language-python\">log.info(history(10)) # 打印出 history(10)返回的结果\nlog.info(\"Selling %s, amount=%s\", security, amount) # 打印出一个格式化后的字符串\nprint history(10), data, context.portfolio\n<\/code><\/pre>\n\n##### 设定log级别：log.set_level\n<pre><code class=\"python language-python\">log.set_level(name, level)\n<\/code><\/pre>\n\n设置不同种类的log的级别, 低于这个级别的log不会输出. 所有log的默认级别是debug\n\n**参数**\nname: 字符串, log种类, 必须是'order', 'history', 'strategy'中的一个, 含义分别是:\n\n- order: 调用order系列API产生的log\n- history: 调用history系列API(history\/attribute_history\/get_price)产生的log\n- strategy: 您自己在策略代码中打的log\n- system：系统日志，除以上三类之外的日志\n\nlevel: 字符串, 必须是'debug', 'info', 'warning', 'error'中的一个, 级别: debug < info < warning < error\n\n**返回**\nNone\n\n**示例**\n<pre><code class=\"python language-python\"># 过滤掉order系列API产生的比error级别低的log\nlog.set_level('order', 'error')\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id = \"write_file\" ><\/span>write_file<\/label>\n      <label>将策略中的信息写入内容到研究模块文件中<\/label>\n      <article>\n<pre><code class=\"python language-python\">write_file(path, content, append=False)\n<\/code><\/pre>\n\n写入内容到研究模块path文件, 写入后, 您可以立即在研究模块中看到这个文件\n\n**参数**\n\n- path: 相对路径, 相对于您的私有空间的根目录的路径\n- content: 文件内容, str或者unicode, 如果是unicode, 则会使用UTF-8编码再存储.可以是二进制内容.\n- append: 是否是追加模式, 当为False会清除原有文件内容，默认为False.\n\n**返回**\nNone\n 如果写入失败(一般是因为路径不合法), 会抛出异常\n\n**示例**\n<pre><code class=\"python language-python\">write_file(\"test.txt\", \"hello world\")\n\n# 写入沪深300的股票到HS300.stocks.json文件中\nimport json\nwrite_file('HS300.stocks.json', json.dumps(get_index_stocks('000300.XSHG')))\n\n# 把 DataFrame 表保存到文件\ndf = attribute_history('000001.XSHE', 5, '1d') #获取DataFrame表\nwrite_file('df.csv', df.to_csv(), append=False) #写到文件中\n\n## 详细用法可以参考文档：https:\/\/www.joinquant.com\/post\/580\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id = \"read_file\" ><\/span>read_file<\/label>\n      <label>读取你在研模块中存放的私有文件<\/label>\n      <article>\n<pre><code class=\"python language-python\">read_file(path)\n<\/code><\/pre>\n\n读取你的私有文件(您的私有文件可以在研究模块中看到)\n\n**参数**\npath: 相对路径, 相对于您的私有空间的根目录的路径\n\n**返回**\n返回文件的原始内容, 不做任何decode.\n\n**示例**\n<pre><code class=\"python language-python\">#解析json文件\nimport json\ncontent = read_file('HS300.stocks.json')\nsecurities = json.loads(content)\nlog.info(securities)\n\n#解析csv文件\nimport pandas as pd\nfrom six import StringIO\nbody=read_file(\"open.csv\")\ndata=pd.read_csv(StringIO(body))\n\n## 详细用法可以参考文档：https:\/\/www.joinquant.com\/post\/580\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id = \"自定义python库\" ><\/span>自定义python库<\/label>\n      <label>自定义私人的Python库文件<\/label>\n      <article>\n\n您可以在把.py文件放在'研究'的根目录, 然后在回测中就可以通过import的方式来引用此文件. 比如\n\n研究根目录\/mylib.py:\n\n    #-*- coding: utf-8 -*-\n    # 如果你的文件包含中文, 请在文件的第一行使用上面的语句指定你的文件编码\n\n    # 用到回测API请加入下面的语句\n    from kuanke.user_space_api import *\n\n    my_stocks = get_index_stocks('000300.XSHG')\n\n\n在策略代码中:\n\n    # 导入自己创建的库\n    from mylib import *\n\n    def initialize(context):\n        log.info(my_stocks)\n\n注意: 暂时只能import研究根目录下的.py文件, 还不能import子目录下的文件(比如通过 import a.b.c 来引用a\/b\/c.py)\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"create_backtest\"><\/span>create_backtest<\/label>\n      <label>通过一个策略ID从研究中创建回测<\/label>\n      <article>\n<pre><code class=\"python language-python\">create_backtest(algorithm_id, start_date, end_date, frequency=\"day\", initial_cash=10000, initial_positions=None, extras=None, name=None, code=\"\")\n<\/code><\/pre>\n\n通过一个策略ID从研究中创建回测\n\n**参数：**\n\n- algorithm_id: 策略ID，从策略编辑页的 url 中获取, 比如 '\/algorithm\/index\/edit?algorithmId=xxxx'，则策略ID为 `xxxx`\n- start_date: 回测开始日期\n- end_date: 回测结束日期\n- frequency: 数据频率，支持 day，minute\n- initial_cash: 初始资金\n- extras: 额外参数，一个 dict， 用于设置全局的 g 变量，如 extras={'x':1, 'y':2}，则回测中 g.x = 1, g.y = 2，需要注意的是，该参数的值是`在 initialize 函数执行之后`才设置给 g 变量的，所以这会覆盖掉 initialize 函数中 g 变量同名属性的值\n- name: 回测名, 用于指定回测名称, 如果没有指定则默认采用策略名作为回测名\n- initial_positions: 初始持仓。持仓会根据价格换成现金加到初始资金中，如果没有给定价格则默认获取股票最近的价格。格式如下:\n<pre><code class=\"python language-python\">initial_positions = [\n    {\n        'security':'000001.XSHE',\n        'amount':'100',\n    },\n    {\n        'security':'000063.XSHE',\n        'amount':'100',\n        'avg_cost': '1.0'\n    },\n]\n<\/code><\/pre>\n- code：策略代码。现在支持从研究中传入策略代码进行回测。指定之后将使用传入的代码来创建回测。\n- benchmark: 为回测设置基准。默认为None，表示使用策略中原有set_benchmark设置的基准。若不为None，则表示使用当前传入的基准覆盖原策略的基准。benchmark支持的基准同set_benchmark\n\n**返回：**\n\n一个字符串, 即 backtest_id\n\n**示例一：**\n<pre><code class=\"python language-python\">algorithm_id = \"xxxx\"\nextra_vars = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}\ninitial_positions = [\n    {\n        'security':'000001.XSHE',\n        'amount':'100',\n    },\n    {\n        'security':'000063.XSHE',\n        'amount':'100',\n        'avg_cost': '1.0'\n    },\n]\n\nparams = {\n    \"algorithm_id\": algorithm_id,\n    \"start_date\": \"2015-10-01\",\n    \"end_date\": \"2016-07-31\",\n    \"frequency\": \"day\",\n    \"initial_cash\": \"1000000\",\n    \"initial_positions\": initial_positions,\n    \"extras\": extra_vars,\n}\n\ncreated_bt_id = create_backtest(**params)\nprint(created_bt_id)\n<\/code><\/pre>\n\n**示例二，在研究中指定回测用策略代码：**\n<pre><code class=\"python language-python\">code = \"\"\"\n# 导入函数库\nfrom jqdata import *\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n\n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n\n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      # 开盘前运行\n    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') \n      # 开盘时运行\n    run_daily(market_open, time='open', reference_security='000300.XSHG')\n      # 收盘后运行\n    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')\n\n## 开盘前运行函数     \ndef before_market_open(context):\n    # 输出运行时间\n    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n\n    # 给微信发送消息（添加模拟交易，并绑定微信生效）\n    send_message('美好的一天~')\n\n    # 要操作的股票：平安银行（g.为全局变量）\n    g.security = '000001.XSHE'\n\n## 开盘时运行函数\ndef market_open(context):\n    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))\n    security = g.security\n    # 获取股票的收盘价\n    close_data = attribute_history(security, 5, '1d', ['close'])\n    # 取得过去五天的平均价格\n    MA5 = close_data['close'].mean()\n    # 取得上一时间点价格\n    current_price = close_data['close'][-1]\n    # 取得当前的现金\n    cash = context.portfolio.available_cash\n\n    # 如果上一时间点价格高出五天平均价1%, 则全仓买入\n    if current_price &gt; 1.01*MA5:\n        # 记录这次买入\n        log.info(\"价格高于均价 1%%, 买入 %s\" % (security))\n        # 用所有 cash 买入股票\n        order_value(security, cash)\n    # 如果上一时间点价格低于五天平均价, 则空仓卖出\n    elif current_price &lt; MA5 and context.portfolio.positions[security].closeable_amount &gt; 0:\n        # 记录这次卖出\n        log.info(\"价格低于均价, 卖出 %s\" % (security))\n        # 卖出所有股票,使这只股票的最终持有量为0\n        order_target(security, 0)\n\n## 收盘后运行函数  \ndef after_market_close(context):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    #得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('##############################################################')\n\n\"\"\"\n\n\nalgorithm_id = \"xxxx\"\nextra_vars = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}\ninitial_positions = [\n    {\n        'security':'000001.XSHE',\n        'amount':'100',\n    },\n    {\n        'security':'000063.XSHE',\n        'amount':'100',\n        'avg_cost': '1.0'\n    },\n]\n\nparams = {\n    \"algorithm_id\": algorithm_id,\n    \"start_date\": \"2015-10-01\",\n    \"end_date\": \"2016-07-31\",\n    \"frequency\": \"day\",\n    \"initial_cash\": \"1000000\",\n    \"initial_positions\": initial_positions,\n    \"extras\": extra_vars,\n}\n\ncreated_bt_id = create_backtest(code=code, **params)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"get_backtest\"><\/span>get_backtest<\/label>\n      <label>研究中获取回测与模拟交易信息<\/label>\n      <article>\n\n#### \n<pre><code class=\"python language-python\">gt = get_backtest(backtest_id)\n<\/code><\/pre>\n\n**参数：**\n\n- backtest_id: 回测ID，从回测详情页以及模拟交易详情页的 url 中获取, 比如 '\/algorithm\/backtest\/detail?backtestId='以及'\/algorithm\/live\/index?backtestId='，则回测ID为 `xxxx`。如下图所示：\n\n![](http:\/\/img2.ph.126.net\/snwsgC-gi5p3YHLjWJaI2g==\/6632085913469806298.png)\n\n**返回：**\n\n- gt.get_status():**获取回测状态**. 返回一个字符串，其含义分别为：\n    - none: 未开始\n    - running: 正在进行\n    - done: 完成\n    - failed: 失败\n    - canceled: 取消\n    - paused: 暂停\n    - deleted: 已删除\n- gt.get_params()：**获得回测参数**. 返回一个 dict, 包含调用 create_backtest 时传入的所有信息. (注： algorithm_id，initial_positions，extras 只有在研究中创建的回测才能取到)\n- gt.get_results()：**获得收益曲线**. 返回一个 list，每个交易日是一个 dict，键的含义如下：\n    - time: 时间\n    - returns: 收益\n    - benchmark_returns: 基准收益\n    - 如果没有收益则返回一个空的 list\n- gt.get_positions()：**获得持仓详情**. 返回一个 list，每个交易日为一个 dict，键的含义为：\n    - time: 时间\n    - security: 证券代码\n    - security_name: 证券名称\n    - amount: 持仓数量\n    - price: 股票价格\n    - avg_cost: 买入股票平均每股所花的钱\n    - closeable_amount: 可平仓数量\n    - 如果没有持仓则返回一个空的 list\n- gt.get_orders()：**获得交易详情**. 返回一个 list，每个交易日为一个 dict，键的含义为：\n    - time: 时间\n    - security: 证券代码\n    - security_name: 证券名称\n    - action: 交易类型, 开仓('open')\/平仓('close')\n    - amount: 下单数量\n    - filled: 成交数量\n    - price: 平均成交价格\n    - commission: 交易佣金\n    - 如果没有持仓则返回一个空的 list\n- gt.get_records()：**获得所有 record 记录**. 返回一个 list，每个交易日为一个 dict，键是 time 以及调用 record() 函数时设置的值.\n- gt.get_risk()：**获得总的风险指标**. 返回一个 dict，键是各类收益指标数据，如果没有风险指标则返回一个空的 dict.\n- gt.get_period_risks()：**获得分月计算的风险指标**. 返回一个 dict，键是各类指标, 值为一个 pandas.DataFrame. 如果没有风险指标则返回一个空的 dict.\n\n**示例：**\n<pre><code class=\"python language-python\">gt = get_backtest(\"xxxx\")\n\ngt.get_status()        # 获取回测状态\ngt.get_params()        # 获取回测参数\ngt.get_results()       # 获取收益曲线\ngt.get_positions()     # 获取所有持仓列表\ngt.get_orders()        # 获取交易列表\ngt.get_records()       # 获取所有record()记录\ngt.get_risk()          # 获取总的风险指标\ngt.get_period_risks()  # 获取分月计算的风险指标\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id = \"normalize_code\" ><\/span>normalize_code<\/label>\n      <label>股票代码格式转换<\/label>\n      <article>\n<pre><code class=\"python language-python\">normalize_code()\n<\/code><\/pre>\n\n将其他形式的股票代码转换为聚宽可用的股票代码形式。\n\n**仅适用于A股市场股票代码以及基金代码**\n\n**示例**\n<pre><code class=\"python language-python\">#输入\nfor code in ('000001', 'SZ000001', '000001SZ', '000001.sz', '000001.XSHE'):\n        print normalize_code(code)\n\n#输出\n000001.XSHE\n000001.XSHE\n000001.XSHE\n000001.XSHE\n000001.XSHE\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id = \"enable_profile\" ><\/span><span id = \"性能分析\" ><\/span>enable_profile ♠<\/label>\n      <label>性能分析 <\/label>\n      <article>\n<pre><code class=\"python language-python\">enable_profile()\n<\/code><\/pre>\n\n**回测环境\/模拟专用API**\n\n开启性能分析功能, **请在所有代码之前调用这句话(即在策略编译页面的代码编辑框最上方放置该代码)**, 只在点击 '运行回测' 运行的时候才能看到性能分析结果.\n开启性能分析之后, 你会在回测结果页面看到性能分析结果.\n请注意, 不需要时, 请不要调用此函数, 因为它本身会影响程序性能.\n\n结果示例(真实输出中没有中文说明):\n<pre><code>\/\/ 时间单位: 微秒\nTimer unit: 1e-06 s\n\n\/\/ 函数执行总时间\nTotal time: 0.00277 s\n\/\/ 文件名\nFile: user_code.py\n\/\/ 函数名\nFunction: initialize at line 3\n\n\/\/  行号, 这一行执行次数,总执行时间,每次执行时间, 这一行执行时间在整个函数的比例\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n     3                                           def initialize(context):\n     4                                               # 定义一个全局变量, 保存要操作的股票\n     5                                               # 000001(股票:平安银行)\n     6         1           31     31.0      1.1      g.security = '000001.XSHE'\n     7                                               # 初始化此策略\n     8                                               # 设置我们要操作的股票池, 这里我们只操作一支股票\n     9         1         2739   2739.0     98.9      set_universe([g.security])\n\nTotal time: 0.426325 s\nFile: user_code.py\nFunction: handle_data at line 12\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n    12                                           def handle_data(context, data):\n    13       122          398      3.3      0.1      security = g.security\n    14                                               # 取得过去五天的平均价格\n    15       122       168565   1381.7     39.5      average_price = data[security].mavg(5)\n    16                                               # 取得上一时间点价格\n    17       122          493      4.0      0.1      current_price = data[security].price\n    18                                               # 取得当前的现金\n    19       122          240      2.0      0.1      cash = context.portfolio.cash\n    20\n    21                                               # 如果上一时间点价格高出五天平均价1%, 则全仓买入\n    22       122          396      3.2      0.1      if current_price &gt; 1.01*average_price:\n    23                                                   # 计算可以买多少只股票\n    24        30          124      4.1      0.0          number_of_shares = int(cash\/current_price)\n    25                                                   # 购买量大于0时，下单\n    26        30           56      1.9      0.0          if number_of_shares &gt; 0:\n    27                                                       # 买入股票\n    28        30        83190   2773.0     19.5              order(security, +number_of_shares)\n    29                                                       # 记录这次买入\n    30        30        16202    540.1      3.8              log.info(\"Buying %s\" % (security))\n    31                                               # 如果上一时间点价格低于五天平均价, 则空仓卖出\n    32        92         1119     12.2      0.3      elif current_price &lt; average_price and context.portfolio.positions[security].amount &gt; 0:\n    33                                                   # 卖出所有股票,使这只股票的最终持有量为0\n    34        13        86702   6669.4     20.3          order_target(security, 0)\n    35                                                   # 记录这次卖出\n    36        13         8210    631.5      1.9          log.info(\"Selling %s\" % (security))\n    37                                               # 画出上一时间点价格\n    38       122        60630    497.0     14.2      record(stock_price=data[security].price)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h3 id=\"策略组合操作\">策略组合操作<\/h3>\n<p><span id = \"fencang\" ><\/span><\/p>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label><span id=\"init_subportfolios\"><\/span>set_subportfolios<\/label>\n      <label>初始化策略子账户 subportfolios<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_subportfolios([SubPortfolioConfig(cash,type), ... ])\n<\/code><\/pre>\n\n**初始化或者修改 subportfolios 的配置，只能在 initialize 中调用, 每个 SubPortfolioConfig 中 cash 的和应该等于总的初始资金**\n\n**SubPortfolioConfig 参数**\n<pre><code class=\"python language-python\">SubPortfolioConfig(cash,type)\n<\/code><\/pre>\n\n- cash: 仓位初始资金\n- type: 可操作标的的类型，'stock' \/ 'index_futures' \/ 'futures'  \/ 'stock_margin' \/ ‘open\\_fund',  其中 stock 包括股票和基金，index_futures 指金融期货，futures 包含股指期货和商品期货，stock_margin 为融资融券账户, open\\_fund为场外基金账户。\n\n**示例**\n<pre><code class=\"python language-python\">init_cash = 500000 # 定义一个变量\n# 设定subportfolios[0]为 股票和基金仓位，初始资金为 init_cash 变量代表的数值\n# 设定subportfolios[1]为 金融期货仓位，初始资金为 init_cash 变量代表的数值\n# 设定subportfolios[2]为 融资融券账户，初始资金为 init_cash 变量代表的数值\nset_subportfolios([SubPortfolioConfig(cash=init_cash, type='stock'),\\\n                   SubPortfolioConfig(cash=init_cash, type='futures'),\\\n                   SubPortfolioConfig(cash=init_cash, type='stock_margin')])\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"SubPortfolio\"><\/span>SubPortfolio<\/label>\n      <label>子账户信息<\/label>\n      <article>\n\n某个仓位的资金，标的信息，如不使用 SubPortfolioConfig 设置多仓位，默认只有subportfolios[0]一个仓位，Portfolio 指向该仓位。每个策略最多可以创建100个 subportfolio。\n\n有关 SubPortfolio 详情见[对象 - SubPortfolio](#subportfolios)\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label><span id=\"transfer_cash\"><\/span>transfer_cash<\/label>\n      <label>账户间转移资金<\/label>\n      <article>\n<pre><code class=\"python language-python\">transfer_cash(from_pindex, to_pindex, cash)\n<\/code><\/pre>\n\n从序号为 from_pindex 的 subportfolio 转移 cash 到序号为 to_pindex 的 subportfolio\n资金转移及时到账\n\n**示例**\n<pre><code class=\"python language-python\"># 从subportfolio[0] 向 subportfolio[1] 转移 500000\ntransfer_cash(from_pindex=0, to_pindex=1, cash=500000)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h3 id=\"Tick级策略专用函数\">Tick 级策略专用函数<\/h3>\n<p><span id = \"tick_bt\" > <\/span><\/p>\n<p><strong>Tick级回测模拟需要申请才能使用，<a href=\"http:\/\/joinquant.mikecrm.com\/lFNhkfR\">申请链接<\/a><\/strong><\/p>\n<p><strong>注意Tick级回测必须使用真实价格模式，设置方式详见<a href=\"#use_real_price\">设置真实价格模式<\/a><\/strong><\/p>\n<p><strong>股票部分， 支持 2017-01-01 至今的tick数据，提供买五卖五数据。<\/strong><\/p>\n<p><strong>期货部分， 支持 2010-01-01 至今的tick数据，提供买一卖一数据。<\/strong> <\/p>\n<h4 id=\"tickapi\"><strong>Tick级专用API<\/strong><\/h4>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>handle_tick <span id=\"handle_tick\"><\/span> <\/label>\n      <label>策略运行<\/label>\n      <article>\n<pre><code class=\"python language-python\">handle_tick(context, tick)\n<\/code><\/pre>\n\n该函数在策略订阅的标的产生 tick 事件时被调用一次。如果没有 tick 事件， 则不会被调用。 \n\n**参数**\n\n- context: [context](#Context) 对象, 存放有当前的账户\/标的持仓信息 \n- tick: [tick](#tick) 对象， 存放了触发 handle_tick 事件的 tick 数据。 \n\n**返回** \n\n- None\n\n**示例**\n<pre><code class=\"python language-python\">def handle_tick(context, tick):\n    log.info(tick)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>subscribe <span id=\"subscribe\"><\/span> <\/label>\n      <label>订阅标的的 tick 事件<\/label>\n      <article>\n<pre><code class=\"python language-python\"> subscribe(security, frequency)\n<\/code><\/pre>\n\n订阅标的的 tick 事件， 必须在频率为 tick 的回测、模拟中使用。\n\n**参数**\n\n- security：要订阅的标的代码或代码列表。目前支持订阅股票、商品期货和股指期货，不能直接订阅主力合约、指数合约代码。 每个策略，回测中不限订阅标的数量，模拟交易时中最多可同时订阅100个标的。\n- frequency：目前必须使用'tick'\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>unsubcribe <span id=\"unsubscribe\"><\/span> <\/label>\n      <label>取消订阅标的的 tick 事件<\/label>\n      <article>\n<pre><code class=\"python language-python\">unsubscribe(security, frequency)\n<\/code><\/pre>\n\n取消订阅标的的 tick 事件\n\n**参数**\n\n- security：要取消订阅的标的代码或代码列表。\n- frequency：目前必须使用'tick'\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>unsubscribe_all <span id=\"unsubscribe_all\"><\/span> <\/label>\n      <label>取消订阅所有 tick 事件<\/label>\n      <article>\n<pre><code class=\"python language-python\">unsubscribe_all()\n<\/code><\/pre>\n取消订阅所有 tick 事件\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_current_tick <span id=\"get_current_tick\"><\/span> <\/label>\n      <label>获取最新的 tick 数据<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_current_tick(security)\n<\/code><\/pre>\n\n**参数**\n\n- security: 标的代码， 支持股票、商品期货和股指期货。 不可以使用主力合约和指数合约代码。\n\n**返回** \n[tick 对象](#tick对象)\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_ticks <span id=\"get_ticks\"><\/span> <\/label>\n      <label>获取股票和期货 tick 数据<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_ticks(security, end_dt, start_dt=None, count=None, fields=['time', 'current', 'high', 'low', 'volume', 'money'])\n<\/code><\/pre>\n\n**股票部分， 支持 2017-01-01 至今的tick数据，提供买五卖五数据。**\n\n**期货部分， 支持 2010-01-01 至今的tick数据，提供买一卖一数据。** 如果要获取主力合约的tick数据，可以先使用get_dominant_future(underlying_symbol,dt)获取主力合约对应的标的，然后再用get_ticks()获取该合约的tick数据\n\n**参数**：\n\n- security: 股票代码或期货代码\n- end_dt: 结束日期\n- start_dt: 开始日期, 与count参数二选一\n- count: 取出指定时间区间内前多少条的tick数据, 与start_dt参数二选一\n- fields:  选择要获取的行情数据字段，默认为[\"time\", \"current\", \"high\", \"low\", \"volume\", \"money\"]\n\n**返回值**\n\n一个numpy.ndarray。ndarray打印输出没有附带字段名，但您仍然可以通过```array[field]```的形式获取对应字段的数据。\n\n\n- **股票tick返回结果**\n\n| 字段名    | 说明       | 字段类型 |\n| --------- | ---------- | ------- |\n| time      | 时间       | float |\n| current   | 当前价     | float    |\n| high      | 最高价     | float    |\n| low       | 最低价     | float    |\n| volume    | 累计成交量 | float    |\n| money     | 累计成交额 | float    |\n| a1_v~a5_v | 五档卖量   | float    |\n| a1_p~a5_p | 五档卖价   | float    |\n| b1_v~b5_v | 五档买量   | float    |\n| b1_p~b5_v | 五档买价   | float    |\n\n\n- **期货tick返回结果：**\n\n| 字段名   | 说明       | 字段类型 |\n| -------- | ----------| -------- |\n| time     | 时间       | float |\n| current  | 当前价     | float    |\n| high     | 最高价     | float    |\n| low      | 最低价     | float    |\n| volume   | 累计成交量 | float    |\n| money    | 累计成交额 | float    |\n| position | 持仓量     | float    |\n| a1_v     | 一档卖量   | float    |\n| a1_p     | 一档卖价   | float    |\n| b1_v     | 一档买量   | float    |\n| b1_p     | 一档买价   | float    |\n\n\n**股票tick数据示例**：\n<pre><code class=\"python language-python\">#获取平安银行2018-07-02的tick数据，start_dt和count只能有一个不为None值\nd = get_ticks(\"000001.XSHE\",start_dt=None, end_dt=\"2018-07-02\", count=10)\nprint(d)\n\n[(20180702145636.0, 8.61, 9.05, 8.56, 1282514.0, 1130125956.0)\n (20180702145639.0, 8.6199, 9.05, 8.56, 1282536.0, 1130145028.0)\n (20180702145642.0, 8.6199, 9.05, 8.56, 1283323.0, 1130822660.0)\n (20180702145645.0, 8.6199, 9.05, 8.56, 1283486.0, 1130963076.0)\n (20180702145648.0, 8.61, 9.05, 8.56, 1283800.0, 1131233412.0)\n (20180702145651.0, 8.6199, 9.05, 8.56, 1284203.0, 1131580548.0)\n (20180702145654.0, 8.6199, 9.05, 8.56, 1284250.0, 1131620996.0)\n (20180702145657.0, 8.6199, 9.05, 8.56, 1284850.0, 1132138244.0)\n (20180702145700.0, 8.6199, 9.05, 8.56, 1285148.0, 1132395012.0)\n (20180702150003.0, 8.61, 9.05, 8.56, 1315520.0, 1158545922.0)]\n<\/code><\/pre>\n\n**期货tick数据示例**：\n<pre><code class=\"python language-python\">#获取AU1812期货合约在2018-07-02的tick数据,start_dt和count只能有一个不为None值\n&gt;&gt;&gt;get_ticks('AU1812.XSGE',start_dt='2018-07-02',end_dt='2018-07-03',count=None)\n[(20180702090000.0, 271.9, 272.45, 271.0, 44536.0, 12100317200.0)\n (20180702090001.0, 271.85, 272.45, 271.0, 44664.0, 12135122600.0)\n (20180702090001.5, 271.9, 272.45, 271.0, 44674.0, 12137841500.0) ...,\n (20180702235945.0, 272.05, 272.95, 272.0, 42986.0, 11717679600.0)\n (20180702235946.0, 272.05, 272.95, 272.0, 42994.0, 11719856000.0)\n (20180702235959.0, 272.05, 272.95, 272.0, 42998.0, 11720944200.0)]\n<\/code><\/pre>\n\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h4 id=\"tick\"><strong>Tick级示例策略<\/strong><\/h4>\n<h5 id=\"1\">示例1：<\/h5>\n<pre><code class=\"python language-python\">def initialize(context):\n    init_cash = context.portfolio.starting_cash\n    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='futures')])\n\n    g.code1 = 'RB1802.XSGE'\n    g.code2 = 'I1710.XDCE'\n    subscribe(g.code1, 'tick')\n    #subscribe(g.code2, 'tick')\n    unsubscribe(g.code2, 'tick')\n    unsubscribe_all()\n    subscribe(g.code1, 'tick')\n\ndef handle_tick(context, tick):\n    #pass\n    log.info(tick)\n    get_current_tick(g.code1)\n    #order(g.code1, 1 , side='short', pindex=0)\n<\/code><\/pre>\n<h5 id=\"2\">示例2：<\/h5>\n<pre><code class=\"python language-python\"># 导入函数库\nimport jqdata\ndef initialize(context):\n    set_benchmark('000300.XSHG')\n    set_option('use_real_price', True)\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n\ndef before_trading_start(context):\n    subscribe('000001.XSHE','tick')\n\ndef handle_tick(context, tick):\n    log.info(tick)\n\ndef after_trading_end(context):\n    unsubscribe_all()\n<\/code><\/pre>\n<h3 id=\"融资融券专用函数\">融资融券专用函数<\/h3>\n<p><span id = \"rongzirongquan\" > <\/span><\/p>\n<h4 id=\"spanidsetrzrqspan\"><strong>初始化融资融券账户<\/strong><span id = \"setrzrq\" ><\/span><\/h4>\n<p>初始化的仓位是<strong>不允许<\/strong>直接进行融资融券操作的，因为初始默认 subportfolios[0] 中 SubPortfolioConfig 的 type = 'stock'，只允许买卖股票与场内基金等。<\/p>\n<p>因此要进行融资融券，您需要设定 SubPortfolioConfig 的 type = 'stock_margin'，具体方法如下：<\/p>\n<pre><code class=\"python language-python\">def initialize(context):\n\n    ## 设置单个账户\n    # 获取初始资金\n    init_cash = context.portfolio.starting_cash \n    # 设定账户为融资融券账户，初始资金为 init_cash 变量代表的数值（如不使用设置多账户，默认只有subportfolios[0]一个账户，Portfolio 指向该账户。）\n    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='stock_margin')])\n\n    — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —\n    ## 设置多个账户\n    # 获取初始资金，并等分为三份\n    init_cash = context.portfolio.starting_cash\/3\n    # 设定subportfolios[0]为 股票和基金仓位，初始资金为 init_cash 变量代表的数值\n    # 设定subportfolios[1]为 金融期货仓位，初始资金为 init_cash 变量代表的数值\n    # 设定subportfolios[2]为 融资融券账户，初始资金为 init_cash 变量代表的数值\n    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='stock'),\\\n                       SubPortfolioConfig(cash=init_cash, type='index_futures'),\\\n                       SubPortfolioConfig(cash=init_cash, type='stock_margin')])\n<\/code><\/pre>\n<h4 id=\"api\"><strong>融资融券专用API<\/strong><\/h4>\n<p><strong>注意：get_marginsec_stocks和get_margincash_stocks无法获取当前未完结交易日的数据，因为交易所的数据尚未生成。<\/strong><\/p>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>margincash_interest_rate <span id = \"margincash_interest_rate'\" ><\/span>  <\/label>\n      <label>设置融资利率<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_option('margincash_interest_rate', value)\n<\/code><\/pre>\n设定融资利率, 默认 8%\n\n**参数**\n\n- value: 融资利率的值, 默认 8%\n\n**示例**<pre><code class=\"python language-python\"># 设定融资利率: 年化8%\nset_option('margincash_interest_rate', 0.08)\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>margincash_margin_rate <span id = \"margincash_margin_rate\" ><\/span>  <\/label>\n      <label>设置融资保证金比率<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_option('margincash_margin_rate', value)\n<\/code><\/pre>\n设置融资保证金比率, 默认 100%\n\n**参数**\n\n- value: 融资保证金比率的值, 默认 100%\n\n**示例**<pre><code class=\"python language-python\"># 设置融资保证金比率: 150%\nset_option('margincash_margin_rate', 1.5)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>marginsec_interest_rate <span id = \"marginsec_interest_rate\" ><\/span> <\/label>\n      <label>设置融券利率<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_option('marginsec_interest_rate', value)\n<\/code><\/pre>\n设定融券利率: 年化 10%, 默认 10%\n\n**参数**\n\n- value: 融券利率的值, 默认 10%\n\n**示例**<pre><code class=\"python language-python\"># 设定融券利率: 年化10%\nset_option('marginsec_interest_rate', 0.10)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>marginsec_margin_rate <span id = \"marginsec_margin_rate\" ><\/span>  <\/label>\n      <label>设置融券保证金比率<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_option('marginsec_margin_rate', value)\n<\/code><\/pre>\n设定融券保证金比率: 150%, 默认 100%\n\n**参数**\n\n- value: 融券保证金比率的值, 默认 100%\n\n**示例**<pre><code class=\"python language-python\"># 设定融券保证金比率: 150%\nset_option('marginsec_margin_rate', 1.5)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>margincash_open <span id = \"margincash_open\" ><\/span> <\/label>\n      <label>融资买入<\/label>\n      <article>\n<pre><code class=\"python language-python\">margincash_open(security, amount, style=None, pindex=0)\n<\/code><\/pre>\n融资买入\n\n**参数**\n\n- security: 标的代码\n- amount: 数量\n- style: 参见[order styles], None代表MarketOrder\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，**默认为0**。\n\n**返回**\nOrder对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None\n\n**示例**<pre><code class=\"python language-python\"># 融资买入平安银行 1000 股\nmargincash_open('000001.XSHE', 1000)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>margincash_close <span id = \"margincash_close\" ><\/span> <\/label>\n      <label>卖券还款<\/label>\n      <article>\n<pre><code class=\"python language-python\">margincash_close(security, amount, style=None, pindex=0)\n<\/code><\/pre>\n卖券还款\n\n**参数**\n\n- security: 标的代码\n- amount: 数量\n- style: 参见[order styles], None代表MarketOrder\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，**默认为0**。\n\n**返回**\nNone\n\n**示例**<pre><code class=\"python language-python\"># 卖出 1000 股平安银行用以还款\nmargincash_close('000001.XSHE', 1000)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>margincash_direct_refund <span id = \"margincash_direct_refund\" ><\/span> <\/label>\n      <label>直接还款<\/label>\n      <article>\n<pre><code class=\"python language-python\">margincash_direct_refund(value, pindex=0)\n<\/code><\/pre>\n直接还款\n\n**参数**\n\n- value: 还款金额\n\n**返回**\nNone\n\n**示例**<pre><code class=\"python language-python\"># 还款 100000 元\nmargincash_direct_refund(100000)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>marginsec_open <span id = \"marginsec_open\" ><\/span>  <\/label>\n      <label>融券卖出<\/label>\n      <article>\n<pre><code class=\"python language-python\">marginsec_open(security, amount, style=None, pindex=0)\n<\/code><\/pre>\n融券卖出\n\n**参数**\n\n- security: 标的代码\n- amount: 数量\n- style: 参见[order styles], None代表MarketOrder\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，**默认为0**。\n\n**返回**\nOrder对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None\n\n**示例**<pre><code class=\"python language-python\"># 融券卖出 1000 股 平安银行\nmarginsec_open('000001.XSHE', 1000)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>marginsec_close <span id = \"marginsec_close\" ><\/span> <\/label>\n      <label>买券还券<\/label>\n      <article>\n<pre><code class=\"python language-python\">marginsec_close(security, amount, style=None, pindex=0)\n<\/code><\/pre>\n买券还券\n\n**参数**\n\n- security: 标的代码\n- amount: 数量\n- style: 参见[order styles], None代表MarketOrder\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，**默认为0**。\n\n**返回**\nNone\n\n**示例**<pre><code class=\"python language-python\"># 买入 1000 股平安银行用以还券\nmarginsec_close('000001.XSHE', 1000)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>marginsec_direct_refund <span id = \"marginsec_direct_refund\" ><\/span> <\/label>\n      <label>直接还券<\/label>\n      <article>\n<pre><code class=\"python language-python\">marginsec_direct_refund(security, amount, pindex=0)\n<\/code><\/pre>\n直接还券\n\n**参数**\n\n- security: 标的代码\n- amount: 数量\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，**默认为0**。\n\n**返回**\nNone\n\n**示例**<pre><code class=\"python language-python\">## 如果账户持仓中\"有\" 1000股 平安银行\n# 直接还 1000 股平安银行\nmarginsec_direct_refund('000001.XSHE', 1000)\n\n— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —\n\n## 如果账户持仓中\"没有\" 1000股 平安银行\n# 需先买入 1000 股平安银行\norder('000001.XSHE', 1000)\n# 再直接还 1000 股平安银行\nmarginsec_direct_refund('000001.XSHE', 1000)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_margincash_stocks <span id = \"get_margincash_stocks\" ><\/span> <\/label>\n      <label>获取融资标的列表<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_margincash_stocks()\n<\/code><\/pre>\n**参数**\ndate: 查询日期，回测模块中若不填，日期默认为回测的日期；研究模块中若不填，默认为最新日期；也可指定日期。\n\n\n**返回**\n返回上交所、深交所最近一次披露的的可融资标的列表的list。\n\n**示例**<pre><code class=\"python language-python\"># 获取融资标的列表，并赋值给 margincash_stocks\nmargincash_stocks = get_margincash_stocks()\n\n# 判断平安银行是否在可融资列表\n&gt;&gt;&gt; '000001.XSHE' in get_margincash_stocks()\n&gt;&gt;&gt; True\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_marginsec_stocks <span id = \"get_marginsec_stocks\" ><\/span> <\/label>\n      <label>获取融券标的列表<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_marginsec_stocks(date=None)\n<\/code><\/pre>\n**参数**\ndate: 查询日期，回测模块中若不填，日期默认为回测的日期；研究模块中若不填，默认为最新日期；也可指定日期。\n\n\n**返回**\n返回上交所、深交所最近一次披露的的可融券标的列表的list。\n\n**示例**<pre><code class=\"python language-python\"># 获取融券标的列表，并赋值给 marginsec_stocks\nmarginsec_stocks= get_marginsec_stocks()\n\n# 判断平安银行是否在可融券列表\n&gt;&gt;&gt; '000001.XSHE' in get_marginsec_stocks()\n&gt;&gt;&gt; True\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>jqdata.get_mtss <span id=\"get_mtss\"><\/span> <\/label>\n      <label>获取融资融券信息<\/label>\n      <article>\n<pre><code class=\"python language-python\">from jqdata import *\nget_mtss(security_list, start_date=None, end_date=None, fields=None, count=None)\n<\/code><\/pre>\n\n获取一只或者多只股票在一个时间段内的融资融券信息\n\n**注： 需导入 jqdata 模块，即在策略或研究起始位置加入`from jqdata import *`**\n\n**参数**\n\n- security_list: 一只股票代码或者一个股票代码的 list\n- start_date: 开始日期, **与 count 二选一, 不可同时使用**. 一个字符串或者 [datetime.datetime]\/[datetime.date] 对象, 默认为平台提供的数据的最早日期\n- end_date: 结束日期, 一个字符串或者 [datetime.date]\/[datetime.datetime] 对象, 默认为 datetime.date.today()\n- count: 数量, **与 start_date 二选一，不可同时使用**, 必须大于 0. 表示返回 end_date 之前 count 个交易日的数据, 包含 end_date\n- fields: 字段名或者 list, 可选. 默认为 None, 表示取全部字段, 各字段含义如下：\n\n|字段名|含义|\n|---|---|\n|date|日期|\n|sec_code|股票代码|\n|fin_value|融资余额（元）|\n|fin_buy_value|融资买入额（元）|\n|fin_refund_value|融资偿还额（元）|\n|sec_value|融券余量（股）|\n|sec_sell_value|融券卖出量（股）|\n|sec_refund_value|融券偿还量（股）|\n|fin_sec_value|融资融券余额（元）|\n\n**返回**\n\n返回一个 [pandas.DataFrame] 对象，默认的列索引为取得的全部字段. 如果给定了 fields 参数, 则列索引与给定的 fields 对应.\n\n**示例**\n<pre><code class=\"python language-python\"># 导入聚宽函数库\nfrom jqdata import *\n\n# 获取一只股票的融资融券信息\nget_mtss('000001.XSHE', '2016-01-01', '2016-04-01')\nget_mtss('000001.XSHE', '2016-01-01', '2016-04-01', fields=[\"date\", \"sec_code\", \"fin_value\", \"fin_buy_value\"])\nget_mtss('000001.XSHE', '2016-01-01', '2016-04-01', fields=\"sec_sell_value\")\n\n# 获取多只股票的融资融券信息\nget_mtss(['000001.XSHE', '000002.XSHE', '000099.XSHE'], '2015-03-25', '2016-01-25')\nget_mtss(['000001.XSHE', '000002.XSHE', '000099.XSHE'], '2015-03-25', '2016-01-25', fields=[\"date\", \"sec_code\", \"sec_value\", \"fin_buy_value\", \"sec_sell_value\"])\n\n# 获取股票 000001.XSHE 在日期 2016-06-30 往前 20 个交易日的融资融券信息\nget_mtss('000001.XSHE', end_date=\"2016-06-30\", count=20)\n# 获取股票 000001.XSHE 往前 20 个交易日的融资融券信息\nget_mtss('000001.XSHE', count=20)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h3 id=\"期货策略专用函数\">期货策略专用函数<\/h3>\n<p><span id = \"ccfx_api\" > <\/span><\/p>\n<h4 id=\"spanidsetccfxspan\"><strong>初始化期货账户<\/strong><span id = \"setccfx\" ><\/span><\/h4>\n<p>初始化的仓位是<strong>不允许<\/strong>直接买卖期货的，因为初始默认 subportfolios[0] 中 SubPortfolioConfig 的 type = 'stock'，只允许买卖股票与场内基金等。<\/p>\n<p>因此要买卖期货，您需要设定 SubPortfolioConfig 的 type = 'futures'，具体方法如下：<\/p>\n<pre><code class=\"python language-python\">def initialize(context):\n\n    ## 设置单个账户\n    # 获取初始资金\n    init_cash = context.portfolio.starting_cash \n    # 设定账户为金融账户，初始资金为 init_cash 变量代表的数值（如不使用设置多账户，默认只有subportfolios[0]一个账户，Portfolio 指向该账户。）\n    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='futures')])\n\n    — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —\n    ## 设置多个账户\n    # 获取初始资金，并等分为三份\n    init_cash = context.portfolio.starting_cash\/3\n    # 设定subportfolios[0]为 股票和基金仓位，初始资金为 init_cash 变量代表的数值\n    # 设定subportfolios[1]为 金融期货仓位，初始资金为 init_cash 变量代表的数值\n    # 设定subportfolios[2]为 融资融券账户，初始资金为 init_cash 变量代表的数值\n    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='stock'),\\\n                       SubPortfolioConfig(cash=init_cash, type='futures'),\\\n                       SubPortfolioConfig(cash=init_cash, type='stock_margin')])\n<\/code><\/pre>\n<h4 id=\"\"><strong>期货信息<\/strong><\/h4>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>主力连续合约<\/label>\n      <label>主力连续合约信息<\/label>\n      <article>\n\n1. 期货合约的生存周期是有限的，到合约最后交易日后就要交割。因此我们根据持仓量对期货合约进行拼接，形成主力连续合约。\n2. 合约代码：品种代号+9999，例如AG9999(白银主力合约)、Y9999(豆油主力合约)。\n3. 主力合约定义：如果某合约持仓量连续2天为同一个品种中最大的，且该合约相对于当前主力合约为远期合约，则自动变成主力合约。不会在日内进行主力合约切换。\n4. **不可直接对主力合约进行下单**。请使用get_dominant_future获取主力合约对应的具体合约。\n\n下面是主要期货交易所的主力合约列表：\n\n**中金所**\n\n| 代码        | 名称            | 代码        | 名称               |\n| ----------- | --------------- | ----------- | ------------------ |\n| IC9999.CCFX | 中证500主力合约 | T9999.CCFX  | 10年期国债主力合约 |\n| IF9999.CCFX | 沪深300主力合约 | TF9999.CCFX | 5年期国债主力合约  |\n| IH9999.CCFX | 上证50主力合约  | -           | -                  |\n\n**上海国际能源交易中心**\n\n| 代码        | 名称         | 代码 | 名称 |\n| ----------- | ------------ | ---- | ---- |\n| SC9999.XINE | 原油主力合约 | -    | -    |\n\n**上期所**\n\n| 代码        | 名称             | 代码        | 名称             |\n| ----------- | ---------------- | ----------- | ---------------- |\n| AG9999.XSGE | 白银主力合约     | PB9999.XSGE | 铅主力合约       |\n| AU9999.XSGE | 黄金主力合约     | RB9999.XSGE | 螺纹钢主力合约   |\n| AL9999.XSGE | 铝主力合约       | RU9999.XSGE | 天然橡胶主力合约 |\n| BU9999.XSGE | 石油沥青主力合约 | SN9999.XSGE | 锡主力合约       |\n| CU9999.XSGE | 铜主力合约       | WR9999.XSGE | 线材主力合约     |\n| FU9999.XSGE | 燃料油主力合约   | ZN9999.XSGE | 锌主力合约       |\n| HC9999.XSGE | 热轧卷板主力合约 | NI9999.XSGE | 镍主力合约       |\n\n**郑商所**\n\n| 代码        | 名称                   | 代码        | 名称                 |\n| ----------- | ---------------------- | ----------- | -------------------- |\nCY9999.XZCE| 棉纱主力合约|RM9999.XZCE| 菜籽粕主力合约\nCF9999.XZCE| 棉花主力合约|FG9999.XZCE| 玻璃主力合约\nRS9999.XZCE| 油菜籽主力合约|JR9999.XZCE| 粳稻谷主力合约\nSF9999.XZCE| 硅铁主力合约|LR9999.XZCE| 晚籼稻主力合约\nSM9999.XZCE| 锰硅主力合约|MA9999.XZCE| 甲醇主力合约\nSR9999.XZCE| 白糖主力合约| ME9999.XZCE| 甲醇主力合约[退市]\nTA9999.XZCE| PTA主力合约| OI9999.XZCE| 菜籽油主力合约\nWH9999.XZCE| 强麦主力合约| RO9999.XZCE| 菜籽油主力合约[退市]\nWS9999.XZCE| 强麦主力合约[退市]| PM9999.XZCE| 普麦主力合约\nZC9999.XZCE| 动力煤主力合约| WT9999.XZCE| 硬白小麦主力合约[退市]\nTC9999.XZCE| 动力煤主力合约[退市]| RI9999.XZCE| 早籼稻主力合约\nGN9999.XZCE| 绿豆主力合约[退市]| ER9999.XZCE| 早籼稻主力合约[退市]\nAP9999.XZCE | 苹果主力合约\n\n**大商所**\n\n| 代码        | 名称             | 代码        | 名称             |\n| ----------- | ---------------- | ----------- | ---------------- |\n| A9999.XDCE  | 豆一主力合约     | JD9999.XDCE | 鸡蛋主力合约     |\n| B9999.XDCE  | 豆二主力合约     | JM9999.XDCE | 焦煤主力合约     |\n| BB9999.XDCE | 胶合板主力合约   | L9999.XDCE  | 聚乙烯主力合约   |\n| C9999.XDCE  | 玉米主力合约     | M9999.XDCE  | 豆粕主力合约     |\n| CS9999.XDCE | 玉米淀粉主力合约 | P9999.XDCE  | 棕榈油主力合约   |\n| FB9999.XDCE | 纤维板主力合约   | PP9999.XDCE | 聚丙烯主力合约   |\n| I9999.XDCE  | 铁矿石主力合约   | V9999.XDCE  | 聚氯乙烯主力合约 |\n| J9999.XDCE  | 焦炭主力合约     | Y9999.XDCE  | 豆油主力合约     |\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>品种指数<\/label>\n      <label>品种指数信息<\/label>\n      <article>\n\n下面是主要期货交易所的期货指数列表：\n\n**中金所**\n\n| 代码        | 名称            | 代码        | 名称               |\n| ----------- | --------------- | ----------- | ------------------ |\n| IC8888.CCFX | 中证500期货指数 | T8888.CCFX  | 10年期国债期货指数 |\n| IF8888.CCFX | 沪深300期货指数 | TF8888.CCFX | 5年期国债期货指数  |\n| IH8888.CCFX | 上证50期货指数  | -           | -                  |\n\n**上海国际能源交易中心**\n\n| 代码        | 名称         | 代码 | 名称 |\n| ----------- | ------------ | ---- | ---- |\n| SC8888.XINE | 原油期货指数 | -    | -    |\n\n**上期所**\n\n| 代码        | 名称             | 代码        | 名称             |\n| ----------- | ---------------- | ----------- | ---------------- |\n| AG8888.XSGE | 白银期货指数     | PB8888.XSGE | 铅期货指数       |\n| AU8888.XSGE | 黄金期货指数     | RB8888.XSGE | 螺纹钢期货指数   |\n| AL8888.XSGE | 铝期货指数       | RU8888.XSGE | 天然橡胶期货指数 |\n| BU8888.XSGE | 石油沥青期货指数 | SN8888.XSGE | 锡期货指数       |\n| CU8888.XSGE | 铜期货指数       | WR8888.XSGE | 线材期货指数     |\n| FU8888.XSGE | 燃料油期货指数   | ZN8888.XSGE | 锌期货指数       |\n| HC8888.XSGE | 热轧卷板期货指数 | NI8888.XSGE | 镍期货指数       |\n\n**郑商所**\n\n| 代码        | 名称                   | 代码        | 名称                 |\n| ----------- | ---------------------- | ----------- | -------------------- |\nCY8888.XZCE| 棉纱期货指数|RM8888.XZCE| 菜籽粕期货指数\nCF8888.XZCE| 棉花期货指数|FG8888.XZCE| 玻璃期货指数\nRS8888.XZCE| 油菜籽期货指数|JR8888.XZCE| 粳稻谷期货指数\nSF8888.XZCE| 硅铁期货指数|LR8888.XZCE| 晚籼稻期货指数\nSM8888.XZCE| 锰硅期货指数|MA8888.XZCE| 甲醇期货指数\nSR8888.XZCE| 白糖期货指数| ME8888.XZCE| 甲醇期货指数[退市]\nTA8888.XZCE| PTA期货指数| OI8888.XZCE| 菜籽油期货指数\nWH8888.XZCE| 强麦期货指数| RO8888.XZCE| 菜籽油期货指数[退市]\nWS8888.XZCE| 强麦期货指数[退市]| PM8888.XZCE| 普麦期货指数\nZC8888.XZCE| 动力煤期货指数| WT8888.XZCE| 硬白小麦期货指数[退市]\nTC8888.XZCE| 动力煤期货指数[退市]| RI8888.XZCE| 早籼稻期货指数\nGN8888.XZCE| 绿豆期货指数[退市]| ER8888.XZCE| 早籼稻期货指数[退市]\nAP8888.XZCE | 苹果期货指数\n\n**大商所**\n\n| 代码        | 名称             | 代码        | 名称             |\n| ----------- | ---------------- | ----------- | ---------------- |\n| A8888.XDCE  | 豆一期货指数     | JD8888.XDCE | 鸡蛋期货指数     |\n| B8888.XDCE  | 豆二期货指数     | JM8888.XDCE | 焦煤期货指数     |\n| BB8888.XDCE | 胶合板期货指数   | L8888.XDCE  | 聚乙烯期货指数   |\n| C8888.XDCE  | 玉米期货指数     | M8888.XDCE  | 豆粕期货指数     |\n| CS8888.XDCE | 玉米淀粉期货指数 | P8888.XDCE  | 棕榈油期货指数   |\n| FB8888.XDCE | 纤维板期货指数   | PP8888.XDCE | 聚丙烯期货指数   |\n| I8888.XDCE  | 铁矿石期货指数   | V8888.XDCE  | 聚氯乙烯期货指数 |\n| J8888.XDCE  | 焦炭期货指数     | Y8888.XDCE  | 豆油期货指数     |\n\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>期货注意事项<\/label>\n      <label>期货策略注意事项<\/label>\n      <article>\n\n- 有夜盘的商品期货的一个交易日从前一天晚上 21:00 开始\n- 每日在16:00:00结算, 对于期货, 使用结算价结算\n- 期货持仓到交割日，没有手动交割，系统会以当天结算价平仓, 没有手续费, 不会有交易记录\n- 股指期货平今手续费默认为万分之六点九\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h4 id=\"api\"><strong>期货专用API<\/strong><\/h4>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>get_dominant_future <span id = \"get_dominant_future\" ><\/span> <\/label>\n      <label>获取主力合约对应的标的<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_dominant_future(underlying_symbol, date=None)\n<\/code><\/pre>\n\n**参数**\n\n-  underlying_symbol: 期货合约品种，如 'AG'(白银)\n-  date: 查询日期，回测模块中若不填，日期默认为回测的日期；研究模块中若不填，默认为最新日期；也可指定日期。\n\n**返回**\n\n- 主力合约对应的期货合约\n\n**示例**\n<pre><code class=\"python language-python\"># 获取某一天的主力合约对应的期货合约代码（策略当前日期是20160801）\n&gt;&gt;&gt; get_dominant_future('IF')\n\n# 输出\n'IF1608.CCFX'\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_future_contracts <span id = \"get_future_contracts\" ><\/span>  <\/label>\n      <label>期货可交易合约列表<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_future_contracts(underlying_symbol, date=None)\n<\/code><\/pre>\n获取某期货品种在策略当前日期的可交易合约标的列表\n\n**参数**\n\n-  security: 期货合约品种，如 'AG'(白银)\n-  date: 查询日期，回测模块中若不填，日期默认为回测的日期；研究模块中若不填，默认为最新日期；也可指定日期。\n\n**返回**\n\n- 某期货品种在策略当前日期的可交易合约标的列表\n\n**示例**\n<pre><code class=\"python language-python\"># 获取某一天的主力合约对应的期货合约代码（策略当前日期是20160601）\nget_future_contracts('IF')\n\n# 输出\n[u'IF1606.CCFX', u'IF1607.CCFX', u'IF1609.CCFX', u'IF1612.CCFX']\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>futures_margin_rate <span id=\"futures_margin_rate\"><\/span>  <\/label>\n      <label>设置期货保证金比例<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_option('futures_margin_rate', value)\n<\/code><\/pre>\n设置期货保证金比例。可为不同品种的标的设置不同比例的保证金。\n\n**参数**\n\n- value: value 是一个 float 值，为期货的保证金比例。\n\n**示例**<pre><code class=\"python language-python\"># 设定期货保证金比例\nset_option('futures_margin_rate', 0.25) # 设定期货保证金比例为25%\nset_option('futures_margin_rate.AU1709', 0.08)# 设定合约AU1709保证金比例为8%\nset_option('futures_margin_rate.AU', 0.09)# 设定所有黄金期货保证金比例为9%\nset_option('futures_margin_rate', 0.1)# 设定所有期货保证金比例为10%\nset_option('futures_margin_rate.IF', 0.15)# 设定所有股指期货保证金比例为15%\n<\/code><\/pre>\n不设置时，股指期货默认值 0.15 ；商品期货默认保证金比例如下：<pre><code class=\"python language-python\">A  0.07\nAG  0.04\nAL  0.05\nAU  0.04\nB  0.05\nBB  0.2\nBU  0.04\nC  0.07\nCF  0.05\nCS  0.07\nCU  0.05\nFB  0.2\nFG  0.05\nFU  0.08\nHC  0.04\nI  0.1\nJ  0.12\nJD  0.08\nJM  0.12\nJR  0.05\nL  0.07\nLR  0.05\nM  0.07\nMA  0.05\nNI  0.05\nOI  0.05\nP  0.05\nPB  0.05\nPM  0.05\nPP  0.07\nRB  0.05\nRI  0.05\nRM  0.05\nRS  0.05\nRU  0.05\nSF  0.05\nSM  0.05\nSN  0.05\nSR  0.05\nTA  0.05\nV  0.07\nWH  0.05\nWR  0.07\nY  0.05\nZC  0.05\nZN  0.05\n<\/code><\/pre>\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>is_dangerous <span id = \"is_dangerous\" ><\/span> <\/label>\n      <label>期货保证金预警<\/label>\n      <article>\n\n判断指定仓位，是否低于指定的保证金比率，高于该比例返回`False`，低于该比例返回`True`.\n<pre><code class=\"python language-python\">context.subportfolios[i].is_dangerous(margin_rate)\n<\/code><\/pre>\n**其中 i 是要查询的仓位编号, margin_rate 是要查询的保证金比例**\n\n**返回：** True 或 False\n\n**示例：**\n<pre><code class=\"python language-python\"># 查询 subportfolios[1] 中保证金是否低于 20%\ncontext.subportfolios[1].is_dangerous(0.2)\n\n# 低于则返回True， 高则返回 False\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_price等 <span id=\"get_future_quotes\"><\/span> <\/label>\n      <label>获取期货的行情数据<\/label>\n      <article>\n\n获取期货行情与获取股票行情的方法相同， [get_price](#get_price-获取历史数据)、[history](#history♠-获取历史数据)、[attribute_history](#attribute_history♠-获取历史数据)、[get_current_data](#get_current_data♠-获取当前时间数据)、[get_bars](#get_bars♠-获取历史数据) 等 API 均可正常使用。\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>order <span id=\"order-method_ccfx\"><\/span> <\/label>\n      <label>期货按股数下单<\/label>\n      <article>\n<pre><code class=\"python language-python\">order(security, amount, style=None, side='long', pindex=0, close_today=False)\n<\/code><\/pre>\n买卖标的。调用成功后, 您将可以调用[get_open_orders]取得所有未完成的交易, 也可以调用[cancel_order]取消交易\n\n**参数**\n\n- security: 标的代码\n- amount: 交易数量, 正数表示买入, 负数表示卖出\n- style: 参见[order styles], None代表MarketOrder\n- side: 'long'\/'short'，操作多单还是空单，默认为多单。\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0 指定第一个 subportfolio, 1 指定第二个 subportfolio，**默认为0**。\n- close_today: 平今字段。\n    - close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓\n    - close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓\n    - close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错\n\n**返回**\nOrder对象或者None, 如果创建订单成功, 则返回Order对象, 失败则返回None\n\n**示例**<pre><code class=\"python language-python\">## 如果期货账户是默认账户\n# 在仓位0中开一手沪深300指数期货的空单\norder('IF1412.CCFX', 1 , side='short', pindex=0)\n\n# 在仓位0中开一手沪深300指数期货的多单\norder('IF1412.CCFX', 1 , side='long', pindex=0)\n\n## 如果期货账户是仓位1\n# 在仓位1中以3600的限价单，平一手沪深300指数期货的空单\norder('IF1412.CCFX', -1 , LimitOrderStyle(3600.0), side='short', pindex=1)\n\n# 在仓位1中平一手沪深300指数期货的多单\norder('IF1412.CCFX', -1 , side='long', pindex=1)\n<\/code><\/pre>\n\n**可能的失败原因**:\n\n1. 标的不存在，对于该原因, 我们会抛出异常停止运行, 因为我们认为这是您代码的bug.\n2. 选择了不存在的仓位号，如没有建立多个仓位，而设定pindex的数大于0\n\n**注意**:\n\n- 因为下列原因, 有时候实际买入或者卖出的股票数量跟您设置的不一样，这个时候我们会在您的log中添加警告信息。\n\n1. 买入时会根据您当前的现金来限制您买入的数量\n2. 卖出时会根据您持有股票的数量来限制您卖出的数量\n3. 我们会遵守A股交易规则: 每次交易数量只能是100的整数倍, 但是卖光所有股票时不受这个限制\n\n- 根据交易所规则, 每天结束时会取消所有未完成交易\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>order_target <span id=\"order_target_ccfx\"><\/span> <\/label>\n      <label>期货目标股数下单<\/label>\n      <article>\n<pre><code class=\"python language-python\">order_target(security, amount, style=None, side='long', pindex=0, close_today=False)\n<\/code><\/pre>\n买卖标的, 使最终标的的数量达到指定的amount\n\n**参数**\n\n- security: 标的代码\n- amount: 期望的最终数量\n- style: 参见[order styles], None代表MarketOrder\n- side: 'long'\/'short'，操作多单还是空单，默认为多单。\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，**默认为0**。\n- close_today: 平今字段。\n    - close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓\n    - close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓\n    - close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错\n\n\n**返回**\nOrder对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None\n\n注意：**使用order_target进行开平仓时，请直接对目标方向进行操作，请看示例。**\n\n**示例**<pre><code class=\"python language-python\"># 开5手多单\norder_target('IF1412.CCFX', 5 , side='long', pindex=1)\n# 平1手多单\norder_target('IF1412.CCFX', 4 , side='long', pindex=1)\n# 再开5手空单，操作完成后持有多单4手，空单5手\norder_target('IF1412.CCFX', 5 , side='short', pindex=1)\n# 平1手空单，操作完成后持有多单4手，空单4手\norder_target('IF1412.CCFX', 4 , side='short', pindex=1)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n\n\n    <div class=\"group\">\n      <label>order_value <span id=\"order_value_ccfx\"><\/span> <\/label>\n      <label>期货按价值下单<\/label>\n      <article>\n<pre><code class=\"python language-python\">order_value(security, value, style=None, side='long', pindex=0, close_today=False)\n<\/code><\/pre>\n买卖价值为value的标的。\n\n**参数**\n\n- security: 标的名字\n- value: 股票价值\n- style: 参见[order styles], None代表MarketOrder\n- side: 'long'\/'short'，操作多单还是空单。默认为多单。\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，**默认为0**。\n- close_today: 平今字段。\n    - close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓\n    - close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓\n    - close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错\n\n\n**返回**\nOrder对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None\n\n注意：**使用order_value进行开平仓时，请直接对目标方向进行操作，请看示例。**\n\n**示例**<pre><code class=\"python language-python\"># 开市值5000000多单\norder_value('IF1412.CCFX', 5000000 , side='long', pindex=1)\n# 平市值4000000多单\norder_value('IF1412.CCFX', -4000000, side='long', pindex=1)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n\n\n    <div class=\"group\">\n      <label>order_target_value <span id=\"order_target_value_ccfx\"><\/span> <\/label>\n      <label>期货目标价值下单<\/label>\n      <article>\n<pre><code class=\"python language-python\">order_target_value(security, value, style=None, side='long', pindex=0, close_today=False)\n<\/code><\/pre>\n调整标的仓位到value价值。\n\n**参数**\n\n- security: 标的名字\n- value: 期望的标的最终价值\n- style: 参见[order styles], None代表MarketOrder\n- side: 'long'\/'short'，操作多单还是空单。\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，**默认为0**。\n- close_today: 平今字段。\n    - close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓\n    - close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓\n    - close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错\n\n\n**返回**\nOrder对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None\n\n注意：**使用order_target_value进行开平仓时，请直接对目标方向进行操作，请看示例。**\n\n**示例**<pre><code class=\"python language-python\"># 将IF1412.CCFX的多单市值调整至5000000\norder_target_value('IF1412.CCFX',5000000, side='long', pindex=1)\n# 将IF1412.CCFX的多单市值调整至4000000\norder_target_value('IF1412.CCFX', 4000000, side='long', pindex=1)\n# 平掉IF1412.CCFX的多单\norder_target_value('IF1412.CCFX', 0 , side='long', pindex=1)\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n  <\/div>\n\n<\/section>\n<h3 id=\"场外基金策略专用函数\">场外基金策略专用函数<\/h3>\n<p><span id = \"open_fund\" > <\/span>\n<strong>请使用 <a href=\"#get_extras\">get_extras<\/a> 获取场外基金的净值信息。<\/strong><br \/>\n<strong>在进行申购与赎回操作前， 需要先使用 set_subportfolios 设置独立的场外基金仓位。<\/strong><br \/>\n<strong>在申购与赎回份额时， 使用 purchase 和 redeem 两个 API 接口。<\/strong><\/p>\n<h4 id=\"spanidset_open_fundspan\"><strong>初始场外基金账户<\/strong><span id = \"set_open_fund\" ><\/span><\/h4>\n<p>初始化的仓位是<strong>不允许<\/strong>直接买卖场外基金的，因为初始默认 subportfolios[0] 中 SubPortfolioConfig 的 type = 'stock'，只允许买卖股票与场内基金。<\/p>\n<p>因此要买卖场外基金，您需要设定 SubPortfolioConfig 的 type = 'open_fund'，具体方法如下：<\/p>\n<pre><code class=\"python language-python\">def initialize(context):\n\n    ## 设置单个账户\n    # 获取初始资金\n    init_cash = context.portfolio.starting_cash \n    # 设定账户为场外基金账户，初始资金为 init_cash 变量代表的数值（如不使用设置多账户，默认只有subportfolios[0]一个账户，Portfolio 指向该账户。）\n    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='open_fund')])\n\n    — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —\n    ## 设置多个账户\n    # 获取初始资金，并等分为三份\n    init_cash = context.portfolio.starting_cash\/3\n    # 设定subportfolios[0]为 股票和基金仓位，初始资金为 init_cash 变量代表的数值\n    # 设定subportfolios[1]为 场外基金仓位，初始资金为 init_cash 变量代表的数值\n    # 设定subportfolios[2]为 融资融券账户，初始资金为 init_cash 变量代表的数值\n    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='stock'),\\\n                       SubPortfolioConfig(cash=init_cash, type='open_fund'),\\\n                       SubPortfolioConfig(cash=init_cash, type='stock_margin')])\n<\/code><\/pre>\n<h4 id=\"spanidmatch_pricespan\"><span id=\"match_price\"><\/span> 场外基金成交价格说明<\/h4>\n<ul>\n<li>非QDII基金，今日申购，按今天的收盘净值价格进行撮合<\/li>\n<li>非QDII基金，今日只能拿到昨天的净值，延迟T+1，因此撮合成交在第二天<\/li>\n<li>QDII基金，今日可以拿到前天的净值，延迟T+2，因此撮合成交在第三天<\/li>\n<\/ul>\n<h4 id=\"api\"><strong>场外基金专用API<\/strong><\/h4>\n<section>\n  <div class=\"header\">\n    <label>名称<\/label>\n    <label>描述<\/label>\n  <\/div>\n  <div class=\"body\">\n\n    <div class=\"group\">\n      <label>purchase <span id=\"purchase\"><\/span> <\/label>\n      <label>申购基金<\/label>\n      <article>\n<pre><code class=\"python language-python\">purchase(security, cash, pindex=0)\n<\/code><\/pre>\n\n申购基金API接口\n\n**参数**\n\n- security: 基金代码编号，OF作为尾缀的字符串，例如招商中证白酒指数分级基金为“161725.OF\"\n- cash: 申购的金额\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0 指定第一个 subportfolio, 1 指定第二个 subportfolio，默认为0\n\n**返回** \n\n- Order对象或者None, 如果创建订单成功, 则返回Order对象, 失败则返回None\n\n**说明**\n\n目前暂时没有考虑T+0交易的场外货币基金\n\n- 非QDII基金，份额T+2到账并可以卖出\n- QDII基金，份额T+3到账并可以卖出\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>redeem <span id=\"redeem\"><\/span> <\/label>\n      <label>赎回基金<\/label>\n      <article>\n<pre><code class=\"python language-python\">redeem(security, amount，pindex=0)\n<\/code><\/pre>\n\n赎回基金API接口\n\n**参数**\n\n- security: 基金代码编号，OF作为尾缀的字符串，例如招商中证白酒指数分级基金为“161725.OF\"\n- amount: 赎回的份额，利用position.closeable_amount来获取可赎回份额\n- pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0 指定第一个 subportfolio, 1 指定第二个 subportfolio，默认为0\n\n**返回**\n\n- Order对象或者None, 如果创建订单成功, 则返回Order对象, 失败则返回None\n\n\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>set_redeem_latency <span id=\"set_redeem_latency\"><\/span> <\/label>\n      <label>设置赎回到账日<\/label>\n      <article>\n<pre><code class=\"python language-python\">set_redeem_latency(day，type, ref=None)\n<\/code><\/pre>\n\n设置指定类型基金的赎回到帐日，默认的赎回到帐日：非货币基金：T+4，QDII:T+7，货币型基金:T+2\n\n**参数**\n\n- day: int 类型，例如，day=4 表示 T+4 日到账，赎回到账时间至少是2天。\n- type: 可操作的场外基金类型，取值不可为空，可以包含多种场外基金的类型'bond_fund'\/'stock_fund'\/'QDII_fund'\/'money_market_fund'\/'mixture_fund'\/'open_fund'，其中 bond_fund指债券基金，stock_fund指股票型基金，QDII_fund指QDII基金，money_market_fund指货币基金，mixture_fund指混合型基金，open_fund则泛指所有的场外基金，如果不清楚具体操作的场外基金的类型，可以使用open_fund\n- ref: 参考代码，仅支持场外基金代码，如 '000300.OF'，类型为字符串，不能用列表填入一组场外基金。取值可以为空，当ref为空时，表示设置的到账时间对type类型中场外基金生效，其他type类型的场外基金使用默认值，如果不为空，则表示对type类型下的ref基金生效，除ref基金以外的其他场外基金使用默认值，包括type类型中除ref以外的其他场外基金。\n\n**返回** \n- None\n\n**示例**\n<pre><code class=\"python language-python\"># 设置股票型基金的到帐日为 T+7 \nset_redeem_latency(day=7, type='stock_fund')\n\n# 设置股票型基金中的000697.OF 的到帐日为 T+5\nset_redeem_latency(day=5, type='stock_fund',ref='000697.OF')\n<\/code><\/pre>\n      <\/article>\n    <\/div>\n\n    <div class=\"group\">\n      <label>get_fund_info <span id=\"get_fund_info\"><\/span> <\/label>\n      <label>基金基础信息数据接口<\/label>\n      <article>\n<pre><code class=\"python language-python\">get_fund_info(security, date=None)\n<\/code><\/pre>\n\n获取单个基金的基本信息\n\n**参数**\n\n- security: 基金代码\n- date: 查询日期, 一个字符串(格式类似’2015-10-15’)或者datetime.date\/datetime.datetime对象, 可以是None, 使用默认日期。回测模块中， 默认日期等于 context.current_dt。 研究模块中， 默认日期是今天。\n\n**返回** \ndict, 各 key 的含义如下：\n- fund_name: 基金全称\n- fund_type: 基金类型\n- fund_establishment_day: 基金成立日  \n- fund_manager: 基金管理人及基本信息\n- fund_management_fee: 基金管理费\n- fund_custodian_fee: 基金托管费 \n- fund_status: 基金申购赎回状态\n- fund_size: 基金规模（季度） \n- fund_share: 基金份额（季度）\n- fund_asset_allocation_proportion: 基金资产配置比例（季度）\n- heavy_hold_stocks: 基金重仓股（季度）\n- heavy_hold_stocks_proportion: 基金重仓股占基金资产净值比例（季度）\n- heavy_hold_bond: 基金重仓债券（季度）\n- heavy_hold_bond_proportion: 基金重仓债券占基金资产净值比例（季度）\n\n      <\/article>\n    <\/div>\n\n  <\/div>\n<\/section>\n<h4 id=\"\"><strong>场外基金示例策略<\/strong><\/h4>\n<pre><code class=\"python language-python\"># 导入函数库\nimport jqdata\n\n# 初始化\ndef initialize(context):\n    g.day = 0\n    # 初始化场外基金仓位\n    set_subportfolios([SubPortfolioConfig(context.portfolio.cash, 'open_fund')])\n    # 设置 QDII 的赎回到账日为 T+3\n    set_redeem_latency(3, 'QDII_fund')\n\ndef handle_data(context, data):\n    s = '000311.OF'\n    if g.day == 1:\n        o = purchase(s, 100000)\n        print o\n    if g.day == 10:\n        o2 = redeem(s, 500)\n        print o2\n    print context.current_dt\n    print context.portfolio.cash\n    print context.portfolio.total_value\n    g.day += 1\n<\/code><\/pre>\n<p><span id = \"others_func\" ><\/span><\/p>\n<h2 id=\"Python库\">Python库<\/h2>\n<p><span id = \"third_lib\" ><\/span><\/p>\n<h3 id=\"标准库\">标准库<\/h3>\n<p><span id=\"standard_library\"><\/span><\/p>\n<p>我们支持所有Python标准库(https:\/\/docs.python.org\/2\/library\/index.html)，您可以通过import的方式进行引入, 下面列出了一些常用的库：<\/p>\n<table>\n<thead>\n<tr>\n<th>库名<\/th>\n<th>帮助文档<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>array<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/array.html<\/td>\n<\/tr>\n<tr>\n<td>cmath<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/cmath.html<\/td>\n<\/tr>\n<tr>\n<td>collections<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/collections.html<\/td>\n<\/tr>\n<tr>\n<td>copy<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/copy.html<\/td>\n<\/tr>\n<tr>\n<td>datetime<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/datetime.html<\/td>\n<\/tr>\n<tr>\n<td>dateutil<\/td>\n<td>https:\/\/pypi.python.org\/pypi\/dateutils\/0.6.6<\/td>\n<\/tr>\n<tr>\n<td>functools<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/functools.html<\/td>\n<\/tr>\n<tr>\n<td>heapq<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/heapq.html<\/td>\n<\/tr>\n<tr>\n<td>itertools<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/itertools.html<\/td>\n<\/tr>\n<tr>\n<td>json<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/json.html<\/td>\n<\/tr>\n<tr>\n<td>math<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/math.html<\/td>\n<\/tr>\n<tr>\n<td>operator<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/operator.html<\/td>\n<\/tr>\n<tr>\n<td>pytz<\/td>\n<td>https:\/\/pypi.python.org\/pypi\/pytz\/2015.2<\/td>\n<\/tr>\n<tr>\n<td>random<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/random.html<\/td>\n<\/tr>\n<tr>\n<td>re<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/re.html<\/td>\n<\/tr>\n<tr>\n<td>string<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/string.html<\/td>\n<\/tr>\n<tr>\n<td>time<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/time.html<\/td>\n<\/tr>\n<tr>\n<td>xml<\/td>\n<td>https:\/\/docs.python.org\/2.7\/library\/xml.html<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<h3 id=\"第三方库\">第三方库<\/h3>\n<p><span id=\"third_library\"><\/span><\/p>\n<p>我们支持以下Python第三方库，您可以通过import的方式进行引入:\n在研究模拟中, 您可以运行 <code>!pip list<\/code> 来查看所有安装的第三库和版本.<\/p>\n<p>回测模块：<\/p>\n<blockquote>\n  <p><strong>anyjson, arch, graphviz, Lasagne, numpy, pandas, pybrain, scipy, seaborn, sklearn, statsmodels, talib, tushare, theano, requests, hmm, hmmlearn, pywt, pycrypto, beautifulsoup4, prettytable, xlrd<\/strong><\/p>\n<\/blockquote>\n<p>研究模块：<\/p>\n<blockquote>\n  <p><strong>anyjson, arch, beautifulsoup4, cvxopt, graphviz, gensim, jieba,  matplotlib, mpl_toolkits, numpy, pandas, pybrain, pymc, pillow, scipy, seaborn, sklearn, statsmodels, tables, talib, hmm, hmmlearn, tushare, theano, Lasagne, requests, pywt, zipline, xlrd, xlwt, openpyxl, snownlp, pycrypto, prettytable, seaborn, bokeh<\/strong><\/p>\n<\/blockquote>\n<p>主要模块介绍：<\/p>\n<table>\n<thead>\n<tr>\n<th>模块名称<\/th>\n<th>版本<\/th>\n<th>简介<\/th>\n<th>网址<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td><strong>arch<\/strong><\/td>\n<td>3.1<\/td>\n<td>Arch模型的lib库<\/td>\n<td>https:\/\/pypi.python.org\/pypi\/arch<\/td>\n<\/tr>\n<tr>\n<td><strong>cvxopt<\/strong><\/td>\n<td>1.1.8<\/td>\n<td>cvxopt是一个最优化计算包，进行线性规划、二次规划、半正定规划等的计算<\/td>\n<td>https:\/\/pypi.python.org\/pypi\/cvxopt\/1.1.8<\/td>\n<\/tr>\n<tr>\n<td><strong>gensim<\/strong><\/td>\n<td>0.12.2<\/td>\n<td>gensim用于计算文本相似度，依赖NumPy和SciPy这两大Python科学计算工具包<\/td>\n<td>http:\/\/radimrehurek.com\/gensim\/tutorial.html<\/td>\n<\/tr>\n<tr>\n<td><strong>jieba<\/strong><\/td>\n<td>0.37<\/td>\n<td>jieba是一个中文分词组件<\/td>\n<td>https:\/\/pypi.python.org\/pypi\/jieba<\/td>\n<\/tr>\n<tr>\n<td><strong>matplotlib<\/strong><\/td>\n<td>1.4.3<\/td>\n<td>matplotlib可能是Python 2D绘图领域使用最广泛的库。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式<\/td>\n<td>http:\/\/matplotlib.org\/contents.html<\/td>\n<\/tr>\n<tr>\n<td><strong>mpl_toolkits<\/strong><\/td>\n<td>1.4.3<\/td>\n<td>mpl_toolkits是一个Python 3D绘图领域函数库<\/td>\n<td>http:\/\/matplotlib.org\/mpl_toolkits\/index.html<\/td>\n<\/tr>\n<tr>\n<td><strong>NumPy<\/strong><\/td>\n<td>1.9.3<\/td>\n<td>NumPy系统是Python的一种开源的数值计算扩展。NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库。专为进行严格的数字处理而产生<\/td>\n<td>http:\/\/www.numpy.org\/<\/td>\n<\/tr>\n<tr>\n<td><strong>pandas<\/strong><\/td>\n<td>0.16.2<\/td>\n<td>Python Data Analysis Library 或 pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。pandas提供了大量能使我们快速便捷地处理数据的函数和方法<\/td>\n<td>http:\/\/pandas.pydata.org\/pandas-docs\/version\/0.16.2\/<\/td>\n<\/tr>\n<tr>\n<td><strong>pybrain<\/strong><\/td>\n<td>0.3<\/td>\n<td>pybrain一个开源的Python神经网络库<\/td>\n<td>http:\/\/pybrain.org\/docs\/<\/td>\n<\/tr>\n<tr>\n<td><strong>pymc<\/strong><\/td>\n<td>2.3.6<\/td>\n<td>pymc是机器学习中一个图模型的Python库<\/td>\n<td>https:\/\/pypi.python.org\/pypi\/pymc\/<\/td>\n<\/tr>\n<tr>\n<td><strong>SciPy<\/strong><\/td>\n<td>0.15.1<\/td>\n<td>SciPy是一款方便、易于使用、专为科学和工程设计的Python工具包。它包括统计，优化，整合，线性代数模块，傅里叶变换，信号和图像处理,常微分方程求解器等等<\/td>\n<td>http:\/\/www.scipy.org\/<\/td>\n<\/tr>\n<tr>\n<td><strong>seaborn<\/strong><\/td>\n<td>0.6.0<\/td>\n<td>该模块是一个统计数据可视化库<\/td>\n<td>http:\/\/web.stanford.edu\/~mwaskom\/software\/seaborn\/<\/td>\n<\/tr>\n<tr>\n<td><strong>sklearn<\/strong><\/td>\n<td>0.18<\/td>\n<td>Scikit-Learn是基于python的机器学习模块，基于BSD开源许可证。scikit-learn的基本功能主要被分为六个部分，分类，回归，聚类，数据降维，模型选择，数据预处理。Scikit-Learn中的机器学习模型非常丰富，包括SVM，决策树，GBDT，KNN等等，可以根据问题的类型选择合适的模型<\/td>\n<td>http:\/\/scikit-learn.org\/stable\/<\/td>\n<\/tr>\n<tr>\n<td><strong>Statsmodels<\/strong><\/td>\n<td>0.6.1<\/td>\n<td>Statismodels是一个Python包，提供一些互补scipy统计计算的功能，包括描述性统计和统计模型估计和推断<\/td>\n<td>http:\/\/statsmodels.sourceforge.net\/<\/td>\n<\/tr>\n<tr>\n<td><strong>PyTables<\/strong><\/td>\n<td>3.2.2<\/td>\n<td>PyTables提供了一些用于结构化数组的高级查询功能，而且还能添加列索引以提升查询速度，这跟关系型数据库所提供的表索引功能非常类似<\/td>\n<td>http:\/\/www.pytables.org\/usersguide\/tutorials.html<\/td>\n<\/tr>\n<tr>\n<td><strong>TALib<\/strong><\/td>\n<td>0.4.9<\/td>\n<td>TALib是一个处理金融数据和技术分析的开放代码库<\/td>\n<td>http:\/\/mrjbq7.github.io\/ta-lib\/funcs.html<\/td>\n<\/tr>\n<tr>\n<td><strong>hmmlearn<\/strong><\/td>\n<td>0.2.0<\/td>\n<td>是在python上实现隐马可夫模型的一个组件包<\/td>\n<td>https:\/\/github.com\/hmmlearn\/hmmlearn<\/td>\n<\/tr>\n<tr>\n<td><strong>Theano<\/strong><\/td>\n<td>0.8.1<\/td>\n<td>Pyhton深度学习库<\/td>\n<td>http:\/\/deeplearning.net\/software\/theano\/<\/td>\n<\/tr>\n<tr>\n<td><strong>Lasagne<\/strong><\/td>\n<td>0.1<\/td>\n<td>Pyhton深度学习库<\/td>\n<td>http:\/\/lasagne.readthedocs.org\/en\/latest\/<\/td>\n<\/tr>\n<tr>\n<td><strong>requests<\/strong><\/td>\n<td>2.7.0<\/td>\n<td>网络访问模块<\/td>\n<td>http:\/\/docs.python-requests.org\/en\/v2.7.0\/<\/td>\n<\/tr>\n<tr>\n<td><strong>pywt<\/strong><\/td>\n<td>0.4.0<\/td>\n<td>小波工具箱<\/td>\n<td>http:\/\/pywavelets.readthedocs.io\/en\/v0.4.0\/<\/td>\n<\/tr>\n<tr>\n<td><strong>Zipline<\/strong><\/td>\n<td>0.9.0<\/td>\n<td>开源的交易算法库，目前作为Quantopian的回溯检验引擎<\/td>\n<td>https:\/\/github.com\/quantopian\/zipline<\/td>\n<\/tr>\n<tr>\n<td><strong>xlrd<\/strong><\/td>\n<td>1.0.0<\/td>\n<td>Python语言中，读取Excel的扩展工具<\/td>\n<td>https:\/\/pypi.python.org\/pypi\/xlrd\/<\/td>\n<\/tr>\n<tr>\n<td><strong>xlwt<\/strong><\/td>\n<td>1.1.2<\/td>\n<td>Python语言中，写入Excel文件的扩展工具<\/td>\n<td>https:\/\/pypi.python.org\/pypi\/xlwt\/<\/td>\n<\/tr>\n<tr>\n<td><strong>openpyxl<\/strong><\/td>\n<td>2.4.0<\/td>\n<td>Openpyxl是一个python读写Excel 2010文件的库<\/td>\n<td>http:\/\/openpyxl.readthedocs.io\/en\/default\/<\/td>\n<\/tr>\n<tr>\n<td><strong>snownlp<\/strong><\/td>\n<td>0.12.3<\/td>\n<td>处理中文文本的Python库<\/td>\n<td>https:\/\/pypi.python.org\/pypi\/snownlp\/<\/td>\n<\/tr>\n<tr>\n<td><strong>pycrypto<\/strong><\/td>\n<td>2.6.2<\/td>\n<td>Python加密工具包<\/td>\n<td>https:\/\/pypi.python.org\/pypi\/pycrypto<\/td>\n<\/tr>\n<tr>\n<td><strong>beautifulsoup4<\/strong><\/td>\n<td>4.5.1<\/td>\n<td>python下很帅气的爬虫包<\/td>\n<td>https:\/\/www.crummy.com\/software\/BeautifulSoup\/<\/td>\n<\/tr>\n<tr>\n<td><strong>prettytable<\/strong><\/td>\n<td>0.7.2<\/td>\n<td>Python通过prettytable模块可以将输出内容如表格方式整齐的输出。<\/td>\n<td>https:\/\/pypi.python.org\/pypi\/PrettyTable<\/td>\n<\/tr>\n<tr>\n<td><strong>PyBrain<\/strong><\/td>\n<td>0.3<\/td>\n<td>Python的一个机器学习模块，它的目标是为机器学习任务提供灵活、易应、强大的机器学习算法。<\/td>\n<td>http:\/\/www.pybrain.org\/<\/td>\n<\/tr>\n<tr>\n<td><strong>seaborn<\/strong><\/td>\n<td>0.6.0<\/td>\n<td>基于matplotlib的Python可视化库<\/td>\n<td>http:\/\/seaborn.pydata.org\/<\/td>\n<\/tr>\n<tr>\n<td><strong>bokeh<\/strong><\/td>\n<td>0.9.3<\/td>\n<td>Python可视化库, 长于创建交互式图表<\/td>\n<td>http:\/\/bokeh.pydata.org\/<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<h3 id=\"共享函数库\">共享函数库<\/h3>\n<p>用户产生的函数，并分享出来。\n使用共享函数库，可以避免用户再做重复的工作，也可以学习其他宽客的代码思路。\n详情查看：帮助 -&gt; <a href=\"\/algorithm\/apishare\/list\">共享函数库<\/a><\/p>\n<h2 id=\"策略示例\">策略示例<\/h2>\n\n<h3 id=\"均线策略\">均线策略<\/h3>\n<p>当价格高于5日均线平均价格<em>1.05时买入，当价格低于5日平均价格<\/em>0.95时卖出。<\/p>\n<pre><code class=\"python language-python\"># 导入聚宽函数库\nimport jqdata\n\n# 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 定义一个全局变量, 保存要操作的股票\n    # 000001(股票:平安银行)\n    g.security = '000001.XSHE'\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n\n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle_data(context, data):\n    security = g.security\n    # 获取股票的收盘价\n    close_data = attribute_history(security, 5, '1d', ['close'])\n    # 取得过去五天的平均价格\n    MA5 = close_data['close'].mean()\n    # 取得上一时间点价格\n    current_price = close_data['close'][-1]\n    # 取得当前的现金\n    cash = context.portfolio.cash\n\n    # 如果上一时间点价格高出五天平均价5%, 则全仓买入\n    if current_price &gt; 1.05*MA5:\n        # 用所有 cash 买入股票\n        order_value(security, cash)\n        # 记录这次买入\n        log.info(\"Buying %s\" % (security))\n    # 如果上一时间点价格低于五天平均价, 则空仓卖出\n    elif current_price &lt; 0.95*MA5 and context.portfolio.positions[security].closeable_amount &gt; 0:\n        # 卖出所有股票,使这只股票的最终持有量为0\n        order_target(security, 0)\n        # 记录这次卖出\n        log.info(\"Selling %s\" % (security))\n    # 画出上一时间点价格\n    record(stock_price=current_price)\n<\/code><\/pre>\n<h3 id=\"多股票持仓示例\">多股票持仓示例<\/h3>\n<p>这是一个较简单的多股票操作示例，当价格高于三天平均价<em>1.005则买入100股，当价格小于三天平均价<\/em>0.995则卖出。<\/p>\n<pre><code class=\"python language-python\"># 导入聚宽函数库\nimport jqdata\n\ndef initialize(context):\n    # 初始化此策略\n    # 设置我们要操作的股票池\n    g.stocks = ['000001.XSHE','000002.XSHE','000004.XSHE','000005.XSHE']\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n\n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle_data(context, data):\n    # 循环每只股票\n    for security in g.stocks:\n        # 得到股票之前3天的平均价\n        vwap = data[security].vwap(3)\n        # 得到上一时间点股票平均价\n        price = data[security].close\n        # 得到当前资金余额\n        cash = context.portfolio.cash\n\n        # 如果上一时间点价格小于三天平均价*0.995，并且持有该股票，卖出\n        if price &lt; vwap * 0.995 and context.portfolio.positions[security].closeable_amount &gt; 0:\n            # 下入卖出单\n            order(security,-100)\n            # 记录这次卖出\n            log.info(\"Selling %s\" % (security))\n        # 如果上一时间点价格大于三天平均价*1.005，并且有现金余额，买入\n        elif price &gt; vwap * 1.005 and cash &gt; 0:\n            # 下入买入单\n            order(security,100)\n            # 记录这次买入\n            log.info(\"Buying %s\" % (security))\n<\/code><\/pre>\n<h3 id=\"多股票追涨策略\">多股票追涨策略<\/h3>\n<p>当股票在当日收盘30分钟内涨幅到达9.5%~9.9%时间段的时候，我们进行买入，在第二天开盘卖出。注意：<strong>请按照分钟进行回测该策略<\/strong>。<\/p>\n<pre><code class=\"python language-python\"># 导入聚宽函数库\nimport jqdata\n\n# 初始化程序, 整个回测只运行一次\ndef initialize(context):\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n\n    # 每天买入股票数量\n    g.daily_buy_count  = 5\n\n    # 设置我们要操作的股票池, 这里我们操作多只股票，下列股票选自计算机信息技术相关板块\n    g.stocks = get_industry_stocks('I64') + get_industry_stocks('I65')\n\n    # 防止板块之间重复包含某只股票, 排除掉重复的, g.stocks 现在是一个集合(set)\n    g.stocks = set(g.stocks)\n\n    # 让每天早上开盘时执行 morning_sell_all\n    run_daily(morning_sell_all, 'open')\n\ndef morning_sell_all(context):\n    # 将目前所有的股票卖出\n    for security in context.portfolio.positions:\n        # 全部卖出\n        order_target(security, 0)\n        # 记录这次卖出\n        log.info(\"Selling %s\" % (security))\n\ndef before_trading_start(context):\n    # 今天已经买入的股票\n    g.today_bought_stocks = set()\n\n    # 得到所有股票昨日收盘价, 每天只需要取一次, 所以放在 before_trading_start 中\n    g.last_df = history(1,'1d','close',g.stocks)\n\n# 在每分钟的第一秒运行, data 是上一分钟的切片数据\ndef handle_data(context, data):\n\n    # 判断是否在当日最后的2小时，我们只追涨最后2小时满足追涨条件的股票\n    if context.current_dt.hour &lt; 13:\n        return\n\n    # 每天只买这么多个\n    if len(g.today_bought_stocks) &gt;= g.daily_buy_count:\n        return\n\n    # 只遍历今天还没有买入的股票\n    for security in (g.stocks - g.today_bought_stocks):\n\n        # 得到当前价格\n        price = data[security].close\n\n        # 获取这只股票昨天收盘价\n        last_close = g.last_df[security][0]\n\n        # 如果上一时间点价格已经涨了9.5%~9.9%\n        # 今天的涨停价格区间大于1元，今天没有买入该支股票\n        if price\/last_close &gt; 1.095 \\\n                and price\/last_close &lt; 1.099 \\\n                and data[security].high_limit - last_close &gt;= 1.0:\n\n            # 得到当前资金余额\n            cash = context.portfolio.cash\n\n            # 计算今天还需要买入的股票数量\n            need_count = g.daily_buy_count - len(g.today_bought_stocks)\n\n            # 把现金分成几份,\n            buy_cash = context.portfolio.cash \/ need_count\n\n            # 买入这么多现金的股票\n            order_value(security, buy_cash)\n\n            # 放入今日已买股票的集合\n            g.today_bought_stocks.add(security)\n\n            # 记录这次买入\n            log.info(\"Buying %s\" % (security))\n\n            # 买够5个之后就不买了\n            if len(g.today_bought_stocks) &gt;= g.daily_buy_count:\n                break\n<\/code><\/pre>\n<h3 id=\"万圣节效应策略\">万圣节效应策略<\/h3>\n<p>股市投资中的“万圣节效应”是指在北半球的冬季(11月至4月份)，股市回报通常明显高於夏季(5月至10月份)。这里我们选取了中国蓝筹股，采用10月15日后买入，5月15日后卖出的简单策略进行示例。<\/p>\n<pre><code class=\"python language-python\"># 导入聚宽函数库\nimport jqdata\n\n# 初始化此策略\ndef initialize(context):\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n\n    # 设置我们要操作的股票池，这里我们选择蓝筹股\n    g.stocks = ['000001.XSHE','600000.XSHG','600019.XSHG','600028.XSHG','600030.XSHG','600036.XSHG','600519.XSHG','601398.XSHG','601857.XSHG','601988.XSHG']\n\n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle_data(context, data):\n    # 得到每只股票可以花费的现金，这里我们使用总现金股票数数量\n    cash = context.portfolio.cash \/ len(g.stocks)\n    # 获取数据\n    hist = history(1,'1d','close',g.stocks)\n    # 循环股票池\n    for security in g.stocks:\n        # 得到当前时间\n        today = context.current_dt\n        # 得到该股票上一时间点价格\n        current_price = hist[security][0]\n        # 如果当前为10月且日期大于15号，并且现金大于上一时间点价格，并且当前该股票空仓\n        if today.month == 10 and today.day &gt; 15 and cash &gt; current_price and context.portfolio.positions[security].closeable_amount == 0:\n            order_value(security, cash)\n            # 记录这次买入\n            log.info(\"Buying %s\" % (security))\n        # 如果当前为5月且日期大于15号，并且当前有该股票持仓，则卖出\n        elif today.month == 5 and today.day &gt; 15 and context.portfolio.positions[security].closeable_amount &gt; 0:\n            # 全部卖出\n            order_target(security, 0)\n            # 记录这次卖出\n            log.info(\"Selling %s\" % (security))\n<\/code><\/pre>",
  "status": "0",
  "code": "00000",
  "msg": ""
}
